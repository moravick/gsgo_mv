(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index-client.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/class-datamap.js":
/*!******************************!*\
  !*** ./src/class-datamap.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\n\n/*///////////////////////////////// ABOUT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\n\n  A class for managing hash-mapped data and detecting differences\n  in a dataset.\n\n  (1) manages differences - an array of just keys of your object is\n      passed in, and DataMap returns what's the same or different.\n  (2) stores related data by key into a Map()\n  (3) utility methods for managing collections and their objects from\n      the LokiJS database\n\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ * /////////////////////////////////////*/\n/// LIBRARIES /////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n/// CONSTANTS /////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n/// list of collection names stored in database\nconst DBKEYS = ['teachers', 'classrooms', 'groups', 'models', 'criteria', 'sentenceStarters', 'ratingsDefinitions', 'classroomResources', 'resources', 'pmcData', 'pmcData.entities', 'pmcData.comments', 'pmcData.markedread', 'pmcData.visuals']; /// list of valid database change commands\n\nconst DBCMDS = new Map([['add', 'NET:SRV_DBADD'], ['update', 'NET:SRV_DBUPDATE'], ['remove', 'NET:SRV_DBREMOVE']]); /// DECLARATIONS //////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst DBG = false;\n/**\n *  An object containing the differences detected between an array NOW vs\n *  an array the LAST TIME\n *  @typedef {Object} ArrayChangeObject\n *  @property {Array} added -\n *  @property {Array} removed -\n *  @property {Array} updated -\n */\n/// CLASS /////////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nclass DataMap {\n  constructor() {\n    this.ids = []; // array of string ids\n\n    this.idsUpdated = [];\n    this.idsAdded = [];\n    this.idsRemoved = [];\n    this.map = new Map();\n    this.selection = new Set();\n  }\n  /** Given an array of elements, return the differences since the last\n   *  call. Useful for managing data protocols that send the entire list\n   *  of entities in an array.\n   *  @param {Array<string>} arr - array of elements. The elements should be usable\n   *  as keys in a Map.\n   *  @returns {ArrayChangeObject} - { added, updated, removed }\n   */\n\n\n  GetChanges(arr) {\n    const results = DataMap.f_deltaFilterIDArray(arr, this.map); // fix bug\n\n    const {\n      added,\n      removed,\n      updated\n    } = results; // save results\n\n    this.idsAdded = added;\n    this.idsRemoved = removed;\n    this.idsUpdated = updated; // return results\n\n    return {\n      added,\n      removed,\n      updated\n    };\n  }\n  /**\n   *  @param {*} id - array value to compare\n   *  @returns {boolean} - true if id exists in the map\n   */\n\n\n  Has(id) {\n    return this.map.has(id);\n  }\n  /** Retrieve\n   *  @param {string} id - key\n   *  @returns {string} - the object associated with the key\n   */\n\n\n  Get(id) {\n    return this.map.get(id);\n  }\n  /**\n   *  @param {string} id - key\n   *  @param {string} element - element\n   */\n\n\n  Set(id, element) {\n    this.map.set(id, element);\n  }\n\n} /// STATIC METHODS ////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nDataMap.DBKEYS = DBKEYS;\nDataMap.DBCMDS = DBCMDS; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** returns an array of valid TOP LEVEL collections\n */\n\nDataMap.Collections = () => {\n  return DBKEYS.filter(el => !el.includes('.'));\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** validate that keyName is a valid DBKEY\n *  @param {string} keyName - extract from the DBSYNC data props\n */\n\n\nDataMap.IsValidKey = keyName => {\n  return DBKEYS.includes(keyName);\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** validate command is valid\n *  @param {string} command - extract from the DBSYNC data.cmd prop\n */\n\n\nDataMap.ValidateCommand = command => DBCMDS.has(command); /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** lookup server message\n *  @param {string} command - a valid key\n */\n\n\nDataMap.GetCommandMessage = command => DBCMDS.get(command); /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Used by server to parse DBQuery data object for modify, add, or update ops.\n *  For parsing the response, see ExtractSyncData\n *  There are two input data formats:\n *  key    { 'pmcData': value }\n *         .. where val is an object with an id\n *  subkey { 'pmcData.entities': { id, entities: value }\n *         .. where id is a modelId and val is a single entity obj\n *  @param {Object} data - object with properties matching DBKEY contain array of values\n *  @returns {Array} - an array of { colkey, subkey, value } for each matching DBKEY\n */\n\n\nDataMap.ExtractQueryData = data => {\n  let queries = []; // the colkey might be a compound key (e.g. pmcData.entities)\n\n  Object.keys(data).forEach(foundKey => {\n    // only return keys that match a collection name\n    if (!DataMap.IsValidKey(foundKey)) return; // process valid key\n\n    let value = data[foundKey]; // should be an object always\n\n    if (Array.isArray(value)) {\n      console.warn(`key: ${foundKey} is an array; did you mean to use ExtractSyncData() instead?`);\n      return;\n    }\n\n    if (typeof value !== 'object') {\n      console.warn(`key: ${foundKey} value is not an object`);\n      return;\n    } // prepare for write\n\n\n    const [colkey, subkey] = foundKey.split('.');\n    const entry = {\n      colkey,\n      subkey,\n      value\n    };\n    queries.push(entry);\n  });\n  return queries;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Return an array of keys and update objects. Used to parse the update or\n *  response from a DBQuery. Input formats are:\n *  .. key            { 'pmcData': [ {...} ] }\n *  .. key w/subkey   { 'pmcData.entities': [ {...} ] }\n *  Return values are:\n * .. colkey : string (e.g. 'pmcData' )\n * .. subkey : string (e.g. 'entities' )\n * .. value  : object (e.g. { id:2, type:'prop', name:'Fish' } )\n */\n\n\nDataMap.ExtractSyncData = data => {\n  const syncitems = [];\n  Object.keys(data).forEach(foundKey => {\n    // only return keys that match a collection name\n    if (!DataMap.IsValidKey(foundKey)) return; // process valid key\n\n    let values = data[foundKey]; // should be an object always\n\n    const [colkey, subkey] = foundKey.split('.');\n    values.forEach(value => {\n      const entry = {\n        colkey,\n        subkey,\n        value\n      };\n      syncitems.push(entry);\n    });\n  });\n  return syncitems;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** validate that data has valid keys DB keys. Returns number of found keys\n *  that conform to type\n *  key    { 'pmcData': value }\n *         .. where val is an object with an id\n *  subkey { 'pmcData.entities': { id, entities: value }\n *         .. where id is a modelId and val is a single entity obj\n * @param {string} cobj - collection object with collection keys\n */\n\n\nDataMap.ValidateCollections = cobj => {\n  const {\n    cmd\n  } = cobj;\n  let count = 0;\n  Object.keys(cobj).forEach(colkey => {\n    // only return colkey that match a collection name\n    if (!DataMap.IsValidKey(colkey)) return; // extract the collection\n\n    const value = cobj[colkey]; // if we got this far, then the colkey contained a non-array\n\n    let ok = true;\n\n    switch (cmd) {\n      case 'add':\n        // eslint-disable-next-line no-bitwise\n        ok &= f_validateAdd(value, colkey);\n        break;\n\n      case 'update':\n        // eslint-disable-next-line no-bitwise\n        ok &= f_validateUpdate(value, colkey);\n        break;\n\n      case 'remove':\n        // eslint-disable-next-line no-bitwise\n        ok &= f_validateRemove(value, colkey);\n        break;\n\n      default:\n        console.log(cmd);\n        throw Error(`${colkey} unknown command ${cmd}`);\n    } // switch\n\n\n    if (!ok) throw Error(`${colkey}.${cmd} single value mystery error`); // sucessful processing\n\n    count++;\n  }); // foreach colkey...loop to next one\n  // finished processing everything, return the count of processed collection\n  // if we dont' get this far, an error had been thrown\n\n  return count;\n};\n\nfunction f_validateAdd(value, key) {\n  if (!key) throw Error('arg2 key required');\n  const [colkey, subkey] = key.split('.');\n  const vtype = typeof value;\n  if (vtype !== 'object') throw Error(`${key}.add: requires OBJECTS with no id`);\n\n  if (subkey) {\n    if (!value.id) throw Error(`${key}.add requires a top-level id to select subkey field`);\n    if (value[subkey].id) throw Error(`${key}.add: ${subkey} value can not have an id`);\n  } else {\n    // eslint-disable-next-line no-lonely-if\n    if (value.id) throw Error(`${key}.add: ${colkey} value can not have an id`);\n  }\n\n  return true;\n}\n\nfunction f_validateUpdate(value, key) {\n  if (!key) throw Error('arg2 key required');\n  const [colkey, subkey] = key.split('.');\n  const vtype = typeof value;\n  if (vtype !== 'object') throw Error(`${key}.update: requires OBJECTS with an id, not ${vtype}`);\n  if (!DataMap.IsValidId(value.id)) throw Error(`${colkey}.update has invalid id ${value.id}`);\n\n  if (subkey) {\n    if (typeof value[subkey] !== 'object') throw Error(`${key}.update expected sub object`);\n    const subid = value[subkey].id;\n    if (!DataMap.IsValidId(subid)) throw Error(`${key}.update invalid id ${subid} typeof ${typeof subid}`);\n  }\n\n  return true;\n}\n\nfunction f_validateRemove(value, key) {\n  if (!key) throw Error('arg2 key required');\n  const [colkey, subkey] = key.split('.');\n  const vtype = typeof value;\n  if (vtype !== 'object') throw Error(`${key}.remove expected object value`);\n  if (!DataMap.IsValidId(value.id)) throw Error(`${key}.remove has invalid id ${value.id}`);\n\n  if (subkey) {\n    if (typeof value[subkey] !== 'object') throw Error(`${key}.remove expects sub object with id`);\n    if (!DataMap.IsValidId(value[subkey].id)) throw Error(`${key}.remove subobject must have valid id`);\n  }\n\n  return true;\n} // called by DataMap.GetChange() instance method\n// modifies elementMap\n// returns added, removed, updated arrays id list\n\n\nfunction f_deltaFilterIDArray(arr, elementMap = new Map()) {\n  // find what matches and what is new\n  const added = [];\n  const updated = [];\n  const removed = [];\n  arr.forEach(id => {\n    if (elementMap.has(id)) updated.push();else added.push(id);\n  });\n  elementMap.forEach((val, id) => {\n    if (!updated.includes(id)) removed.push(id);\n  }); // return results\n\n  return {\n    added,\n    removed,\n    updated\n  };\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Given an input, insure that it is an int >=0\n */\n\n\nDataMap.IsValidId = id => {\n  let test = Number.parseInt(id, 10) === id;\n  return test && id >= 0;\n};\n/** given an array of idsObjs, report that all that it is an int >=0\n */\n\n\nDataMap.HasValidIdObjs = ids => {\n  if (!Array.isArray(ids)) throw Error('arg1 must be array of objects');\n  return ids.every(idObj => DataMap.IsValidId(idObj.id));\n};\n/** given an array of ids, report if all vonfirm\n */\n\n\nDataMap.IsValidIdsArray = ids => {\n  if (!Array.isArray(ids)) throw Error('arg1 must be array of ints');\n  return ids.every(id => DataMap.IsValidId(id));\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Given an original object, modify a key inside it with the supplied data\n *  It's assumed the the propname is for an array of objs w/ id { id, ... }\n * @param {object} obj - object with property list to search/modify\n * @param {string} propname - name of property to extract list from obj\n * @param {object} updObj - new data to replace existing object by id match\n */\n\n\nDataMap.MutateObjectProp = (obj, propname, updObj) => {\n  if (typeof obj !== 'object') throw Error('arg1 must be object');\n  if (typeof propname !== 'string') throw Error('arg2 must be string');\n  if (typeof updObj !== 'object') throw Error('arg3 must be object');\n  if (!DataMap.IsValidId(updObj.id)) throw Error('arg3 must be object with id');\n  const id = updObj.id;\n  const list = obj[propname];\n  const found = list.find(el => el.id === id); //\n\n  if (!found) return undefined; //\n  // if we got this far, mutate\n\n  const sBefore = JSON.stringify(obj);\n  const sIdObj = JSON.stringify(updObj);\n  Object.assign(found, updObj);\n  const sAfter = JSON.stringify(obj); // return a copy without loki metadata for return\n\n  const retobj = { ...found\n  };\n  retobj.$loki = undefined;\n  retobj.meta = undefined;\n  if (DBG) console.log(`UpdateObjectProp:\\n.. old:${sBefore}\\n.. new:${sAfter}`);\n  return retobj;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Overwrite the original object with changes in second object\n */\n\n\nDataMap.MutateObject = (obj, idObj) => {\n  if (typeof obj !== 'object') throw Error('arg1 must be object');\n  if (typeof idObj !== 'object') throw Error('arg2 must be object');\n  if (!DataMap.IsValidId(idObj.id)) throw Error('arg2 must be object with id');\n  Object.assign(obj, idObj); // return a copy without loki metadata for return\n\n  const retobj = { ...obj\n  };\n  retobj.$loki = undefined;\n  retobj.meta = undefined;\n  return retobj;\n}; /// INITIALIZATION ////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n/// EXPORTS ///////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nmodule.exports = DataMap;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2xhc3MtZGF0YW1hcC5qcz80ZWFiIl0sIm5hbWVzIjpbIkRCS0VZUyIsIkRCQ01EUyIsIk1hcCIsIkRCRyIsIkRhdGFNYXAiLCJjb25zdHJ1Y3RvciIsImlkcyIsImlkc1VwZGF0ZWQiLCJpZHNBZGRlZCIsImlkc1JlbW92ZWQiLCJtYXAiLCJzZWxlY3Rpb24iLCJTZXQiLCJHZXRDaGFuZ2VzIiwiYXJyIiwicmVzdWx0cyIsImZfZGVsdGFGaWx0ZXJJREFycmF5IiwiYWRkZWQiLCJyZW1vdmVkIiwidXBkYXRlZCIsIkhhcyIsImlkIiwiaGFzIiwiR2V0IiwiZ2V0IiwiZWxlbWVudCIsInNldCIsIkNvbGxlY3Rpb25zIiwiZmlsdGVyIiwiZWwiLCJpbmNsdWRlcyIsIklzVmFsaWRLZXkiLCJrZXlOYW1lIiwiVmFsaWRhdGVDb21tYW5kIiwiY29tbWFuZCIsIkdldENvbW1hbmRNZXNzYWdlIiwiRXh0cmFjdFF1ZXJ5RGF0YSIsImRhdGEiLCJxdWVyaWVzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJmb3VuZEtleSIsInZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwiY29uc29sZSIsIndhcm4iLCJjb2xrZXkiLCJzdWJrZXkiLCJzcGxpdCIsImVudHJ5IiwicHVzaCIsIkV4dHJhY3RTeW5jRGF0YSIsInN5bmNpdGVtcyIsInZhbHVlcyIsIlZhbGlkYXRlQ29sbGVjdGlvbnMiLCJjb2JqIiwiY21kIiwiY291bnQiLCJvayIsImZfdmFsaWRhdGVBZGQiLCJmX3ZhbGlkYXRlVXBkYXRlIiwiZl92YWxpZGF0ZVJlbW92ZSIsImxvZyIsIkVycm9yIiwia2V5IiwidnR5cGUiLCJJc1ZhbGlkSWQiLCJzdWJpZCIsImVsZW1lbnRNYXAiLCJ2YWwiLCJ0ZXN0IiwiTnVtYmVyIiwicGFyc2VJbnQiLCJIYXNWYWxpZElkT2JqcyIsImV2ZXJ5IiwiaWRPYmoiLCJJc1ZhbGlkSWRzQXJyYXkiLCJNdXRhdGVPYmplY3RQcm9wIiwib2JqIiwicHJvcG5hbWUiLCJ1cGRPYmoiLCJsaXN0IiwiZm91bmQiLCJmaW5kIiwidW5kZWZpbmVkIiwic0JlZm9yZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzSWRPYmoiLCJhc3NpZ24iLCJzQWZ0ZXIiLCJyZXRvYmoiLCIkbG9raSIsIm1ldGEiLCJNdXRhdGVPYmplY3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU1BLE1BQU0sR0FBRyxDQUNiLFVBRGEsRUFFYixZQUZhLEVBR2IsUUFIYSxFQUliLFFBSmEsRUFLYixVQUxhLEVBTWIsa0JBTmEsRUFPYixvQkFQYSxFQVFiLG9CQVJhLEVBU2IsV0FUYSxFQVViLFNBVmEsRUFXYixrQkFYYSxFQVliLGtCQVphLEVBYWIsb0JBYmEsRUFjYixpQkFkYSxDQUFmLEMsQ0FpQkE7O0FBQ0EsTUFBTUMsTUFBTSxHQUFHLElBQUlDLEdBQUosQ0FBUSxDQUNyQixDQUFDLEtBQUQsRUFBUSxlQUFSLENBRHFCLEVBRXJCLENBQUMsUUFBRCxFQUFXLGtCQUFYLENBRnFCLEVBR3JCLENBQUMsUUFBRCxFQUFXLGtCQUFYLENBSHFCLENBQVIsQ0FBZixDLENBTUE7QUFDQTs7QUFDQSxNQUFNQyxHQUFHLEdBQUcsS0FBWjtBQUVBOzs7Ozs7OztBQVFBO0FBQ0E7O0FBQ0EsTUFBTUMsT0FBTixDQUFjO0FBQ1pDLGFBQVcsR0FBRztBQUNaLFNBQUtDLEdBQUwsR0FBVyxFQUFYLENBRFksQ0FDRzs7QUFDZixTQUFLQyxVQUFMLEdBQWtCLEVBQWxCO0FBQ0EsU0FBS0MsUUFBTCxHQUFnQixFQUFoQjtBQUNBLFNBQUtDLFVBQUwsR0FBa0IsRUFBbEI7QUFDQSxTQUFLQyxHQUFMLEdBQVcsSUFBSVIsR0FBSixFQUFYO0FBQ0EsU0FBS1MsU0FBTCxHQUFpQixJQUFJQyxHQUFKLEVBQWpCO0FBQ0Q7QUFFRDs7Ozs7Ozs7O0FBT0FDLFlBQVUsQ0FBQ0MsR0FBRCxFQUFN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QUFlUixTQUFmO0FBQ0FPLFFBQU0sQ0FBQ0UsSUFBUCxHQUFjVCxTQUFkO0FBQ0EsU0FBT08sTUFBUDtBQUNELENBVkQsQyxDQVlBO0FBQ0E7QUFFQTtBQUNBOzs7QUFDQUksTUFBTSxDQUFDQyxPQUFQLEdBQWlCOUYsT0FBakIiLCJmaWxlIjoiLi9zcmMvY2xhc3MtZGF0YW1hcC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG4vKi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBBQk9VVCBcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcKlxcXG5cbiAgQSBjbGFzcyBmb3IgbWFuYWdpbmcgaGFzaC1tYXBwZWQgZGF0YSBhbmQgZGV0ZWN0aW5nIGRpZmZlcmVuY2VzXG4gIGluIGEgZGF0YXNldC5cblxuICAoMSkgbWFuYWdlcyBkaWZmZXJlbmNlcyAtIGFuIGFycmF5IG9mIGp1c3Qga2V5cyBvZiB5b3VyIG9iamVjdCBpc1xuICAgICAgcGFzc2VkIGluLCBhbmQgRGF0YU1hcCByZXR1cm5zIHdoYXQncyB0aGUgc2FtZSBvciBkaWZmZXJlbnQuXG4gICgyKSBzdG9yZXMgcmVsYXRlZCBkYXRhIGJ5IGtleSBpbnRvIGEgTWFwKClcbiAgKDMpIHV0aWxpdHkgbWV0aG9kcyBmb3IgbWFuYWdpbmcgY29sbGVjdGlvbnMgYW5kIHRoZWlyIG9iamVjdHMgZnJvbVxuICAgICAgdGhlIExva2lKUyBkYXRhYmFzZVxuXG5cXCpcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcICogLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyovXG5cbi8vLyBMSUJSQVJJRVMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblxuLy8vIENPTlNUQU5UUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLy8vIGxpc3Qgb2YgY29sbGVjdGlvbiBuYW1lcyBzdG9yZWQgaW4gZGF0YWJhc2VcbmNvbnN0IERCS0VZUyA9IFtcbiAgJ3RlYWNoZXJzJyxcbiAgJ2NsYXNzcm9vbXMnLFxuICAnZ3JvdXBzJyxcbiAgJ21vZGVscycsXG4gICdjcml0ZXJpYScsXG4gICdzZW50ZW5jZVN0YXJ0ZXJzJyxcbiAgJ3JhdGluZ3NEZWZpbml0aW9ucycsXG4gICdjbGFzc3Jvb21SZXNvdXJjZXMnLFxuICAncmVzb3VyY2VzJyxcbiAgJ3BtY0RhdGEnLFxuICAncG1jRGF0YS5lbnRpdGllcycsXG4gICdwbWNEYXRhLmNvbW1lbnRzJyxcbiAgJ3BtY0RhdGEubWFya2VkcmVhZCcsXG4gICdwbWNEYXRhLnZpc3VhbHMnXG5dO1xuXG4vLy8gbGlzdCBvZiB2YWxpZCBkYXRhYmFzZSBjaGFuZ2UgY29tbWFuZHNcbmNvbnN0IERCQ01EUyA9IG5ldyBNYXAoW1xuICBbJ2FkZCcsICdORVQ6U1JWX0RCQUREJ10sXG4gIFsndXBkYXRlJywgJ05FVDpTUlZfREJVUERBVEUnXSxcbiAgWydyZW1vdmUnLCAnTkVUOlNSVl9EQlJFTU9WRSddXG5dKTtcblxuLy8vIERFQ0xBUkFUSU9OUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuY29uc3QgREJHID0gZmFsc2U7XG5cbi8qKlxuICogIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBkaWZmZXJlbmNlcyBkZXRlY3RlZCBiZXR3ZWVuIGFuIGFycmF5IE5PVyB2c1xuICogIGFuIGFycmF5IHRoZSBMQVNUIFRJTUVcbiAqICBAdHlwZWRlZiB7T2JqZWN0fSBBcnJheUNoYW5nZU9iamVjdFxuICogIEBwcm9wZXJ0eSB7QXJyYXl9IGFkZGVkIC1cbiAqICBAcHJvcGVydHkge0FycmF5fSByZW1vdmVkIC1cbiAqICBAcHJvcGVydHkge0FycmF5fSB1cGRhdGVkIC1cbiAqL1xuLy8vIENMQVNTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuY2xhc3MgRGF0YU1hcCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaWRzID0gW107IC8vIGFycmF5IG9mIHN0cmluZyBpZHNcbiAgICB0aGlzLmlkc1VwZGF0ZWQgPSBbXTtcbiAgICB0aGlzLmlkc0FkZGVkID0gW107XG4gICAgdGhpcy5pZHNSZW1vdmVkID0gW107XG4gICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgU2V0KCk7XG4gIH1cblxuICAvKiogR2l2ZW4gYW4gYXJyYXkgb2YgZWxlbWVudHMsIHJldHVybiB0aGUgZGlmZmVyZW5jZXMgc2luY2UgdGhlIGxhc3RcbiAgICogIGNhbGwuIFVzZWZ1bCBmb3IgbWFuYWdpbmcgZGF0YSBwcm90b2NvbHMgdGhhdCBzZW5kIHRoZSBlbnRpcmUgbGlzdFxuICAgKiAgb2YgZW50aXRpZXMgaW4gYW4gYXJyYXkuXG4gICAqICBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFyciAtIGFycmF5IG9mIGVsZW1lbnRzLiBUaGUgZWxlbWVudHMgc2hvdWxkIGJlIHVzYWJsZVxuICAgKiAgYXMga2V5cyBpbiBhIE1hcC5cbiAgICogIEByZXR1cm5zIHtBcnJheUNoYW5nZU9iamVjdH0gLSB7IGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkIH1cbiAgICovXG4gIEdldENoYW5nZXMoYXJyKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IERhdGFNYXAuZl9kZWx0YUZpbHRlcklEQXJyYXkoYXJyLCB0aGlzLm1hcCk7XG4gICAgLy8gZml4IGJ1Z1xuICAgIGNvbnN0IHsgYWRkZWQsIHJlbW92ZWQsIHVwZGF0ZWQgfSA9IHJlc3VsdHM7XG4gICAgLy8gc2F2ZSByZXN1bHRzXG4gICAgdGhpcy5pZHNBZGRlZCA9IGFkZGVkO1xuICAgIHRoaXMuaWRzUmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgdGhpcy5pZHNVcGRhdGVkID0gdXBkYXRlZDtcbiAgICAvLyByZXR1cm4gcmVzdWx0c1xuICAgIHJldHVybiB7IGFkZGVkLCByZW1vdmVkLCB1cGRhdGVkIH07XG4gIH1cblxuICAvKipcbiAgICogIEBwYXJhbSB7Kn0gaWQgLSBhcnJheSB2YWx1ZSB0byBjb21wYXJlXG4gICAqICBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIGlkIGV4aXN0cyBpbiB0aGUgbWFwXG4gICAqL1xuICBIYXMoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzKGlkKTtcbiAgfVxuXG4gIC8qKiBSZXRyaWV2ZVxuICAgKiAgQHBhcmFtIHtzdHJpbmd9IGlkIC0ga2V5XG4gICAqICBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXlcbiAgICovXG4gIEdldChpZCkge1xuICAgIHJldHVybiB0aGlzLm1hcC5nZXQoaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqICBAcGFyYW0ge3N0cmluZ30gaWQgLSBrZXlcbiAgICogIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50IC0gZWxlbWVudFxuICAgKi9cbiAgU2V0KGlkLCBlbGVtZW50KSB7XG4gICAgdGhpcy5tYXAuc2V0KGlkLCBlbGVtZW50KTtcbiAgfVxufVxuXG4vLy8gU1RBVElDIE1FVEhPRFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5EYXRhTWFwLkRCS0VZUyA9IERCS0VZUztcbkRhdGFNYXAuREJDTURTID0gREJDTURTO1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIHJldHVybnMgYW4gYXJyYXkgb2YgdmFsaWQgVE9QIExFVkVMIGNvbGxlY3Rpb25zXG4gKi9cbkRhdGFNYXAuQ29sbGVjdGlvbnMgPSAoKSA9PiB7XG4gIHJldHVybiBEQktFWVMuZmlsdGVyKGVsID0+ICFlbC5pbmNsdWRlcygnLicpKTtcbn07XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogdmFsaWRhdGUgdGhhdCBrZXlOYW1lIGlzIGEgdmFsaWQgREJLRVlcbiAqICBAcGFyYW0ge3N0cmluZ30ga2V5TmFtZSAtIGV4dHJhY3QgZnJvbSB0aGUgREJTWU5DIGRhdGEgcHJvcHNcbiAqL1xuRGF0YU1hcC5Jc1ZhbGlkS2V5ID0ga2V5TmFtZSA9PiB7XG4gIHJldHVybiBEQktFWVMuaW5jbHVkZXMoa2V5TmFtZSk7XG59O1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIHZhbGlkYXRlIGNvbW1hbmQgaXMgdmFsaWRcbiAqICBAcGFyYW0ge3N0cmluZ30gY29tbWFuZCAtIGV4dHJhY3QgZnJvbSB0aGUgREJTWU5DIGRhdGEuY21kIHByb3BcbiAqL1xuRGF0YU1hcC5WYWxpZGF0ZUNvbW1hbmQgPSBjb21tYW5kID0+IERCQ01EUy5oYXMoY29tbWFuZCk7XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogbG9va3VwIHNlcnZlciBtZXNzYWdlXG4gKiAgQHBhcmFtIHtzdHJpbmd9IGNvbW1hbmQgLSBhIHZhbGlkIGtleVxuICovXG5EYXRhTWFwLkdldENvbW1hbmRNZXNzYWdlID0gY29tbWFuZCA9PiBEQkNNRFMuZ2V0KGNvbW1hbmQpO1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIFVzZWQgYnkgc2VydmVyIHRvIHBhcnNlIERCUXVlcnkgZGF0YSBvYmplY3QgZm9yIG1vZGlmeSwgYWRkLCBvciB1cGRhdGUgb3BzLlxuICogIEZvciBwYXJzaW5nIHRoZSByZXNwb25zZSwgc2VlIEV4dHJhY3RTeW5jRGF0YVxuICogIFRoZXJlIGFyZSB0d28gaW5wdXQgZGF0YSBmb3JtYXRzOlxuICogIGtleSAgICB7ICdwbWNEYXRhJzogdmFsdWUgfVxuICogICAgICAgICAuLiB3aGVyZSB2YWwgaXMgYW4gb2JqZWN0IHdpdGggYW4gaWRcbiAqICBzdWJrZXkgeyAncG1jRGF0YS5lbnRpdGllcyc6IHsgaWQsIGVudGl0aWVzOiB2YWx1ZSB9XG4gKiAgICAgICAgIC4uIHdoZXJlIGlkIGlzIGEgbW9kZWxJZCBhbmQgdmFsIGlzIGEgc2luZ2xlIGVudGl0eSBvYmpcbiAqICBAcGFyYW0ge09iamVjdH0gZGF0YSAtIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgbWF0Y2hpbmcgREJLRVkgY29udGFpbiBhcnJheSBvZiB2YWx1ZXNcbiAqICBAcmV0dXJucyB7QXJyYXl9IC0gYW4gYXJyYXkgb2YgeyBjb2xrZXksIHN1YmtleSwgdmFsdWUgfSBmb3IgZWFjaCBtYXRjaGluZyBEQktFWVxuICovXG5EYXRhTWFwLkV4dHJhY3RRdWVyeURhdGEgPSBkYXRhID0+IHtcbiAgbGV0IHF1ZXJpZXMgPSBbXTtcbiAgLy8gdGhlIGNvbGtleSBtaWdodCBiZSBhIGNvbXBvdW5kIGtleSAoZS5nLiBwbWNEYXRhLmVudGl0aWVzKVxuICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZvdW5kS2V5ID0+IHtcbiAgICAvLyBvbmx5IHJldHVybiBrZXlzIHRoYXQgbWF0Y2ggYSBjb2xsZWN0aW9uIG5hbWVcbiAgICBpZiAoIURhdGFNYXAuSXNWYWxpZEtleShmb3VuZEtleSkpIHJldHVybjtcbiAgICAvLyBwcm9jZXNzIHZhbGlkIGtleVxuICAgIGxldCB2YWx1ZSA9IGRhdGFbZm91bmRLZXldOyAvLyBzaG91bGQgYmUgYW4gb2JqZWN0IGFsd2F5c1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBga2V5OiAke2ZvdW5kS2V5fSBpcyBhbiBhcnJheTsgZGlkIHlvdSBtZWFuIHRvIHVzZSBFeHRyYWN0U3luY0RhdGEoKSBpbnN0ZWFkP2BcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zb2xlLndhcm4oYGtleTogJHtmb3VuZEtleX0gdmFsdWUgaXMgbm90IGFuIG9iamVjdGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBwcmVwYXJlIGZvciB3cml0ZVxuICAgIGNvbnN0IFtjb2xrZXksIHN1YmtleV0gPSBmb3VuZEtleS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IGVudHJ5ID0geyBjb2xrZXksIHN1YmtleSwgdmFsdWUgfTtcbiAgICBxdWVyaWVzLnB1c2goZW50cnkpO1xuICB9KTtcbiAgcmV0dXJuIHF1ZXJpZXM7XG59O1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIFJldHVybiBhbiBhcnJheSBvZiBrZXlzIGFuZCB1cGRhdGUgb2JqZWN0cy4gVXNlZCB0byBwYXJzZSB0aGUgdXBkYXRlIG9yXG4gKiAgcmVzcG9uc2UgZnJvbSBhIERCUXVlcnkuIElucHV0IGZvcm1hdHMgYXJlOlxuICogIC4uIGtleSAgICAgICAgICAgIHsgJ3BtY0RhdGEnOiBbIHsuLi59IF0gfVxuICogIC4uIGtleSB3L3N1YmtleSAgIHsgJ3BtY0RhdGEuZW50aXRpZXMnOiBbIHsuLi59IF0gfVxuICogIFJldHVybiB2YWx1ZXMgYXJlOlxuICogLi4gY29sa2V5IDogc3RyaW5nIChlLmcuICdwbWNEYXRhJyApXG4gKiAuLiBzdWJrZXkgOiBzdHJpbmcgKGUuZy4gJ2VudGl0aWVzJyApXG4gKiAuLiB2YWx1ZSAgOiBvYmplY3QgKGUuZy4geyBpZDoyLCB0eXBlOidwcm9wJywgbmFtZTonRmlzaCcgfSApXG4gKi9cbkRhdGFNYXAuRXh0cmFjdFN5bmNEYXRhID0gZGF0YSA9PiB7XG4gIGNvbnN0IHN5bmNpdGVtcyA9IFtdO1xuICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZvdW5kS2V5ID0+IHtcbiAgICAvLyBvbmx5IHJldHVybiBrZXlzIHRoYXQgbWF0Y2ggYSBjb2xsZWN0aW9uIG5hbWVcbiAgICBpZiAoIURhdGFNYXAuSXNWYWxpZEtleShmb3VuZEtleSkpIHJldHVybjtcbiAgICAvLyBwcm9jZXNzIHZhbGlkIGtleVxuICAgIGxldCB2YWx1ZXMgPSBkYXRhW2ZvdW5kS2V5XTsgLy8gc2hvdWxkIGJlIGFuIG9iamVjdCBhbHdheXNcbiAgICBjb25zdCBbY29sa2V5LCBzdWJrZXldID0gZm91bmRLZXkuc3BsaXQoJy4nKTtcbiAgICB2YWx1ZXMuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBlbnRyeSA9IHsgY29sa2V5LCBzdWJrZXksIHZhbHVlIH07XG4gICAgICBzeW5jaXRlbXMucHVzaChlbnRyeSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gc3luY2l0ZW1zO1xufTtcbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiB2YWxpZGF0ZSB0aGF0IGRhdGEgaGFzIHZhbGlkIGtleXMgREIga2V5cy4gUmV0dXJucyBudW1iZXIgb2YgZm91bmQga2V5c1xuICogIHRoYXQgY29uZm9ybSB0byB0eXBlXG4gKiAga2V5ICAgIHsgJ3BtY0RhdGEnOiB2YWx1ZSB9XG4gKiAgICAgICAgIC4uIHdoZXJlIHZhbCBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpZFxuICogIHN1YmtleSB7ICdwbWNEYXRhLmVudGl0aWVzJzogeyBpZCwgZW50aXRpZXM6IHZhbHVlIH1cbiAqICAgICAgICAgLi4gd2hlcmUgaWQgaXMgYSBtb2RlbElkIGFuZCB2YWwgaXMgYSBzaW5nbGUgZW50aXR5IG9ialxuICogQHBhcmFtIHtzdHJpbmd9IGNvYmogLSBjb2xsZWN0aW9uIG9iamVjdCB3aXRoIGNvbGxlY3Rpb24ga2V5c1xuICovXG5EYXRhTWFwLlZhbGlkYXRlQ29sbGVjdGlvbnMgPSBjb2JqID0+IHtcbiAgY29uc3QgeyBjbWQgfSA9IGNvYmo7XG4gIGxldCBjb3VudCA9IDA7XG4gIE9iamVjdC5rZXlzKGNvYmopLmZvckVhY2goY29sa2V5ID0+IHtcbiAgICAvLyBvbmx5IHJldHVybiBjb2xrZXkgdGhhdCBtYXRjaCBhIGNvbGxlY3Rpb24gbmFtZVxuICAgIGlmICghRGF0YU1hcC5Jc1ZhbGlkS2V5KGNvbGtleSkpIHJldHVybjtcbiAgICAvLyBleHRyYWN0IHRoZSBjb2xsZWN0aW9uXG4gICAgY29uc3QgdmFsdWUgPSBjb2JqW2NvbGtleV07XG4gICAgLy8gaWYgd2UgZ290IHRoaXMgZmFyLCB0aGVuIHRoZSBjb2xrZXkgY29udGFpbmVkIGEgbm9uLWFycmF5XG4gICAgbGV0IG9rID0gdHJ1ZTtcbiAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgb2sgJj0gZl92YWxpZGF0ZUFkZCh2YWx1ZSwgY29sa2V5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICBvayAmPSBmX3ZhbGlkYXRlVXBkYXRlKHZhbHVlLCBjb2xrZXkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JlbW92ZSc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIG9rICY9IGZfdmFsaWRhdGVSZW1vdmUodmFsdWUsIGNvbGtleSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS5sb2coY21kKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoYCR7Y29sa2V5fSB1bmtub3duIGNvbW1hbmQgJHtjbWR9YCk7XG4gICAgfSAvLyBzd2l0Y2hcbiAgICBpZiAoIW9rKSB0aHJvdyBFcnJvcihgJHtjb2xrZXl9LiR7Y21kfSBzaW5nbGUgdmFsdWUgbXlzdGVyeSBlcnJvcmApO1xuICAgIC8vIHN1Y2Vzc2Z1bCBwcm9jZXNzaW5nXG4gICAgY291bnQrKztcbiAgfSk7IC8vIGZvcmVhY2ggY29sa2V5Li4ubG9vcCB0byBuZXh0IG9uZVxuXG4gIC8vIGZpbmlzaGVkIHByb2Nlc3NpbmcgZXZlcnl0aGluZywgcmV0dXJuIHRoZSBjb3VudCBvZiBwcm9jZXNzZWQgY29sbGVjdGlvblxuICAvLyBpZiB3ZSBkb250JyBnZXQgdGhpcyBmYXIsIGFuIGVycm9yIGhhZCBiZWVuIHRocm93blxuICByZXR1cm4gY291bnQ7XG59O1xuXG5mdW5jdGlvbiBmX3ZhbGlkYXRlQWRkKHZhbHVlLCBrZXkpIHtcbiAgaWYgKCFrZXkpIHRocm93IEVycm9yKCdhcmcyIGtleSByZXF1aXJlZCcpO1xuICBjb25zdCBbY29sa2V5LCBzdWJrZXldID0ga2V5LnNwbGl0KCcuJyk7XG4gIGNvbnN0IHZ0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodnR5cGUgIT09ICdvYmplY3QnKSB0aHJvdyBFcnJvcihgJHtrZXl9LmFkZDogcmVxdWlyZXMgT0JKRUNUUyB3aXRoIG5vIGlkYCk7XG4gIGlmIChzdWJrZXkpIHtcbiAgICBpZiAoIXZhbHVlLmlkKVxuICAgICAgdGhyb3cgRXJyb3IoYCR7a2V5fS5hZGQgcmVxdWlyZXMgYSB0b3AtbGV2ZWwgaWQgdG8gc2VsZWN0IHN1YmtleSBmaWVsZGApO1xuICAgIGlmICh2YWx1ZVtzdWJrZXldLmlkKVxuICAgICAgdGhyb3cgRXJyb3IoYCR7a2V5fS5hZGQ6ICR7c3Via2V5fSB2YWx1ZSBjYW4gbm90IGhhdmUgYW4gaWRgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZWx5LWlmXG4gICAgaWYgKHZhbHVlLmlkKSB0aHJvdyBFcnJvcihgJHtrZXl9LmFkZDogJHtjb2xrZXl9IHZhbHVlIGNhbiBub3QgaGF2ZSBhbiBpZGApO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZl92YWxpZGF0ZVVwZGF0ZSh2YWx1ZSwga2V5KSB7XG4gIGlmICgha2V5KSB0aHJvdyBFcnJvcignYXJnMiBrZXkgcmVxdWlyZWQnKTtcbiAgY29uc3QgW2NvbGtleSwgc3Via2V5XSA9IGtleS5zcGxpdCgnLicpO1xuICBjb25zdCB2dHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHZ0eXBlICE9PSAnb2JqZWN0JylcbiAgICB0aHJvdyBFcnJvcihgJHtrZXl9LnVwZGF0ZTogcmVxdWlyZXMgT0JKRUNUUyB3aXRoIGFuIGlkLCBub3QgJHt2dHlwZX1gKTtcbiAgaWYgKCFEYXRhTWFwLklzVmFsaWRJZCh2YWx1ZS5pZCkpXG4gICAgdGhyb3cgRXJyb3IoYCR7Y29sa2V5fS51cGRhdGUgaGFzIGludmFsaWQgaWQgJHt2YWx1ZS5pZH1gKTtcbiAgaWYgKHN1YmtleSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWVbc3Via2V5XSAhPT0gJ29iamVjdCcpXG4gICAgICB0aHJvdyBFcnJvcihgJHtrZXl9LnVwZGF0ZSBleHBlY3RlZCBzdWIgb2JqZWN0YCk7XG4gICAgY29uc3Qgc3ViaWQgPSB2YWx1ZVtzdWJrZXldLmlkO1xuICAgIGlmICghRGF0YU1hcC5Jc1ZhbGlkSWQoc3ViaWQpKVxuICAgICAgdGhyb3cgRXJyb3IoYCR7a2V5fS51cGRhdGUgaW52YWxpZCBpZCAke3N1YmlkfSB0eXBlb2YgJHt0eXBlb2Ygc3ViaWR9YCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBmX3ZhbGlkYXRlUmVtb3ZlKHZhbHVlLCBrZXkpIHtcbiAgaWYgKCFrZXkpIHRocm93IEVycm9yKCdhcmcyIGtleSByZXF1aXJlZCcpO1xuICBjb25zdCBbY29sa2V5LCBzdWJrZXldID0ga2V5LnNwbGl0KCcuJyk7XG4gIGNvbnN0IHZ0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodnR5cGUgIT09ICdvYmplY3QnKSB0aHJvdyBFcnJvcihgJHtrZXl9LnJlbW92ZSBleHBlY3RlZCBvYmplY3QgdmFsdWVgKTtcbiAgaWYgKCFEYXRhTWFwLklzVmFsaWRJZCh2YWx1ZS5pZCkpXG4gICAgdGhyb3cgRXJyb3IoYCR7a2V5fS5yZW1vdmUgaGFzIGludmFsaWQgaWQgJHt2YWx1ZS5pZH1gKTtcbiAgaWYgKHN1YmtleSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWVbc3Via2V5XSAhPT0gJ29iamVjdCcpXG4gICAgICB0aHJvdyBFcnJvcihgJHtrZXl9LnJlbW92ZSBleHBlY3RzIHN1YiBvYmplY3Qgd2l0aCBpZGApO1xuICAgIGlmICghRGF0YU1hcC5Jc1ZhbGlkSWQodmFsdWVbc3Via2V5XS5pZCkpXG4gICAgICB0aHJvdyBFcnJvcihgJHtrZXl9LnJlbW92ZSBzdWJvYmplY3QgbXVzdCBoYXZlIHZhbGlkIGlkYCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4vLyBjYWxsZWQgYnkgRGF0YU1hcC5HZXRDaGFuZ2UoKSBpbnN0YW5jZSBtZXRob2Rcbi8vIG1vZGlmaWVzIGVsZW1lbnRNYXBcbi8vIHJldHVybnMgYWRkZWQsIHJlbW92ZWQsIHVwZGF0ZWQgYXJyYXlzIGlkIGxpc3RcbmZ1bmN0aW9uIGZfZGVsdGFGaWx0ZXJJREFycmF5KGFyciwgZWxlbWVudE1hcCA9IG5ldyBNYXAoKSkge1xuICAvLyBmaW5kIHdoYXQgbWF0Y2hlcyBhbmQgd2hhdCBpcyBuZXdcbiAgY29uc3QgYWRkZWQgPSBbXTtcbiAgY29uc3QgdXBkYXRlZCA9IFtdO1xuICBjb25zdCByZW1vdmVkID0gW107XG5cbiAgYXJyLmZvckVhY2goaWQgPT4ge1xuICAgIGlmIChlbGVtZW50TWFwLmhhcyhpZCkpIHVwZGF0ZWQucHVzaCgpO1xuICAgIGVsc2UgYWRkZWQucHVzaChpZCk7XG4gIH0pO1xuICBlbGVtZW50TWFwLmZvckVhY2goKHZhbCwgaWQpID0+IHtcbiAgICBpZiAoIXVwZGF0ZWQuaW5jbHVkZXMoaWQpKSByZW1vdmVkLnB1c2goaWQpO1xuICB9KTtcbiAgLy8gcmV0dXJuIHJlc3VsdHNcbiAgcmV0dXJuIHsgYWRkZWQsIHJlbW92ZWQsIHVwZGF0ZWQgfTtcbn1cblxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIEdpdmVuIGFuIGlucHV0LCBpbnN1cmUgdGhhdCBpdCBpcyBhbiBpbnQgPj0wXG4gKi9cbkRhdGFNYXAuSXNWYWxpZElkID0gaWQgPT4ge1xuICBsZXQgdGVzdCA9IE51bWJlci5wYXJzZUludChpZCwgMTApID09PSBpZDtcbiAgcmV0dXJuIHRlc3QgJiYgaWQgPj0gMDtcbn07XG4vKiogZ2l2ZW4gYW4gYXJyYXkgb2YgaWRzT2JqcywgcmVwb3J0IHRoYXQgYWxsIHRoYXQgaXQgaXMgYW4gaW50ID49MFxuICovXG5EYXRhTWFwLkhhc1ZhbGlkSWRPYmpzID0gaWRzID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGlkcykpIHRocm93IEVycm9yKCdhcmcxIG11c3QgYmUgYXJyYXkgb2Ygb2JqZWN0cycpO1xuICByZXR1cm4gaWRzLmV2ZXJ5KGlkT2JqID0+IERhdGFNYXAuSXNWYWxpZElkKGlkT2JqLmlkKSk7XG59O1xuLyoqIGdpdmVuIGFuIGFycmF5IG9mIGlkcywgcmVwb3J0IGlmIGFsbCB2b25maXJtXG4gKi9cbkRhdGFNYXAuSXNWYWxpZElkc0FycmF5ID0gaWRzID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGlkcykpIHRocm93IEVycm9yKCdhcmcxIG11c3QgYmUgYXJyYXkgb2YgaW50cycpO1xuICByZXR1cm4gaWRzLmV2ZXJ5KGlkID0+IERhdGFNYXAuSXNWYWxpZElkKGlkKSk7XG59O1xuXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogR2l2ZW4gYW4gb3JpZ2luYWwgb2JqZWN0LCBtb2RpZnkgYSBrZXkgaW5zaWRlIGl0IHdpdGggdGhlIHN1cHBsaWVkIGRhdGFcbiAqICBJdCdzIGFzc3VtZWQgdGhlIHRoZSBwcm9wbmFtZSBpcyBmb3IgYW4gYXJyYXkgb2Ygb2JqcyB3LyBpZCB7IGlkLCAuLi4gfVxuICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIG9iamVjdCB3aXRoIHByb3BlcnR5IGxpc3QgdG8gc2VhcmNoL21vZGlmeVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BuYW1lIC0gbmFtZSBvZiBwcm9wZXJ0eSB0byBleHRyYWN0IGxpc3QgZnJvbSBvYmpcbiAqIEBwYXJhbSB7b2JqZWN0fSB1cGRPYmogLSBuZXcgZGF0YSB0byByZXBsYWNlIGV4aXN0aW5nIG9iamVjdCBieSBpZCBtYXRjaFxuICovXG5EYXRhTWFwLk11dGF0ZU9iamVjdFByb3AgPSAob2JqLCBwcm9wbmFtZSwgdXBkT2JqKSA9PiB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgdGhyb3cgRXJyb3IoJ2FyZzEgbXVzdCBiZSBvYmplY3QnKTtcbiAgaWYgKHR5cGVvZiBwcm9wbmFtZSAhPT0gJ3N0cmluZycpIHRocm93IEVycm9yKCdhcmcyIG11c3QgYmUgc3RyaW5nJyk7XG4gIGlmICh0eXBlb2YgdXBkT2JqICE9PSAnb2JqZWN0JykgdGhyb3cgRXJyb3IoJ2FyZzMgbXVzdCBiZSBvYmplY3QnKTtcbiAgaWYgKCFEYXRhTWFwLklzVmFsaWRJZCh1cGRPYmouaWQpKSB0aHJvdyBFcnJvcignYXJnMyBtdXN0IGJlIG9iamVjdCB3aXRoIGlkJyk7XG4gIGNvbnN0IGlkID0gdXBkT2JqLmlkO1xuICBjb25zdCBsaXN0ID0gb2JqW3Byb3BuYW1lXTtcbiAgY29uc3QgZm91bmQgPSBsaXN0LmZpbmQoZWwgPT4gZWwuaWQgPT09IGlkKTtcbiAgLy9cbiAgaWYgKCFmb3VuZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgLy9cbiAgLy8gaWYgd2UgZ290IHRoaXMgZmFyLCBtdXRhdGVcbiAgY29uc3Qgc0JlZm9yZSA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gIGNvbnN0IHNJZE9iaiA9IEpTT04uc3RyaW5naWZ5KHVwZE9iaik7XG4gIE9iamVjdC5hc3NpZ24oZm91bmQsIHVwZE9iaik7XG4gIGNvbnN0IHNBZnRlciA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gIC8vIHJldHVybiBhIGNvcHkgd2l0aG91dCBsb2tpIG1ldGFkYXRhIGZvciByZXR1cm5cbiAgY29uc3QgcmV0b2JqID0geyAuLi5mb3VuZCB9O1xuICByZXRvYmouJGxva2kgPSB1bmRlZmluZWQ7XG4gIHJldG9iai5tZXRhID0gdW5kZWZpbmVkO1xuICBpZiAoREJHKSBjb25zb2xlLmxvZyhgVXBkYXRlT2JqZWN0UHJvcDpcXG4uLiBvbGQ6JHtzQmVmb3JlfVxcbi4uIG5ldzoke3NBZnRlcn1gKTtcbiAgcmV0dXJuIHJldG9iajtcbn07XG5cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBPdmVyd3JpdGUgdGhlIG9yaWdpbmFsIG9iamVjdCB3aXRoIGNoYW5nZXMgaW4gc2Vjb25kIG9iamVjdFxuICovXG5EYXRhTWFwLk11dGF0ZU9iamVjdCA9IChvYmosIGlkT2JqKSA9PiB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgdGhyb3cgRXJyb3IoJ2FyZzEgbXVzdCBiZSBvYmplY3QnKTtcbiAgaWYgKHR5cGVvZiBpZE9iaiAhPT0gJ29iamVjdCcpIHRocm93IEVycm9yKCdhcmcyIG11c3QgYmUgb2JqZWN0Jyk7XG4gIGlmICghRGF0YU1hcC5Jc1ZhbGlkSWQoaWRPYmouaWQpKSB0aHJvdyBFcnJvcignYXJnMiBtdXN0IGJlIG9iamVjdCB3aXRoIGlkJyk7XG4gIE9iamVjdC5hc3NpZ24ob2JqLCBpZE9iaik7XG4gIC8vIHJldHVybiBhIGNvcHkgd2l0aG91dCBsb2tpIG1ldGFkYXRhIGZvciByZXR1cm5cbiAgY29uc3QgcmV0b2JqID0geyAuLi5vYmogfTtcbiAgcmV0b2JqLiRsb2tpID0gdW5kZWZpbmVkO1xuICByZXRvYmoubWV0YSA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIHJldG9iajtcbn07XG5cbi8vLyBJTklUSUFMSVpBVElPTiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblxuLy8vIEVYUE9SVFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTWFwO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/class-datamap.js\n");

/***/ }),

/***/ "./src/class-messager.js":
/*!*******************************!*\
  !*** ./src/class-messager.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable @typescript-eslint/no-use-before-define */\n\n/*//////////////////////////////// ABOUT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\n\n    Messager - Handle a collection of named events and their handlers.\n    https://en.wikipedia.org/wiki/Event-driven_architecture#JavaScript\n\n    This is a low-level class used by other URSYS modules both by client\n    browsers and nodejs.\n\n    NOTE: CallerReturnFunctions receive data object AND control object.\n    The control object has the \"return\" function that closes a transaction;\n    this is useful for async operations without Promises.\n\n    NOTE: When providing a handlerFunc, users should be aware of binding\n    context using Function.prototype.bind() or by using arrow functions\n\\\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ * //////////////////////////////////////*/\n// NOTE: This module uses the COMMONJS module format for compatibility\n// between node and browser-side Javascript.\nconst NetPacket = __webpack_require__(/*! ./class-netpacket */ \"./src/class-netpacket.js\"); /// MODULE VARS ///////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nlet MSGR_IDCOUNT = 0;\nlet DBG = true; /// URSYS MESSAGER CLASS //////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/**\n * Implement network-aware message passing scheme based on message strings passing\n * single data objects. Message table stores multiple message handlers as a set\n * to avoid multiple registered handlers\n */\n\nclass Messager {\n  constructor() {\n    this.handlerMap = new Map(); // message map storing sets of functions\n\n    this.messager_id = ++MSGR_IDCOUNT;\n  } /// FIRE ONCE EVENTS //////////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /**\n   * Register a message string to a handler function that will receive a mutable\n   * data object that is returned at the end of the handler function\n   * @example Subscribe('MY_MESSAGE',(data)=>{ return data; });\n   * @param {string} mesgName message to register a handler for\n   * @param {function} handlerFunc function receiving 'data' object\n   * @param {Object} [options] options\n   * @param {string} [options.handlerUID] URSYS_ID identifies group, attaches handler\n   * @param {string} [options.info] description of message handler\n   * @param {Object} [options.syntax] dictionary of data object properties accepted\n   */\n\n\n  Subscribe(mesgName, handlerFunc, options = {}) {\n    let {\n      handlerUID\n    } = options;\n    let {\n      syntax\n    } = options;\n    let {\n      fromNet\n    } = options;\n\n    if (typeof handlerFunc !== 'function') {\n      throw Error('arg2 must be a function');\n    }\n\n    if (typeof handlerUID === 'string') {\n      // bind the URChan uid to the handlerFunc function for convenient access\n      // by the message dispatcher\n      handlerFunc.ulink_id = handlerUID;\n    }\n\n    if (typeof fromNet === 'boolean') {\n      // true if this subscriber wants to receive network messages\n      handlerFunc.fromNet = fromNet;\n    }\n\n    let handlers = this.handlerMap.get(mesgName);\n\n    if (!handlers) {\n      handlers = new Set();\n      this.handlerMap.set(mesgName, handlers);\n    } // syntax annotation\n\n\n    if (syntax) handlerFunc.umesg = {\n      syntax\n    }; // saved function to handler\n\n    handlers.add(handlerFunc);\n    return this;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /**\n   * Unsubscribe a handler function from a registered message. The handler\n   * function object must be the same one used to register it.\n   * @param {string} mesgName message to unregister a handler for\n   * @param {function} handlerFunc function originally registered\n   */\n\n\n  Unsubscribe(mesgName, handlerFunc) {\n    if (!arguments.length) {\n      this.handlerMap.clear();\n    } else if (arguments.length === 1) {\n      this.handlerMap.delete(mesgName);\n    } else {\n      const handlers = this.handlerMap.get(mesgName);\n\n      if (handlers) {\n        handlers.delete(handlerFunc);\n      }\n    }\n\n    return this;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /**\n   * Publish a message with data payload\n   * @param {string} mesgName message to send data to\n   * @param {Object} inData parameters for the message handler\n   * @param {Object} [options] options\n   * @param {string} [options.srcUID] URSYS_ID group that is sending the\n   * message. If this is set, then the sending URSYS_ID can receive its own\n   * message request.\n   * @param {string} [options.type] type of message (mcall)\n   * @param {boolean} [options.toLocal=true] send to local message handlers\n   * @param {boolean} [options.toNet=false] send to network message handlers\n   */\n\n\n  Publish(mesgName, inData, options = {}) {\n    let {\n      srcUID,\n      type\n    } = options;\n    let {\n      toLocal = true,\n      toNet = false\n    } = options;\n    const handlers = this.handlerMap.get(mesgName); /// toLocal\n\n    if (handlers && toLocal) handlers.forEach(handlerFunc => {\n      // handlerFunc signature: (data,dataReturn) => {}\n      // handlerFunc has ulink_id property to note originating URCHAN object\n      // skip \"same origin\" calls\n      if (srcUID && handlerFunc.ulink_id === srcUID) {\n        console.warn(`MessagerSend: [${mesgName}] skip call since origin = destination; use Signal() if intended`);\n        return;\n      } // trigger the local handler (no return expected)\n\n\n      handlerFunc(inData, {}); // second param is for control message expansion\n    }); // end handlers.forEach\n    /// toNetwork\n\n    if (toNet) {\n      let pkt = new NetPacket(mesgName, inData, type);\n      pkt.SocketSend();\n    } // end toNetwork\n\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /**\n   * Publish message to everyone, local and network, and also mirrors back to self.\n   * This is a wrapper for Publish() that ensures that srcUID is overridden.\n   * @param {string} mesgName message to send data to\n   * @param {Object} inData parameters for the message handler\n   * @param {Object} [options] see Publish() for option details\n   */\n\n\n  Signal(mesgName, data, options = {}) {\n    if (options.srcUID) {\n      console.warn(`overriding srcUID ${options.srcUID} with NULL because Signal() doesn't use it`);\n      options.srcUID = null;\n    }\n\n    this.Publish(mesgName, data, options);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /**\n   * Issue a message transaction. Returns an array of promises. Works across\n   * the network.\n   * @param {string} mesgName message to send data to\n   * @param {Object} inData parameters for the message handler\n   * @param {Object} [options] see Publish() for option details\n   * @returns {Array} an array of Promises\n   */\n\n\n  async CallAsync(mesgName, inData, options = {}) {\n    let {\n      srcUID,\n      type\n    } = options;\n    let {\n      toLocal = true,\n      toNet = true\n    } = options;\n    let {\n      fromNet = false\n    } = options;\n    const channel = NetPacket.ExtractChannel(mesgName);\n    const handlers = this.handlerMap.get(mesgName);\n    let promises = []; /// handle a call from the network\n\n    if (toLocal) {\n      if (!channel.LOCAL && !fromNet) throw Error(`'${mesgName}' for local calls remove channel prefix`);\n\n      if (handlers) {\n        handlers.forEach(handlerFunc => {\n          /*/\n          handlerFunc signature: (data,dataReturn) => {}\n          handlerFunc has ulink_id property to note originating URCHAN object\n          handlerFunc has fromNet property if it expects to receive network sourced calls\n          /*/\n          // skip calls that don't have their fromNet stat set if it's a net call\n          if (fromNet && !handlerFunc.fromNet) {\n            if (DBG) console.warn(`MessagerCall: [${mesgName}] skip netcall for handler uninterested in net`);\n            return;\n          } // skip \"same origin\" calls\n\n\n          if (srcUID && handlerFunc.ulink_id === srcUID) {\n            if (DBG) console.warn(`MessagerCall: [${mesgName}] skip call since origin = destination; use Signal() if intended`);\n            return;\n          } // Create a promise. if handlerFunc returns a promise, it follows\n\n\n          let p = f_MakeResolverFunction(handlerFunc, inData);\n          promises.push(p);\n        }); // end foreach\n      } else {\n        // no handlers\n        promises.push(Promise.resolve({\n          error: 'local message handler not found'\n        }));\n      }\n    } // to local\n    // end if handlers\n    /// resolver function\n    /// remember MESSAGER class is used for more than just Network Calls\n    /// the state manager also uses it, so the resolved value may be of any type\n\n\n    function f_MakeResolverFunction(handlerFunc) {\n      return new Promise(resolve => {\n        let retval = handlerFunc(inData, {\n          /*control functions go here*/\n        });\n        resolve(retval);\n      });\n    } /// toNetwork\n\n\n    if (toNet) {\n      if (!channel.NET) throw Error('net calls must use NET: message prefix');\n      type = type || 'mcall';\n      let pkt = new NetPacket(mesgName, inData, type);\n      let p = pkt.PromiseTransaction();\n      promises.push(p);\n    } // end toNetwork\n    /// do the work\n\n\n    let resArray = await Promise.all(promises);\n    let resObj = Object.assign({}, ...resArray);\n    return resObj;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /**\n   * Get list of messages that are handled by this Messager instance.\n   * @returns {Array<string>} message name strings\n   */\n\n\n  MessageNames() {\n    let handlers = [];\n    this.handlerMap.forEach((set, key) => {\n      handlers.push(key);\n      if (DBG) console.log(`handler: ${key}`);\n    });\n    return handlers;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /**\n   * Get list of messages that are published to the network\n   * @returns {Array<string>} message name strings\n   */\n\n\n  NetMessageNames() {\n    let handlers = [];\n    this.handlerMap.forEach((set, key) => {\n      let addMessage = false; // eslint-disable-next-line no-return-assign, no-bitwise\n\n      set.forEach(func => addMessage |= func.fromNet === true);\n      if (addMessage) handlers.push(key);\n    });\n    return handlers;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /**\n   * Check to see if a message is handled by this Messager instance\n   * @param {string=''} msg message name to check\n   * @returns {boolean} true if message name is handled\n   */\n\n\n  HasMessageName(msg = '') {\n    return this.handlerMap.has(msg);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /**\n   * Ensure that the passed message names really exist in this Messager\n   * instance\n   * @param {Array<string>} msgs\n   */\n\n\n  ValidateMessageNames(msgs = []) {\n    const valid = [];\n    msgs.forEach(name => {\n      if (this.HasMessageName(name)) valid.push(name);else throw new Error(`ValidateMessageNames() found invalid message '${name}'`);\n    });\n    return valid;\n  }\n\n} // class Messager\n/// EXPORT CLASS DEFINITION ///////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nmodule.exports = Messager;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2xhc3MtbWVzc2FnZXIuanM/ODUwYyJdLCJuYW1lcyI6WyJOZXRQYWNrZXQiLCJyZXF1aXJlIiwiTVNHUl9JRENPVU5UIiwiREJHIiwiTWVzc2FnZXIiLCJjb25zdHJ1Y3RvciIsImhhbmRsZXJNYXAiLCJNYXAiLCJtZXNzYWdlcl9pZCIsIlN1YnNjcmliZSIsIm1lc2dOYW1lIiwiaGFuZGxlckZ1bmMiLCJvcHRpb25zIiwiaGFuZGxlclVJRCIsInN5bnRheCIsImZyb21OZXQiLCJFcnJvciIsInVsaW5rX2lkIiwiaGFuZGxlcnMiLCJnZXQiLCJTZXQiLCJzZXQiLCJ1bWVzZyIsImFkZCIsIlVuc3Vic2NyaWJlIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiY2xlYXIiLCJkZWxldGUiLCJQdWJsaXNoIiwiaW5EYXRhIiwic3JjVUlEIiwidHlwZSIsInRvTG9jYWwiLCJ0b05ldCIsImZvckVhY2giLCJjb25zb2xlIiwid2FybiIsInBrdCIsIlNvY2tldFNlbmQiLCJTaWduYWwiLCJkYXRhIiwiQ2FsbEFzeW5jIiwiY2hhbm5lbCIsIkV4dHJhY3RDaGFubmVsIiwicHJvbWlzZXMiLCJMT0NBTCIsInAiLCJmX01ha2VSZXNvbHZlckZ1bmN0aW9uIiwicHVzaCIsIlByb21pc2UiLCJyZXNvbHZlIiwiZXJyb3IiLCJyZXR2YWwiLCJORVQiLCJQcm9taXNlVHJhbnNhY3Rpb24iLCJyZXNBcnJheSIsImFsbCIsInJlc09iaiIsIk9iamVjdCIsImFzc2lnbiIsIk1lc3NhZ2VOYW1lcyIsImtleSIsImxvZyIsIk5ldE1lc3NhZ2VOYW1lcyIsImFkZE1lc3NhZ2UiLCJmdW5jIiwiSGFzTWVzc2FnZU5hbWUiLCJtc2ciLCJoYXMiLCJWYWxpZGF0ZU1lc3NhZ2VOYW1lcyIsIm1zZ3MiLCJ2YWxpZCIsIm5hbWUiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBQ0Es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ZSI6Ii4vc3JjL2NsYXNzLW1lc3NhZ2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG4vKi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIEFCT1VUIFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCpcXFxuXG4gICAgTWVzc2FnZXIgLSBIYW5kbGUgYSBjb2xsZWN0aW9uIG9mIG5hbWVkIGV2ZW50cyBhbmQgdGhlaXIgaGFuZGxlcnMuXG4gICAgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXZlbnQtZHJpdmVuX2FyY2hpdGVjdHVyZSNKYXZhU2NyaXB0XG5cbiAgICBUaGlzIGlzIGEgbG93LWxldmVsIGNsYXNzIHVzZWQgYnkgb3RoZXIgVVJTWVMgbW9kdWxlcyBib3RoIGJ5IGNsaWVudFxuICAgIGJyb3dzZXJzIGFuZCBub2RlanMuXG5cbiAgICBOT1RFOiBDYWxsZXJSZXR1cm5GdW5jdGlvbnMgcmVjZWl2ZSBkYXRhIG9iamVjdCBBTkQgY29udHJvbCBvYmplY3QuXG4gICAgVGhlIGNvbnRyb2wgb2JqZWN0IGhhcyB0aGUgXCJyZXR1cm5cIiBmdW5jdGlvbiB0aGF0IGNsb3NlcyBhIHRyYW5zYWN0aW9uO1xuICAgIHRoaXMgaXMgdXNlZnVsIGZvciBhc3luYyBvcGVyYXRpb25zIHdpdGhvdXQgUHJvbWlzZXMuXG5cbiAgICBOT1RFOiBXaGVuIHByb3ZpZGluZyBhIGhhbmRsZXJGdW5jLCB1c2VycyBzaG91bGQgYmUgYXdhcmUgb2YgYmluZGluZ1xuICAgIGNvbnRleHQgdXNpbmcgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQoKSBvciBieSB1c2luZyBhcnJvdyBmdW5jdGlvbnNcblxcXG5cXCpcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCAqIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vKi9cblxuLy8gTk9URTogVGhpcyBtb2R1bGUgdXNlcyB0aGUgQ09NTU9OSlMgbW9kdWxlIGZvcm1hdCBmb3IgY29tcGF0aWJpbGl0eVxuLy8gYmV0d2VlbiBub2RlIGFuZCBicm93c2VyLXNpZGUgSmF2YXNjcmlwdC5cbmNvbnN0IE5ldFBhY2tldCA9IHJlcXVpcmUoJy4vY2xhc3MtbmV0cGFja2V0Jyk7XG5cbi8vLyBNT0RVTEUgVkFSUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbmxldCBNU0dSX0lEQ09VTlQgPSAwO1xubGV0IERCRyA9IHRydWU7XG5cbi8vLyBVUlNZUyBNRVNTQUdFUiBDTEFTUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKlxuICogSW1wbGVtZW50IG5ldHdvcmstYXdhcmUgbWVzc2FnZSBwYXNzaW5nIHNjaGVtZSBiYXNlZCBvbiBtZXNzYWdlIHN0cmluZ3MgcGFzc2luZ1xuICogc2luZ2xlIGRhdGEgb2JqZWN0cy4gTWVzc2FnZSB0YWJsZSBzdG9yZXMgbXVsdGlwbGUgbWVzc2FnZSBoYW5kbGVycyBhcyBhIHNldFxuICogdG8gYXZvaWQgbXVsdGlwbGUgcmVnaXN0ZXJlZCBoYW5kbGVyc1xuICovXG5jbGFzcyBNZXNzYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGFuZGxlck1hcCA9IG5ldyBNYXAoKTsgLy8gbWVzc2FnZSBtYXAgc3RvcmluZyBzZXRzIG9mIGZ1bmN0aW9uc1xuICAgIHRoaXMubWVzc2FnZXJfaWQgPSArK01TR1JfSURDT1VOVDtcbiAgfVxuXG4gIC8vLyBGSVJFIE9OQ0UgRVZFTlRTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBtZXNzYWdlIHN0cmluZyB0byBhIGhhbmRsZXIgZnVuY3Rpb24gdGhhdCB3aWxsIHJlY2VpdmUgYSBtdXRhYmxlXG4gICAqIGRhdGEgb2JqZWN0IHRoYXQgaXMgcmV0dXJuZWQgYXQgdGhlIGVuZCBvZiB0aGUgaGFuZGxlciBmdW5jdGlvblxuICAgKiBAZXhhbXBsZSBTdWJzY3JpYmUoJ01ZX01FU1NBR0UnLChkYXRhKT0+eyByZXR1cm4gZGF0YTsgfSk7XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNnTmFtZSBtZXNzYWdlIHRvIHJlZ2lzdGVyIGEgaGFuZGxlciBmb3JcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlckZ1bmMgZnVuY3Rpb24gcmVjZWl2aW5nICdkYXRhJyBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5oYW5kbGVyVUlEXSBVUlNZU19JRCBpZGVudGlmaWVzIGdyb3VwLCBhdHRhY2hlcyBoYW5kbGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pbmZvXSBkZXNjcmlwdGlvbiBvZiBtZXNzYWdlIGhhbmRsZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN5bnRheF0gZGljdGlvbmFyeSBvZiBkYXRhIG9iamVjdCBwcm9wZXJ0aWVzIGFjY2VwdGVkXG4gICAqL1xuICBTdWJzY3JpYmUobWVzZ05hbWUsIGhhbmRsZXJGdW5jLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgeyBoYW5kbGVyVUlEIH0gPSBvcHRpb25zO1xuICAgIGxldCB7IHN5bnRheCB9ID0gb3B0aW9ucztcbiAgICBsZXQgeyBmcm9tTmV0IH0gPSBvcHRpb25zO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlckZ1bmMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IEVycm9yKCdhcmcyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGhhbmRsZXJVSUQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBiaW5kIHRoZSBVUkNoYW4gdWlkIHRvIHRoZSBoYW5kbGVyRnVuYyBmdW5jdGlvbiBmb3IgY29udmVuaWVudCBhY2Nlc3NcbiAgICAgIC8vIGJ5IHRoZSBtZXNzYWdlIGRpc3BhdGNoZXJcbiAgICAgIGhhbmRsZXJGdW5jLnVsaW5rX2lkID0gaGFuZGxlclVJRDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmcm9tTmV0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgIC8vIHRydWUgaWYgdGhpcyBzdWJzY3JpYmVyIHdhbnRzIHRvIHJlY2VpdmUgbmV0d29yayBtZXNzYWdlc1xuICAgICAgaGFuZGxlckZ1bmMuZnJvbU5ldCA9IGZyb21OZXQ7XG4gICAgfVxuICAgIGxldCBoYW5kbGVycyA9IHRoaXMuaGFuZGxlck1hcC5nZXQobWVzZ05hbWUpO1xuICAgIGlmICghaGFuZGxlcnMpIHtcbiAgICAgIGhhbmRsZXJzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5oYW5kbGVyTWFwLnNldChtZXNnTmFtZSwgaGFuZGxlcnMpO1xuICAgIH1cbiAgICAvLyBzeW50YXggYW5ub3RhdGlvblxuICAgIGlmIChzeW50YXgpIGhhbmRsZXJGdW5jLnVtZXNnID0geyBzeW50YXggfTtcbiAgICAvLyBzYXZlZCBmdW5jdGlvbiB0byBoYW5kbGVyXG4gICAgaGFuZGxlcnMuYWRkKGhhbmRsZXJGdW5jKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGEgaGFuZGxlciBmdW5jdGlvbiBmcm9tIGEgcmVnaXN0ZXJlZCBtZXNzYWdlLiBUaGUgaGFuZGxlclxuICAgKiBmdW5jdGlvbiBvYmplY3QgbXVzdCBiZSB0aGUgc2FtZSBvbmUgdXNlZCB0byByZWdpc3RlciBpdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc2dOYW1lIG1lc3NhZ2UgdG8gdW5yZWdpc3RlciBhIGhhbmRsZXIgZm9yXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXJGdW5jIGZ1bmN0aW9uIG9yaWdpbmFsbHkgcmVnaXN0ZXJlZFxuICAgKi9cbiAgVW5zdWJzY3JpYmUobWVzZ05hbWUsIGhhbmRsZXJGdW5jKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmhhbmRsZXJNYXAuY2xlYXIoKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuaGFuZGxlck1hcC5kZWxldGUobWVzZ05hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuaGFuZGxlck1hcC5nZXQobWVzZ05hbWUpO1xuICAgICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgIGhhbmRsZXJzLmRlbGV0ZShoYW5kbGVyRnVuYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKipcbiAgICogUHVibGlzaCBhIG1lc3NhZ2Ugd2l0aCBkYXRhIHBheWxvYWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc2dOYW1lIG1lc3NhZ2UgdG8gc2VuZCBkYXRhIHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbkRhdGEgcGFyYW1ldGVycyBmb3IgdGhlIG1lc3NhZ2UgaGFuZGxlclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNyY1VJRF0gVVJTWVNfSUQgZ3JvdXAgdGhhdCBpcyBzZW5kaW5nIHRoZVxuICAgKiBtZXNzYWdlLiBJZiB0aGlzIGlzIHNldCwgdGhlbiB0aGUgc2VuZGluZyBVUlNZU19JRCBjYW4gcmVjZWl2ZSBpdHMgb3duXG4gICAqIG1lc3NhZ2UgcmVxdWVzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnR5cGVdIHR5cGUgb2YgbWVzc2FnZSAobWNhbGwpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudG9Mb2NhbD10cnVlXSBzZW5kIHRvIGxvY2FsIG1lc3NhZ2UgaGFuZGxlcnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50b05ldD1mYWxzZV0gc2VuZCB0byBuZXR3b3JrIG1lc3NhZ2UgaGFuZGxlcnNcbiAgICovXG4gIFB1Ymxpc2gobWVzZ05hbWUsIGluRGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHsgc3JjVUlELCB0eXBlIH0gPSBvcHRpb25zO1xuICAgIGxldCB7IHRvTG9jYWwgPSB0cnVlLCB0b05ldCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyTWFwLmdldChtZXNnTmFtZSk7XG4gICAgLy8vIHRvTG9jYWxcbiAgICBpZiAoaGFuZGxlcnMgJiYgdG9Mb2NhbClcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goaGFuZGxlckZ1bmMgPT4ge1xuICAgICAgICAvLyBoYW5kbGVyRnVuYyBzaWduYXR1cmU6IChkYXRhLGRhdGFSZXR1cm4pID0+IHt9XG4gICAgICAgIC8vIGhhbmRsZXJGdW5jIGhhcyB1bGlua19pZCBwcm9wZXJ0eSB0byBub3RlIG9yaWdpbmF0aW5nIFVSQ0hBTiBvYmplY3RcbiAgICAgICAgLy8gc2tpcCBcInNhbWUgb3JpZ2luXCIgY2FsbHNcbiAgICAgICAgaWYgKHNyY1VJRCAmJiBoYW5kbGVyRnVuYy51bGlua19pZCA9PT0gc3JjVUlEKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYE1lc3NhZ2VyU2VuZDogWyR7bWVzZ05hbWV9XSBza2lwIGNhbGwgc2luY2Ugb3JpZ2luID0gZGVzdGluYXRpb247IHVzZSBTaWduYWwoKSBpZiBpbnRlbmRlZGBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cmlnZ2VyIHRoZSBsb2NhbCBoYW5kbGVyIChubyByZXR1cm4gZXhwZWN0ZWQpXG4gICAgICAgIGhhbmRsZXJGdW5jKGluRGF0YSwge30pOyAvLyBzZWNvbmQgcGFyYW0gaXMgZm9yIGNvbnRyb2wgbWVzc2FnZSBleHBhbnNpb25cbiAgICAgIH0pOyAvLyBlbmQgaGFuZGxlcnMuZm9yRWFjaFxuXG4gICAgLy8vIHRvTmV0d29ya1xuICAgIGlmICh0b05ldCkge1xuICAgICAgbGV0IHBrdCA9IG5ldyBOZXRQYWNrZXQobWVzZ05hbWUsIGluRGF0YSwgdHlwZSk7XG4gICAgICBwa3QuU29ja2V0U2VuZCgpO1xuICAgIH0gLy8gZW5kIHRvTmV0d29ya1xuICB9XG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKipcbiAgICogUHVibGlzaCBtZXNzYWdlIHRvIGV2ZXJ5b25lLCBsb2NhbCBhbmQgbmV0d29yaywgYW5kIGFsc28gbWlycm9ycyBiYWNrIHRvIHNlbGYuXG4gICAqIFRoaXMgaXMgYSB3cmFwcGVyIGZvciBQdWJsaXNoKCkgdGhhdCBlbnN1cmVzIHRoYXQgc3JjVUlEIGlzIG92ZXJyaWRkZW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNnTmFtZSBtZXNzYWdlIHRvIHNlbmQgZGF0YSB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gaW5EYXRhIHBhcmFtZXRlcnMgZm9yIHRoZSBtZXNzYWdlIGhhbmRsZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzZWUgUHVibGlzaCgpIGZvciBvcHRpb24gZGV0YWlsc1xuICAgKi9cbiAgU2lnbmFsKG1lc2dOYW1lLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAob3B0aW9ucy5zcmNVSUQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYG92ZXJyaWRpbmcgc3JjVUlEICR7b3B0aW9ucy5zcmNVSUR9IHdpdGggTlVMTCBiZWNhdXNlIFNpZ25hbCgpIGRvZXNuJ3QgdXNlIGl0YFxuICAgICAgKTtcbiAgICAgIG9wdGlvbnMuc3JjVUlEID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5QdWJsaXNoKG1lc2dOYW1lLCBkYXRhLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqXG4gICAqIElzc3VlIGEgbWVzc2FnZSB0cmFuc2FjdGlvbi4gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9taXNlcy4gV29ya3MgYWNyb3NzXG4gICAqIHRoZSBuZXR3b3JrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzZ05hbWUgbWVzc2FnZSB0byBzZW5kIGRhdGEgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IGluRGF0YSBwYXJhbWV0ZXJzIGZvciB0aGUgbWVzc2FnZSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gc2VlIFB1Ymxpc2goKSBmb3Igb3B0aW9uIGRldGFpbHNcbiAgICogQHJldHVybnMge0FycmF5fSBhbiBhcnJheSBvZiBQcm9taXNlc1xuICAgKi9cbiAgYXN5bmMgQ2FsbEFzeW5jKG1lc2dOYW1lLCBpbkRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCB7IHNyY1VJRCwgdHlwZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgeyB0b0xvY2FsID0gdHJ1ZSwgdG9OZXQgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgIGxldCB7IGZyb21OZXQgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjaGFubmVsID0gTmV0UGFja2V0LkV4dHJhY3RDaGFubmVsKG1lc2dOYW1lKTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuaGFuZGxlck1hcC5nZXQobWVzZ05hbWUpO1xuICAgIGxldCBwcm9taXNlcyA9IFtdO1xuICAgIC8vLyBoYW5kbGUgYSBjYWxsIGZyb20gdGhlIG5ldHdvcmtcbiAgICBpZiAodG9Mb2NhbCkge1xuICAgICAgaWYgKCFjaGFubmVsLkxPQ0FMICYmICFmcm9tTmV0KVxuICAgICAgICB0aHJvdyBFcnJvcihgJyR7bWVzZ05hbWV9JyBmb3IgbG9jYWwgY2FsbHMgcmVtb3ZlIGNoYW5uZWwgcHJlZml4YCk7XG4gICAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyRnVuYyA9PiB7XG4gICAgICAgICAgLyovXG4gICAgICAgICAgaGFuZGxlckZ1bmMgc2lnbmF0dXJlOiAoZGF0YSxkYXRhUmV0dXJuKSA9PiB7fVxuICAgICAgICAgIGhhbmRsZXJGdW5jIGhhcyB1bGlua19pZCBwcm9wZXJ0eSB0byBub3RlIG9yaWdpbmF0aW5nIFVSQ0hBTiBvYmplY3RcbiAgICAgICAgICBoYW5kbGVyRnVuYyBoYXMgZnJvbU5ldCBwcm9wZXJ0eSBpZiBpdCBleHBlY3RzIHRvIHJlY2VpdmUgbmV0d29yayBzb3VyY2VkIGNhbGxzXG4gICAgICAgICAgLyovXG4gICAgICAgICAgLy8gc2tpcCBjYWxscyB0aGF0IGRvbid0IGhhdmUgdGhlaXIgZnJvbU5ldCBzdGF0IHNldCBpZiBpdCdzIGEgbmV0IGNhbGxcbiAgICAgICAgICBpZiAoZnJvbU5ldCAmJiAhaGFuZGxlckZ1bmMuZnJvbU5ldCkge1xuICAgICAgICAgICAgaWYgKERCRylcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIGBNZXNzYWdlckNhbGw6IFske21lc2dOYW1lfV0gc2tpcCBuZXRjYWxsIGZvciBoYW5kbGVyIHVuaW50ZXJlc3RlZCBpbiBuZXRgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHNraXAgXCJzYW1lIG9yaWdpblwiIGNhbGxzXG4gICAgICAgICAgaWYgKHNyY1VJRCAmJiBoYW5kbGVyRnVuYy51bGlua19pZCA9PT0gc3JjVUlEKSB7XG4gICAgICAgICAgICBpZiAoREJHKVxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgYE1lc3NhZ2VyQ2FsbDogWyR7bWVzZ05hbWV9XSBza2lwIGNhbGwgc2luY2Ugb3JpZ2luID0gZGVzdGluYXRpb247IHVzZSBTaWduYWwoKSBpZiBpbnRlbmRlZGBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ3JlYXRlIGEgcHJvbWlzZS4gaWYgaGFuZGxlckZ1bmMgcmV0dXJucyBhIHByb21pc2UsIGl0IGZvbGxvd3NcbiAgICAgICAgICBsZXQgcCA9IGZfTWFrZVJlc29sdmVyRnVuY3Rpb24oaGFuZGxlckZ1bmMsIGluRGF0YSk7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChwKTtcbiAgICAgICAgfSk7IC8vIGVuZCBmb3JlYWNoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyBoYW5kbGVyc1xuICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh7IGVycm9yOiAnbG9jYWwgbWVzc2FnZSBoYW5kbGVyIG5vdCBmb3VuZCcgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IC8vIHRvIGxvY2FsXG5cbiAgICAvLyBlbmQgaWYgaGFuZGxlcnNcbiAgICAvLy8gcmVzb2x2ZXIgZnVuY3Rpb25cbiAgICAvLy8gcmVtZW1iZXIgTUVTU0FHRVIgY2xhc3MgaXMgdXNlZCBmb3IgbW9yZSB0aGFuIGp1c3QgTmV0d29yayBDYWxsc1xuICAgIC8vLyB0aGUgc3RhdGUgbWFuYWdlciBhbHNvIHVzZXMgaXQsIHNvIHRoZSByZXNvbHZlZCB2YWx1ZSBtYXkgYmUgb2YgYW55IHR5cGVcbiAgICBmdW5jdGlvbiBmX01ha2VSZXNvbHZlckZ1bmN0aW9uKGhhbmRsZXJGdW5jKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGxldCByZXR2YWwgPSBoYW5kbGVyRnVuYyhpbkRhdGEsIHtcbiAgICAgICAgICAvKmNvbnRyb2wgZnVuY3Rpb25zIGdvIGhlcmUqL1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzb2x2ZShyZXR2YWwpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vLyB0b05ldHdvcmtcbiAgICBpZiAodG9OZXQpIHtcbiAgICAgIGlmICghY2hhbm5lbC5ORVQpIHRocm93IEVycm9yKCduZXQgY2FsbHMgbXVzdCB1c2UgTkVUOiBtZXNzYWdlIHByZWZpeCcpO1xuICAgICAgdHlwZSA9IHR5cGUgfHwgJ21jYWxsJztcbiAgICAgIGxldCBwa3QgPSBuZXcgTmV0UGFja2V0KG1lc2dOYW1lLCBpbkRhdGEsIHR5cGUpO1xuICAgICAgbGV0IHAgPSBwa3QuUHJvbWlzZVRyYW5zYWN0aW9uKCk7XG4gICAgICBwcm9taXNlcy5wdXNoKHApO1xuICAgIH0gLy8gZW5kIHRvTmV0d29ya1xuXG4gICAgLy8vIGRvIHRoZSB3b3JrXG4gICAgbGV0IHJlc0FycmF5ID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIGxldCByZXNPYmogPSBPYmplY3QuYXNzaWduKHt9LCAuLi5yZXNBcnJheSk7XG4gICAgcmV0dXJuIHJlc09iajtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqXG4gICAqIEdldCBsaXN0IG9mIG1lc3NhZ2VzIHRoYXQgYXJlIGhhbmRsZWQgYnkgdGhpcyBNZXNzYWdlciBpbnN0YW5jZS5cbiAgICogQHJldHVybnMge0FycmF5PHN0cmluZz59IG1lc3NhZ2UgbmFtZSBzdHJpbmdzXG4gICAqL1xuICBNZXNzYWdlTmFtZXMoKSB7XG4gICAgbGV0IGhhbmRsZXJzID0gW107XG4gICAgdGhpcy5oYW5kbGVyTWFwLmZvckVhY2goKHNldCwga2V5KSA9PiB7XG4gICAgICBoYW5kbGVycy5wdXNoKGtleSk7XG4gICAgICBpZiAoREJHKSBjb25zb2xlLmxvZyhgaGFuZGxlcjogJHtrZXl9YCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhhbmRsZXJzO1xuICB9XG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKipcbiAgICogR2V0IGxpc3Qgb2YgbWVzc2FnZXMgdGhhdCBhcmUgcHVibGlzaGVkIHRvIHRoZSBuZXR3b3JrXG4gICAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBtZXNzYWdlIG5hbWUgc3RyaW5nc1xuICAgKi9cbiAgTmV0TWVzc2FnZU5hbWVzKCkge1xuICAgIGxldCBoYW5kbGVycyA9IFtdO1xuICAgIHRoaXMuaGFuZGxlck1hcC5mb3JFYWNoKChzZXQsIGtleSkgPT4ge1xuICAgICAgbGV0IGFkZE1lc3NhZ2UgPSBmYWxzZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXR1cm4tYXNzaWduLCBuby1iaXR3aXNlXG4gICAgICBzZXQuZm9yRWFjaChmdW5jID0+IChhZGRNZXNzYWdlIHw9IGZ1bmMuZnJvbU5ldCA9PT0gdHJ1ZSkpO1xuICAgICAgaWYgKGFkZE1lc3NhZ2UpIGhhbmRsZXJzLnB1c2goa2V5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGFuZGxlcnM7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKlxuICAgKiBDaGVjayB0byBzZWUgaWYgYSBtZXNzYWdlIGlzIGhhbmRsZWQgYnkgdGhpcyBNZXNzYWdlciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZz0nJ30gbXNnIG1lc3NhZ2UgbmFtZSB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBtZXNzYWdlIG5hbWUgaXMgaGFuZGxlZFxuICAgKi9cbiAgSGFzTWVzc2FnZU5hbWUobXNnID0gJycpIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyTWFwLmhhcyhtc2cpO1xuICB9XG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKipcbiAgICogRW5zdXJlIHRoYXQgdGhlIHBhc3NlZCBtZXNzYWdlIG5hbWVzIHJlYWxseSBleGlzdCBpbiB0aGlzIE1lc3NhZ2VyXG4gICAqIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gbXNnc1xuICAgKi9cbiAgVmFsaWRhdGVNZXNzYWdlTmFtZXMobXNncyA9IFtdKSB7XG4gICAgY29uc3QgdmFsaWQgPSBbXTtcbiAgICBtc2dzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBpZiAodGhpcy5IYXNNZXNzYWdlTmFtZShuYW1lKSkgdmFsaWQucHVzaChuYW1lKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWxpZGF0ZU1lc3NhZ2VOYW1lcygpIGZvdW5kIGludmFsaWQgbWVzc2FnZSAnJHtuYW1lfSdgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsaWQ7XG4gIH1cbn0gLy8gY2xhc3MgTWVzc2FnZXJcblxuLy8vIEVYUE9SVCBDTEFTUyBERUZJTklUSU9OIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlcjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/class-messager.js\n");

/***/ }),

/***/ "./src/class-netpacket.js":
/*!********************************!*\
  !*** ./src/class-netpacket.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable @typescript-eslint/no-use-before-define */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/* eslint-disable lines-between-class-members */\n\n/*//////////////////////////////// ABOUT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\n\n  NetPacket objects are sent between the browser and server as part of the\n  URSYS messaging system. NetMessages do not need addresses.\n\n  This NetPacket declaration is SHARED in both node and browser javascript\n  codebases.\n\n  FEATURES\n\n  * handles asynchronous transactions\n  * works in both node and browser contexts\n  * has an \"offline mode\" to suppress network messages without erroring\n\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ * //////////////////////////////////////*/\n/// DEPENDENCIES //////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nconst PROMPTS = __webpack_require__(/*! ./util/prompts */ \"./src/util/prompts.js\"); /// DEBUG MESSAGES ////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nconst DBG = {\n  send: false,\n  transact: false,\n  setup: false\n};\nconst PR = PROMPTS.makeStyleFormatter('PKT');\nconst ERR = ':ERR:';\nconst PERR = ERR + PR;\nconst ERR_NOT_NETMESG = `${PERR}obj does not seem to be a NetPacket`;\nconst ERR_BAD_PROP = `${PERR}property argument must be a string`;\nconst ERR_ERR_BAD_CSTR = `${PERR}constructor args are string, object`;\nconst ERR_BAD_SOCKET = `${PERR}sender object must implement send()`;\nconst ERR_DUPE_TRANS = `${PERR}this packet transaction is already registered!`;\nconst ERR_NO_GLOB_UADDR = `${PERR}packet sending attempted before UADDR is set!`;\nconst ERR_UNKNOWN_TYPE = `${PERR}packet type is unknown:`;\nconst ERR_NOT_PACKET = `${PERR}passed object is not a NetPacket`;\nconst ERR_UNKNOWN_RMODE = `${PERR}packet routine mode is unknown:`; /// CONSTANTS /////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst M_INIT = 'init';\nconst M_ONLINE = 'online';\nconst M_STANDALONE = 'offline';\nconst M_CLOSED = 'closed';\nconst M_ERROR = 'error';\nconst VALID_CHANNELS = ['LOCAL', 'NET', 'STATE']; // * is all channels in list\n/// DECLARATIONS //////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nlet m_id_counter = 0;\nlet m_id_prefix = 'PKT';\nlet m_transactions = {};\nlet m_netsocket = null;\nlet m_group_id = null;\nlet m_mode = M_INIT; /// ENUMS /////////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst PACKET_TYPES = ['msend', // a 'send' message returns no data\n'msig', // a 'signal' message is a send that calls all handlers everywhere\n'mcall', // a 'call' message returns data\n'state' // (unimplemented) a 'state' message is used by a state manager\n];\nconst TRANSACTION_MODE = ['req', // packet in initial 'request' mode\n'res' // packet in returned 'response' mode\n]; /// URSYS NETMESSAGE CLASS ////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Class NetPacket\n * Container for messages that can be sent across the network to the URSYS\n * server.\n * @typedef {Object} NetPacket\n * @property {string} msg - message\n * @property {Object} data - message data\n * @property {string} id - internal id\n * @property {string} type - packet operation type (1way,2way,sync)\n * @property {string} rmode - transaction direction\n * @property {string} memo - human-readable debug note space\n * @property {string} seqnum - sequence number for transaction\n * @property {Array} seqlog - array of seqnums, starting with originating address\n * @property {string} s_uid - originating browser internal endpoint\n * @property {string} s_uaddr - originating browser address\n * @property {string} s_group - group session key\n */\n\nclass NetPacket {\n  /** constructor\n   * @param {string|object} msg message name, or an existing plain object to coerce into a NetPacket\n   * @param {Object} data data packet to send\n   * @param {string} type the message (defined in PACKET_TYPES)\n   */\n  constructor(msg, data, type) {\n    // OPTION 1\n    // create NetPacket from (generic object)\n    if (typeof msg === 'object' && data === undefined) {\n      // make sure it has a msg and data obj\n      if (typeof msg.msg !== 'string' || typeof msg.data !== 'object') {\n        throw Error(ERR_NOT_NETMESG);\n      } // merge properties into this new class instance and return it\n\n\n      Object.assign(this, msg);\n      this.seqlog = this.seqlog.slice(); // copy array\n\n      m_SeqIncrement(this);\n      return this;\n    } // OPTION 2\n    // create NetPacket from JSON-encoded string\n\n\n    if (typeof msg === 'string' && data === undefined) {\n      let obj = JSON.parse(msg);\n      Object.assign(this, obj);\n      m_SeqIncrement(this);\n      return this;\n    } // OPTION 3\n    // create new NetPacket from scratch (mesg,data)\n    // unique id for every NetPacket\n\n\n    if (typeof type === 'string') m_CheckType(type);\n\n    if (typeof msg !== 'string' || typeof data !== 'object') {\n      throw Error(ERR_ERR_BAD_CSTR);\n    } // allow calls with null data by setting to empty object\n\n\n    this.data = data || {};\n    this.msg = msg; // id and debugging memo support\n\n    this.id = this.MakeNewID();\n    this.rmode = TRANSACTION_MODE[0]; // is default 'request' (trans request)\n\n    this.type = type || PACKET_TYPES[0]; // is default 'msend' (no return)\n\n    this.memo = ''; // transaction support\n\n    this.seqnum = 0; // positive when part of transaction\n\n    this.seqlog = []; // transaction log\n    // addressing support\n\n    this.s_uaddr = NetPacket.SocketUADDR() || null; // first originating uaddr set by SocketSend()\n\n    this.s_group = null; // session groupid is set by external module once validated\n\n    this.s_uid = null; // first originating URCHAN srcUID\n    // filtering support\n  } // constructor\n  /// ACCESSSOR METHODS ///////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.Type() returns the TRANSACTION_TYPE of this packet\n   */\n\n\n  Type() {\n    return this.type;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.Type() returns true if type matches\n   * @param {string} type the type to compare with the packet's type\n   * @returns {boolean}\n   */\n\n\n  IsType(type) {\n    return this.type === type;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.SetType() sets the type of the packet. Must be a known type\n   * in PACKET_TYPES\n   */\n\n\n  SetType(type) {\n    this.type = m_CheckType(type);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** returns the message string of form CHANNEL:MESSAGE, where CHANNEL:\n   * is optional\n   */\n\n\n  Message() {\n    return this.msg;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** returns MESSAGE without the CHANNEL: prefix. The channel (e.g.\n   * NET, LOCAL, STATE) is also set true\n   */\n\n\n  DecodedMessage() {\n    return NetPacket.ExtractChannel(this.msg);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.Is() returns truthy value (this.data) if the passed msgstr\n   *  matches the message associated with this NetPacket\n   */\n\n\n  Is(msgstr) {\n    return msgstr === this.msg ? this.data : undefined;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.IsServerMessage() is a convenience function return true if\n   * server message */\n\n\n  IsServerMessage() {\n    return this.msg.startsWith('NET:SRV_');\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.SetMessage() sets the message field\n   */\n\n\n  SetMessage(msgstr) {\n    this.msg = msgstr;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.Data() returns the entire data payload or the property within\n   * the data payload (can return undefined if property doesn't exist)\n   */\n\n\n  Data(prop) {\n    if (!prop) return this.data;\n    if (typeof prop === 'string') return this.data[prop];\n    throw Error(ERR_BAD_PROP);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /**\n   * Convenience method to set data object entirely\n   */\n\n\n  SetData(propOrVal, val) {\n    if (typeof propOrVal === 'object') {\n      this.data = propOrVal;\n      return;\n    }\n\n    if (typeof propOrVal === 'string') {\n      this.data[propOrVal] = val;\n      return;\n    }\n\n    throw Error(ERR_BAD_PROP);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.Memo() returns the 'memo' field of the packet */\n\n\n  Memo() {\n    return this.memo;\n  }\n\n  SetMemo(memo) {\n    this.memo = memo;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.JSON() returns a stringified JSON version of the packet. */\n\n\n  JSON() {\n    return JSON.stringify(this);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.SourceGroupId() return the session group id associated with\n   * this packet.\n   */\n\n\n  SourceGroupID() {\n    return this.s_group;\n  } /// TRANSACTION SUPPORT /////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.SeqNum() returns a non-positive integer that is the number of\n   * times this packet was reused during a transaction (e.g. 'mcall' types).\n   */\n\n\n  SeqNum() {\n    return this.seqnum;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.SourceAddress() returns the originating browser of the packet,\n   * which is the socketname maintained by the URSYS server. It is valid only\n   * after the URSYS server has received it, so it is invalid when a NetPacket\n   * packet is first created.\n   */\n\n\n  SourceAddress() {\n    /*/ NOTE\n         s_uaddr is the most recent sending browser.\n         If a NetPacket packet is reused in a transaction (e.g. a call that returns\n        data) then the originating browser is the first element in the transaction\n        log .seqlog\n    /*/\n    // is this packet originating from server to a remote?\n    if (this.s_uaddr === NetPacket.DefaultServerUADDR() && !this.msg.startsWith('NET:SVR_')) {\n      return this.s_uaddr;\n    } // this is a regular message forward to remote handlers\n\n\n    return this.IsTransaction() ? this.seqlog[0] : this.s_uaddr;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** Return true if this pkt is from the server targeting remote handlers\n   */\n\n\n  IsServerOrigin() {\n    return this.SourceAddress() === NetPacket.DefaultServerUADDR();\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.CopySourceAddress() copies the source address of sets the\n   * current address to the originating URSYS browser address. Used by server\n   * forwarding and returning packets between remotes.\n   * @param {NetPacket} pkt - the packet to copy source from\n   */\n\n\n  CopySourceAddress(pkt) {\n    if (pkt.constructor.name !== 'NetPacket') throw Error(ERR_NOT_PACKET);\n    this.s_uaddr = pkt.SourceAddress();\n  } /// - - - - - - - - server- - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.Info() returns debug information about the packet\n   * @param {string} key - type of debug info (always 'src' currently)\n   * @returns {string} source browser + group (if set)\n   */\n\n\n  Info(key) {\n    switch (key) {\n      case 'src':\n      /* falls-through */\n\n      default:\n        return this.SourceGroupID() ? `${this.SourceAddress()} [${this.SourceGroupID()}]` : `${this.SourceAddress()}`;\n    }\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.MakeNewID() is a utility method that generates a unique id for\n   * each NetPacket packet. When combined with s_uaddr and s_srcuid, this gives\n   * a packet a unique ID across the entire URSYS network.\n   * @returns {string} unique id\n   */\n\n\n  MakeNewID() {\n    let idStr = (++m_id_counter).toString();\n    this.id = m_id_prefix + idStr.padStart(5, '0');\n    return this.id;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.SocketSend() is a convenience method to let packets 'send\n   * themselves' to the network via the URSYS server.\n   * @param {Object=m_socket} socket - web socket object. m_socket\n   * is defined only on browsers; see NetPacket.GlobalSetup()\n   */\n\n\n  SocketSend(socket = m_netsocket) {\n    if (m_mode === M_ONLINE || m_mode === M_INIT) {\n      this.s_group = NetPacket.GlobalGroupID();\n      let dst = socket.UADDR || 'unregistered socket';\n      if (!socket) throw Error('SocketSend(sock) requires a valid socket');\n\n      if (DBG.send) {\n        let status = `sending '${this.Message()}' to ${dst}`;\n        console.log(PR, status);\n      } // for server-side ws library, send supports a function callback\n      // for WebSocket, this is ignored\n\n\n      socket.send(this.JSON(), err => {\n        if (err) console.error(`\\nsocket ${socket.UADDR} reports error ${err}\\n`);\n      });\n    } else if (m_mode !== M_STANDALONE) {\n      console.log(PR, \"SocketSend: Can't send because NetPacket mode is\", m_mode);\n    } else {\n      console.warn(PR, 'STANDALONE MODE: SocketSend() suppressed!');\n    } // FYI: global m_netsocket is not defined on server, since packets arrive on multiple sockets\n\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.PromiseTransaction() maps a packet to a return handler using a\n   * unique key. This key allows an incoming packet to be mapped back to the\n   * caller even if it is technically a different object received over the\n   * network.\n   * @param {Object=m_socket} socket - web socket object. m_socket is defined\n   * only on browsers; see NetPacket.GlobalSetup()\n   */\n\n\n  PromiseTransaction(socket = m_netsocket) {\n    if (m_mode === M_STANDALONE) {\n      console.warn(PR, 'STANDALONE MODE: PromiseTransaction() suppressed!');\n      return Promise.resolve();\n    } // global m_netsocket is not defined on server, since packets arrive on multiple sockets\n\n\n    if (!socket) throw Error('PromiseTransaction(sock) requires a valid socket'); // save our current UADDR\n\n    this.seqlog.push(NetPacket.UADDR);\n    let dbg = DBG.transact && !this.IsServerMessage();\n    let p = new Promise((resolve, reject) => {\n      let hash = m_GetHashKey(this);\n\n      if (m_transactions[hash]) {\n        reject(Error(`${ERR_DUPE_TRANS}:${hash}`));\n      } else {\n        // save the resolve function in transactions table;\n        // promise will resolve on remote invocation with data\n        m_transactions[hash] = data => {\n          if (dbg) {\n            console.log(PR, 'resolving promise with', JSON.stringify(data));\n          }\n\n          resolve(data);\n        };\n\n        this.SocketSend(socket);\n      }\n    });\n    return p;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.RoutingMode() returns the direction of the packet to a\n   * destination handler (req) or back to the origin (res).  */\n\n\n  RoutingMode() {\n    return this.rmode;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.IsRequest() returns true if this packet is one being sent\n   * to a remote handler\n   */\n\n\n  IsRequest() {\n    return this.rmode === 'req';\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.IsResponse() returns true if this is a packet\n   * being returned from a remote handler\n   * @returns {boolean} true if this is a transaction response\n   */\n\n\n  IsResponse() {\n    return this.rmode === 'res'; // more bulletproof check, but unnecessary\n    // return this.rmove ==='res' && this.SourceAddress() === NetPacket.UADDR;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.IsTransaction() tests whether the packet is a response to a\n   * call that was sent out previously.\n   */\n\n\n  IsTransaction() {\n    return this.rmode !== 'req' && this.seqnum > 0 && this.seqlog[0] === NetPacket.UADDR;\n  } ///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.ReturnTransaction() is used to send a packet back to its\n   * origin. It saves the current browser address (stored in NetPacket.UADDR),\n   * sets the direction of the packet, and puts it on the socket.\n   * @param {Object=m_socket} socket - web socket object. m_socket is defined\n   * only on browsers; see NetPacket.GlobalSetup()\n   */\n\n\n  ReturnTransaction(socket = m_netsocket) {\n    // global m_netsocket is not defined on server, since packets arrive on multiple sockets\n    if (!socket) throw Error('ReturnTransaction(sock) requires a valid socket'); // note: seqnum is already incremented by the constructor if this was\n    // a received packet\n    // add this to the sequence log\n\n    this.seqlog.push(NetPacket.UADDR);\n    this.rmode = m_CheckRMode('res');\n    this.SocketSend(socket);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.CompleteTransaction() is called when a packet is received back\n   * from the remote handler. At this point, the original caller needs to be\n   * informed via the saved function handler created in\n   * NetPacket.PromiseTransaction().\n   */\n\n\n  CompleteTransaction() {\n    let dbg = DBG.transact && !this.IsServerMessage();\n    let hash = m_GetHashKey(this);\n    let resolverFunc = m_transactions[hash];\n    if (dbg) console.log(PR, 'CompleteTransaction', hash);\n\n    if (typeof resolverFunc !== 'function') {\n      throw Error(`transaction [${hash}] resolverFunction is type ${typeof resolverFunc}`);\n    } else {\n      resolverFunc(this.data);\n      Reflect.deleteProperty(m_transactions[hash]);\n    }\n  }\n\n} // class NetPacket\n/// STATIC CLASS METHODS //////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** NetPacket.GlobalSetup() is a static method that initializes shared\n * parameters for use by all instances of the NetPacket class. It is used only\n * on browsers, which have a single socket connection.\n *\n * If no netsocket property is defined, then NetPacket instances will surpress\n * sending of network messages while allowing local messages to work normally.\n * See NetPacket.GlobalOfflineMode() for more information.\n * @function\n * @param {Object} [config] - configuration object\n * @param {Object} [config.netsocket] - valid websocket to URSYS server\n * @param {Object} [config.uaddr] - URSYS browser address\n */\n\n\nNetPacket.GlobalSetup = (config = {}) => {\n  let {\n    uaddr,\n    netsocket,\n    peers,\n    is_local\n  } = config;\n  if (uaddr) NetPacket.UADDR = uaddr;\n  if (peers) NetPacket.PEERS = peers;\n\n  if (netsocket) {\n    // NOTE: m_netsocket is set only on clients since on server, there are\n    // multiple sockets\n    if (typeof netsocket.send !== 'function') throw Error(ERR_BAD_SOCKET);\n    if (DBG.setup) console.log(PR, 'GlobalSetup: netsocket set, mode online');\n    m_netsocket = netsocket;\n    m_mode = M_ONLINE;\n  }\n\n  if (is_local) NetPacket.ULOCAL = is_local;\n};\n\nNetPacket.UADDR = 'UNASSIGNED';\nNetPacket.ULOCAL = false; // set if connection is a local connection\n\nNetPacket.PEERS = undefined; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** NetPacket.GlobalCleanup() is a static method called only by the client,\n * which drops the current socket and puts the app in 'closed' state. In\n * practice this call doesn't accomplish much, but is here for symmetry to\n * GlobalSetup().\n * @function\n */\n\nNetPacket.GlobalCleanup = () => {\n  if (m_netsocket) {\n    if (DBG.setup) console.log(PR, 'GlobalCleanup: deallocating netsocket, mode closed');\n    m_netsocket = null;\n    m_mode = M_CLOSED;\n    NetPacket.ULOCAL = false;\n  }\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Static method NetPacket.GlobalOfflineMode() explicitly sets the mode to STANDALONE, which\n * actively suppresses remote network communication without throwing errors.\n * It's used for static code snapshots of the webapp that don't need the\n * network.\n * @function\n */\n\n\nNetPacket.GlobalOfflineMode = () => {\n  m_mode = M_STANDALONE;\n\n  if (m_netsocket) {\n    console.log(...PR('STANDALONE MODE: NetPacket disabling network'));\n    m_netsocket = null;\n    let event = new CustomEvent('URSYSDisconnect', {});\n    console.log(...PR('STANDALONE MODE: sending URSYSDisconnect'));\n    document.dispatchEvent(event);\n  }\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/**\n * Converts 'CHANNEL:MESSAGE' string to an object with channel, message\n * properties. If there is more than one : in the message string, it's left\n * as part of the message. All properties returned in are UPPERCASE.\n * @param {string} message - message with optional channel prefix\n * @returns {Object} - contains channel (UC) that are set\n * @example\n * const parsed = NetPacket.DecodeChannel('NET:MY_MESSAGE');\n * if (parsed.NET) console.log('this is true');\n * if (parsed.LOCAL) console.log('this is false');\n * console.log('message is',parsed.MESSAGE);\n */\n\n\nNetPacket.ExtractChannel = function ExtractChannel(msg) {\n  let [channel, MESSAGE] = msg.split(':', 2); // no : found, must be local\n\n  if (!MESSAGE) {\n    MESSAGE = channel;\n    channel = '';\n  }\n\n  const parsed = {\n    MESSAGE\n  };\n\n  if (!channel) {\n    parsed.LOCAL = true;\n    return parsed;\n  }\n\n  if (channel === '*') {\n    VALID_CHANNELS.forEach(chan => {\n      parsed[chan] = true;\n    });\n    return parsed;\n  }\n\n  if (VALID_CHANNELS.includes(channel)) {\n    parsed[channel] = true;\n    return parsed;\n  } // legacy messages use invalid channel names\n  // for now forward them as-is\n\n\n  console.warn(`'${msg}' replace : with _`);\n  parsed.LOCAL = true;\n  return parsed; // this is what should actually happen\n  // throw Error(`invalid channel '${channel}'`);\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** NetPacket.SocketUADDR() is a static method returning the class-wide setting\n * of the browser UADDR. This is only used on browser code.\n * @function\n * @returns {string} URSYS address of the current browser, a URSYS address\n */\n\n\nNetPacket.SocketUADDR = () => {\n  return NetPacket.UADDR;\n};\n\nNetPacket.Peers = () => {\n  return NetPacket.PEERS;\n};\n\nNetPacket.IsLocalhost = () => {\n  return NetPacket.ULOCAL;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** NetPacket.DefaultServerUADDR() is a static method returning a hardcoded\n * URSYS address referring to the URSYS server. It is used by the server-side\n * code to set the server address, and the browser can rely on it as well.\n * @function\n * @returns {string} URSYS address of the server\n */\n\n\nNetPacket.DefaultServerUADDR = () => {\n  return 'SVR_01';\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** NetPacket.GlobalGroupID() is a static method returning the session key\n * (aka group-id) set for this browser instance\n * @function\n * @returns {string} session key\n */\n\n\nNetPacket.GlobalGroupID = () => {\n  return m_group_id;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** NetPacket.GlobalSetGroupID() is a static method that stores the passed\n * token as the GroupID\n * @function\n * @param {string} token - special session key data\n */\n\n\nNetPacket.GlobalSetGroupID = token => {\n  m_group_id = token;\n}; /// PRIVATE CLASS HELPERS /////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/*/ DEPRECATE? Utility function to increment the packet's sequence number\n *  @param {NetPacket} pkt - packet to modify\n/*/\n\n\nfunction m_SeqIncrement(pkt) {\n  pkt.seqnum++;\n  return pkt;\n} ///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/*/ Utility to create a unique hash key from packet information. Used by\n *  PromiseTransaction().\n *  @param {NetPacket} pkt - packet to use\n *  @return {string} hash key string\n/*/\n\n\nfunction m_GetHashKey(pkt) {\n  let hash = `${pkt.SourceAddress()}:${pkt.id}`;\n  return hash;\n} ///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/*/ Utility to ensure that the passed type is one of the allowed packet types.\n *  Throws an error if it is not.\n *  @param {string} type - a string to be matched against PACKET_TYPES\n *  @returns {string} the string that passed the type check\n/*/\n\n\nfunction m_CheckType(type) {\n  if (type === undefined) {\n    throw new Error(`must pass a type string, not ${type}`);\n  }\n\n  if (!PACKET_TYPES.includes(type)) throw Error(`${ERR_UNKNOWN_TYPE} '${type}'`);\n  return type;\n} ///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/*/ Utility to ensure the passed transaction mode is one of the allowed\n *  types. Throws an error if it is not.\n *  @param {string} mode - a string to be matched against TRANSACTION_MODE\n *  @returns {string} the string the passed the mode check\n/*/\n\n\nfunction m_CheckRMode(mode) {\n  if (mode === undefined) {\n    throw new Error(`must pass a mode string, not ${mode}`);\n  }\n\n  if (!TRANSACTION_MODE.includes(mode)) throw Error(`${ERR_UNKNOWN_RMODE} '${mode}'`);\n  return mode;\n} /// EXPORT CLASS DEFINITION ///////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nNetPacket.CODE_OK = 0;\nNetPacket.CODE_NO_MESSAGE = 1; // requested message doesn't exist\n\nNetPacket.CODE_SOC_NOSOCK = -100;\nNetPacket.CODE_SES_REQUIRE_KEY = -200; // access key not set\n\nNetPacket.CODE_SES_REQUIRE_LOGIN = -201; // socket was not logged-in\n\nNetPacket.CODE_SES_INVALID_KEY = -202; // provided key didn't match socket key\n\nNetPacket.CODE_SES_RE_REGISTER = -203; // session attempted to login again\n\nNetPacket.CODE_SES_INVALID_TOKEN = -204; // session attempted to login again\n\nNetPacket.CODE_REG_DENIED = -300; // registration of handler denied\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n/// using CommonJS format on purpose for node compatibility\n\nmodule.exports = NetPacket;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2xhc3MtbmV0cGFja2V0LmpzPzIwMjUiXSwibmFtZXMiOlsiUFJPTVBUUyIsInJlcXVpcmUiLCJEQkciLCJzZW5kIiwidHJhbnNhY3QiLCJzZXR1cCIsIlBSIiwibWFrZVN0eWxlRm9ybWF0dGVyIiwiRVJSIiwiUEVSUiIsIkVSUl9OT1RfTkVUTUVTRyIsIkVSUl9CQURfUFJPUCIsIkVSUl9FUlJfQkFEX0NTVFIiLCJFUlJfQkFEX1NPQ0tFVCIsIkVSUl9EVVBFX1RSQU5TIiwiRVJSX05PX0dMT0JfVUFERFIiLCJFUlJfVU5LTk9XTl9UWVBFIiwiRVJSX05PVF9QQUNLRVQiLCJFUlJfVU5LTk9XTl9STU9ERSIsIk1fSU5JVCIsIk1fT05MSU5FIiwiTV9TVEFOREFMT05FIiwiTV9DTE9TRUQiLCJNX0VSUk9SIiwiVkFMSURfQ0hBTk5FTFMiLCJtX2lkX2NvdW50ZXIiLCJtX2lkX3ByZWZpeCIsIm1fdHJhbnNhY3Rpb25zIiwibV9uZXRzb2NrZXQiLCJtX2dyb3VwX2lkIiwibV9tb2RlIiwiUEFDS0VUX1RZUEVTIiwiVFJBTlNBQ1RJT05fTU9ERSIsIk5ldFBhY2tldCIsImNvbnN0cnVjdG9yIiwibXNnIiwiZGF0YSIsInR5cGUiLCJ1bmRlZmluZWQiLCJFcnJvciIsIk9iamVjdCIsImFzc2lnbiIsInNlcWxvZyIsInNsaWNlIiwibV9TZXFJbmNyZW1lbnQiLCJvYmoiLCJKU09OIiwicGFyc2UiLCJtX0NoZWNrVHlwZSIsImlkIiwiTWFrZU5ld0lEIiwicm1vZGUiLCJtZW1vIiwic2VxbnVtIiwic191YWRkciIsIlNvY2tldFVBRERSIiwic19ncm91cCIsInNfdWlkIiwiVHlwZSIsIklzVHlwZSIsIlNldFR5cGUiLCJNZXNzYWdlIiwiRGVjb2RlZE1lc3NhZ2UiLCJFeHRyYWN0Q2hhbm5lbCIsIklzIiwibXNnc3RyIiwiSXNTZXJ2ZXJNZXNzYWdlIiwic3RhcnRzV2l0aCIsIlNldE1lc3NhZ2UiLCJEYXRhIiwicHJvcCIsIlNldERhdGEiLCJwcm9wT3JWYWwiLCJ2YWwiLCJNZW1vIiwiU2V0TWVtbyIsInN0cmluZ2lmeSIsIlNvdXJjZUdyb3VwSUQiLCJTZXFOdW0iLCJTb3VyY2VBZGRyZXNzIiwiRGVmYXVsdFNlcnZlclVBRERSIiwiSXNUcmFuc2FjdGlvbiIsIklzU2VydmVyT3JpZ2luIiwiQ29weVNvdXJjZUFkZHJlc3MiLCJwa3QiLCJuYW1lIiwiSW5mbyIsImtleSIsImlkU3RyIiwidG9TdHJpbmciLCJwYWRTdGFydCIsIlNvY2tldFNlbmQiLCJzb2NrZXQiLCJHbG9iYWxHcm91cElEIiwiZHN0IiwiVUFERFIiLCJzdGF0dXMiLCJjb25zb2xlIiwibG9nIiwiZXJyIiwiZXJyb3IiLCJ3YXJuIiwiUHJvbWlzZVRyYW5zYWN0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwdXNoIiwiZGJnIiwicCIsInJlamVjdCIsImhhc2giLCJtX0dldEhhc2hLZXkiLCJSb3V0aW5nTW9kZSIsIklzUmVxdWVzdCIsIklzUmVzcG9uc2UiLCJSZXR1cm5UcmFuc2FjdGlvbiIsIm1fQ2hlY2tSTW9kZSIsIkNvbXBsZXRlVHJhbnNhY3Rpb24iLCJyZXNvbHZlckZ1bmMiLCJSZWZsZWN0IiwiZGVsZXRlUHJvcGVydHkiLCJHbG9iYWxTZXR1cCIsImNvbmZpZyIsInVhZGRyIiwibmV0c29ja2V0IiwicGVlcnMiLCJpc19sb2NhbCIsIlBFRVJTIiwiVUxPQ0FMIiwiR2xvYmFsQ2xlYW51cCIsIkdsb2JhbE9mZmxpbmVNb2RlIiwiZXZlbnQiLCJDdXN0b21FdmVudCIsImRvY3VtZW50IiwiZGlzcGF0Y2hFdmVudCIsImNoYW5uZWwiLCJNRVNTQUdFIiwic3BsaXQiLCJwYXJzZWQiLCJMT0NBTCIsImZvckVhY2giLCJjaGFuIiwiaW5jbHVkZXMiLCJQZWVycyIsIklzTG9jYWxob3N0IiwiR2xvYmFsU2V0R3JvdXBJRCIsInRva2VuIiwibW9kZSIsIkNPREVfT0siLCJDT0RFX05PX01FU1NBR0UiLCJDT0RFX1NPQ19OT1NPQ0siLCJDT0RFX1NFU19SRVFVSVJFX0tFWSIsIkNPREVfU0VTX1JFUVVJUkVfTE9HSU4iLCJDT0RFX1NFU19JTlZBTElEX0tFWSIsIkNPREVfU0VTX1JFX1JFR0lTVEVSIiwiQ09ERV9TRVNfSU5WQUxJRF9UT0tFTiIsIkNPREVfUkVHX0RFTklFRCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBLE1BQU1BLE9BQU8sR0FBR0MsbUJBQU8sQ0FBQyw2Q0FBRCxDQUF2QixDLENBRUE7QUFDQTs7O0FBQ0EsTUFBTUMsR0FBRyxHQUFHO0FBQUVDLE1BQUksRUFBRSxLQUFSO0FBQWVDLFVBQVEsRUFBRSxLQUF6QjtBQUFnQ0MsT0FBSyxFQUFFO0FBQXZDLENBQVo7QUFFQSxNQUFNQyxFQUFFLEdBQUdOLE9BQU8sQ0FBQ08sa0JBQVIsQ0FBMkIsS0FBM0IsQ0FBWDtBQUNBLE1BQU1DLEdBQUcsR0FBRyxPQUFaO0FBQ0EsTUFBTUMsSUFBSSxHQUFHRCxHQUFHLEdBQUdGLEVBQW5CO0FBQ0EsTUFBTUksZUFBZSxHQUFJLEdBQUVELElBQUsscUNBQWhDO0FBQ0EsTUFBTUUsWUFBWSxHQUFJLEdBQUVGLElBQUssb0NBQTdCO0FBQ0EsTUFBTUcsZ0JBQWdCLEdBQUksR0FBRUgsSUFBSyxxQ0FBakM7QUFDQSxNQUFNSSxjQUFjLEdBQUksR0FBRUosSUFBSyxxQ0FBL0I7QUFDQSxNQUFNSyxjQUFjLEdBQUksR0FBRUwsSUFBSyxnREFBL0I7QUFDQSxNQUFNTSxpQkFBaUIsR0FBSSxHQUFFTixJQUFLLCtDQUFsQztBQUNBLE1BQU1PLGdCQUFnQixHQUFJLEdBQUVQLElBQUsseUJBQWpDO0FBQ0EsTUFBTVEsY0FBYyxHQUFJLEdBQUVSLElBQUssa0NBQS9CO0FBQ0EsTUFBTVMsaUJBQWlCLEdBQUksR0FBRVQsSUFBSyxpQ0FBbEMsQyxDQUVBO0FBQ0E7O0FBQ0EsTUFBTVUsTUFBTSxHQUFHLE1BQWY7QUFDQSxNQUFNQyxRQUFRLEdBQUcsUUFB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QUEvQixDQUFYO0FBQ0YsU0FBT0EsSUFBUDtBQUNELEMsQ0FFRDtBQUNBOzs7QUFDQWpILFNBQVMsQ0FBQ2tILE9BQVYsR0FBb0IsQ0FBcEI7QUFDQWxILFNBQVMsQ0FBQ21ILGVBQVYsR0FBNEIsQ0FBNUIsQyxDQUErQjs7QUFDL0JuSCxTQUFTLENBQUNvSCxlQUFWLEdBQTRCLENBQUMsR0FBN0I7QUFDQXBILFNBQVMsQ0FBQ3FILG9CQUFWLEdBQWlDLENBQUMsR0FBbEMsQyxDQUF1Qzs7QUFDdkNySCxTQUFTLENBQUNzSCxzQkFBVixHQUFtQyxDQUFDLEdBQXBDLEMsQ0FBeUM7O0FBQ3pDdEgsU0FBUyxDQUFDdUgsb0JBQVYsR0FBaUMsQ0FBQyxHQUFsQyxDLENBQXVDOztBQUN2Q3ZILFNBQVMsQ0FBQ3dILG9CQUFWLEdBQWlDLENBQUMsR0FBbEMsQyxDQUF1Qzs7QUFDdkN4SCxTQUFTLENBQUN5SCxzQkFBVixHQUFtQyxDQUFDLEdBQXBDLEMsQ0FBeUM7O0FBQ3pDekgsU0FBUyxDQUFDMEgsZUFBVixHQUE0QixDQUFDLEdBQTdCLEMsQ0FBa0M7QUFDbEM7QUFDQTs7QUFDQUMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCNUgsU0FBakIiLCJmaWxlIjoiLi9zcmMvY2xhc3MtbmV0cGFja2V0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIGxpbmVzLWJldHdlZW4tY2xhc3MtbWVtYmVycyAqL1xuLyovLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBBQk9VVCBcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwqXFxcblxuICBOZXRQYWNrZXQgb2JqZWN0cyBhcmUgc2VudCBiZXR3ZWVuIHRoZSBicm93c2VyIGFuZCBzZXJ2ZXIgYXMgcGFydCBvZiB0aGVcbiAgVVJTWVMgbWVzc2FnaW5nIHN5c3RlbS4gTmV0TWVzc2FnZXMgZG8gbm90IG5lZWQgYWRkcmVzc2VzLlxuXG4gIFRoaXMgTmV0UGFja2V0IGRlY2xhcmF0aW9uIGlzIFNIQVJFRCBpbiBib3RoIG5vZGUgYW5kIGJyb3dzZXIgamF2YXNjcmlwdFxuICBjb2RlYmFzZXMuXG5cbiAgRkVBVFVSRVNcblxuICAqIGhhbmRsZXMgYXN5bmNocm9ub3VzIHRyYW5zYWN0aW9uc1xuICAqIHdvcmtzIGluIGJvdGggbm9kZSBhbmQgYnJvd3NlciBjb250ZXh0c1xuICAqIGhhcyBhbiBcIm9mZmxpbmUgbW9kZVwiIHRvIHN1cHByZXNzIG5ldHdvcmsgbWVzc2FnZXMgd2l0aG91dCBlcnJvcmluZ1xuXG5cXCpcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCAqIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vKi9cblxuLy8vIERFUEVOREVOQ0lFUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuY29uc3QgUFJPTVBUUyA9IHJlcXVpcmUoJy4vdXRpbC9wcm9tcHRzJyk7XG5cbi8vLyBERUJVRyBNRVNTQUdFUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbmNvbnN0IERCRyA9IHsgc2VuZDogZmFsc2UsIHRyYW5zYWN0OiBmYWxzZSwgc2V0dXA6IGZhbHNlIH07XG5cbmNvbnN0IFBSID0gUFJPTVBUUy5tYWtlU3R5bGVGb3JtYXR0ZXIoJ1BLVCcpO1xuY29uc3QgRVJSID0gJzpFUlI6JztcbmNvbnN0IFBFUlIgPSBFUlIgKyBQUjtcbmNvbnN0IEVSUl9OT1RfTkVUTUVTRyA9IGAke1BFUlJ9b2JqIGRvZXMgbm90IHNlZW0gdG8gYmUgYSBOZXRQYWNrZXRgO1xuY29uc3QgRVJSX0JBRF9QUk9QID0gYCR7UEVSUn1wcm9wZXJ0eSBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nYDtcbmNvbnN0IEVSUl9FUlJfQkFEX0NTVFIgPSBgJHtQRVJSfWNvbnN0cnVjdG9yIGFyZ3MgYXJlIHN0cmluZywgb2JqZWN0YDtcbmNvbnN0IEVSUl9CQURfU09DS0VUID0gYCR7UEVSUn1zZW5kZXIgb2JqZWN0IG11c3QgaW1wbGVtZW50IHNlbmQoKWA7XG5jb25zdCBFUlJfRFVQRV9UUkFOUyA9IGAke1BFUlJ9dGhpcyBwYWNrZXQgdHJhbnNhY3Rpb24gaXMgYWxyZWFkeSByZWdpc3RlcmVkIWA7XG5jb25zdCBFUlJfTk9fR0xPQl9VQUREUiA9IGAke1BFUlJ9cGFja2V0IHNlbmRpbmcgYXR0ZW1wdGVkIGJlZm9yZSBVQUREUiBpcyBzZXQhYDtcbmNvbnN0IEVSUl9VTktOT1dOX1RZUEUgPSBgJHtQRVJSfXBhY2tldCB0eXBlIGlzIHVua25vd246YDtcbmNvbnN0IEVSUl9OT1RfUEFDS0VUID0gYCR7UEVSUn1wYXNzZWQgb2JqZWN0IGlzIG5vdCBhIE5ldFBhY2tldGA7XG5jb25zdCBFUlJfVU5LTk9XTl9STU9ERSA9IGAke1BFUlJ9cGFja2V0IHJvdXRpbmUgbW9kZSBpcyB1bmtub3duOmA7XG5cbi8vLyBDT05TVEFOVFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbmNvbnN0IE1fSU5JVCA9ICdpbml0JztcbmNvbnN0IE1fT05MSU5FID0gJ29ubGluZSc7XG5jb25zdCBNX1NUQU5EQUxPTkUgPSAnb2ZmbGluZSc7XG5jb25zdCBNX0NMT1NFRCA9ICdjbG9zZWQnO1xuY29uc3QgTV9FUlJPUiA9ICdlcnJvcic7XG5jb25zdCBWQUxJRF9DSEFOTkVMUyA9IFsnTE9DQUwnLCAnTkVUJywgJ1NUQVRFJ107IC8vICogaXMgYWxsIGNoYW5uZWxzIGluIGxpc3RcblxuLy8vIERFQ0xBUkFUSU9OUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxubGV0IG1faWRfY291bnRlciA9IDA7XG5sZXQgbV9pZF9wcmVmaXggPSAnUEtUJztcbmxldCBtX3RyYW5zYWN0aW9ucyA9IHt9O1xubGV0IG1fbmV0c29ja2V0ID0gbnVsbDtcbmxldCBtX2dyb3VwX2lkID0gbnVsbDtcbmxldCBtX21vZGUgPSBNX0lOSVQ7XG5cbi8vLyBFTlVNUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbmNvbnN0IFBBQ0tFVF9UWVBFUyA9IFtcbiAgJ21zZW5kJywgLy8gYSAnc2VuZCcgbWVzc2FnZSByZXR1cm5zIG5vIGRhdGFcbiAgJ21zaWcnLCAvLyBhICdzaWduYWwnIG1lc3NhZ2UgaXMgYSBzZW5kIHRoYXQgY2FsbHMgYWxsIGhhbmRsZXJzIGV2ZXJ5d2hlcmVcbiAgJ21jYWxsJywgLy8gYSAnY2FsbCcgbWVzc2FnZSByZXR1cm5zIGRhdGFcbiAgJ3N0YXRlJyAvLyAodW5pbXBsZW1lbnRlZCkgYSAnc3RhdGUnIG1lc3NhZ2UgaXMgdXNlZCBieSBhIHN0YXRlIG1hbmFnZXJcbl07XG5jb25zdCBUUkFOU0FDVElPTl9NT0RFID0gW1xuICAncmVxJywgLy8gcGFja2V0IGluIGluaXRpYWwgJ3JlcXVlc3QnIG1vZGVcbiAgJ3JlcycgLy8gcGFja2V0IGluIHJldHVybmVkICdyZXNwb25zZScgbW9kZVxuXTtcblxuLy8vIFVSU1lTIE5FVE1FU1NBR0UgQ0xBU1MgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIENsYXNzIE5ldFBhY2tldFxuICogQ29udGFpbmVyIGZvciBtZXNzYWdlcyB0aGF0IGNhbiBiZSBzZW50IGFjcm9zcyB0aGUgbmV0d29yayB0byB0aGUgVVJTWVNcbiAqIHNlcnZlci5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IE5ldFBhY2tldFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1zZyAtIG1lc3NhZ2VcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhIC0gbWVzc2FnZSBkYXRhXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBpbnRlcm5hbCBpZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgLSBwYWNrZXQgb3BlcmF0aW9uIHR5cGUgKDF3YXksMndheSxzeW5jKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJtb2RlIC0gdHJhbnNhY3Rpb24gZGlyZWN0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVtbyAtIGh1bWFuLXJlYWRhYmxlIGRlYnVnIG5vdGUgc3BhY2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZXFudW0gLSBzZXF1ZW5jZSBudW1iZXIgZm9yIHRyYW5zYWN0aW9uXG4gKiBAcHJvcGVydHkge0FycmF5fSBzZXFsb2cgLSBhcnJheSBvZiBzZXFudW1zLCBzdGFydGluZyB3aXRoIG9yaWdpbmF0aW5nIGFkZHJlc3NcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzX3VpZCAtIG9yaWdpbmF0aW5nIGJyb3dzZXIgaW50ZXJuYWwgZW5kcG9pbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzX3VhZGRyIC0gb3JpZ2luYXRpbmcgYnJvd3NlciBhZGRyZXNzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc19ncm91cCAtIGdyb3VwIHNlc3Npb24ga2V5XG4gKi9cbmNsYXNzIE5ldFBhY2tldCB7XG4gIC8qKiBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IG1zZyBtZXNzYWdlIG5hbWUsIG9yIGFuIGV4aXN0aW5nIHBsYWluIG9iamVjdCB0byBjb2VyY2UgaW50byBhIE5ldFBhY2tldFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBkYXRhIHBhY2tldCB0byBzZW5kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSBtZXNzYWdlIChkZWZpbmVkIGluIFBBQ0tFVF9UWVBFUylcbiAgICovXG4gIGNvbnN0cnVjdG9yKG1zZywgZGF0YSwgdHlwZSkge1xuICAgIC8vIE9QVElPTiAxXG4gICAgLy8gY3JlYXRlIE5ldFBhY2tldCBmcm9tIChnZW5lcmljIG9iamVjdClcbiAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ29iamVjdCcgJiYgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgaXQgaGFzIGEgbXNnIGFuZCBkYXRhIG9ialxuICAgICAgaWYgKHR5cGVvZiBtc2cubXNnICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgbXNnLmRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IEVycm9yKEVSUl9OT1RfTkVUTUVTRyk7XG4gICAgICB9XG4gICAgICAvLyBtZXJnZSBwcm9wZXJ0aWVzIGludG8gdGhpcyBuZXcgY2xhc3MgaW5zdGFuY2UgYW5kIHJldHVybiBpdFxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBtc2cpO1xuICAgICAgdGhpcy5zZXFsb2cgPSB0aGlzLnNlcWxvZy5zbGljZSgpOyAvLyBjb3B5IGFycmF5XG4gICAgICBtX1NlcUluY3JlbWVudCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBPUFRJT04gMlxuICAgIC8vIGNyZWF0ZSBOZXRQYWNrZXQgZnJvbSBKU09OLWVuY29kZWQgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnICYmIGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IG9iaiA9IEpTT04ucGFyc2UobXNnKTtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgb2JqKTtcbiAgICAgIG1fU2VxSW5jcmVtZW50KHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIE9QVElPTiAzXG4gICAgLy8gY3JlYXRlIG5ldyBOZXRQYWNrZXQgZnJvbSBzY3JhdGNoIChtZXNnLGRhdGEpXG4gICAgLy8gdW5pcXVlIGlkIGZvciBldmVyeSBOZXRQYWNrZXRcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSBtX0NoZWNrVHlwZSh0eXBlKTtcbiAgICBpZiAodHlwZW9mIG1zZyAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBFcnJvcihFUlJfRVJSX0JBRF9DU1RSKTtcbiAgICB9XG4gICAgLy8gYWxsb3cgY2FsbHMgd2l0aCBudWxsIGRhdGEgYnkgc2V0dGluZyB0byBlbXB0eSBvYmplY3RcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIHRoaXMubXNnID0gbXNnO1xuICAgIC8vIGlkIGFuZCBkZWJ1Z2dpbmcgbWVtbyBzdXBwb3J0XG4gICAgdGhpcy5pZCA9IHRoaXMuTWFrZU5ld0lEKCk7XG4gICAgdGhpcy5ybW9kZSA9IFRSQU5TQUNUSU9OX01PREVbMF07IC8vIGlzIGRlZmF1bHQgJ3JlcXVlc3QnICh0cmFucyByZXF1ZXN0KVxuICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgUEFDS0VUX1RZUEVTWzBdOyAvLyBpcyBkZWZhdWx0ICdtc2VuZCcgKG5vIHJldHVybilcbiAgICB0aGlzLm1lbW8gPSAnJztcbiAgICAvLyB0cmFuc2FjdGlvbiBzdXBwb3J0XG4gICAgdGhpcy5zZXFudW0gPSAwOyAvLyBwb3NpdGl2ZSB3aGVuIHBhcnQgb2YgdHJhbnNhY3Rpb25cbiAgICB0aGlzLnNlcWxvZyA9IFtdOyAvLyB0cmFuc2FjdGlvbiBsb2dcbiAgICAvLyBhZGRyZXNzaW5nIHN1cHBvcnRcbiAgICB0aGlzLnNfdWFkZHIgPSBOZXRQYWNrZXQuU29ja2V0VUFERFIoKSB8fCBudWxsOyAvLyBmaXJzdCBvcmlnaW5hdGluZyB1YWRkciBzZXQgYnkgU29ja2V0U2VuZCgpXG4gICAgdGhpcy5zX2dyb3VwID0gbnVsbDsgLy8gc2Vzc2lvbiBncm91cGlkIGlzIHNldCBieSBleHRlcm5hbCBtb2R1bGUgb25jZSB2YWxpZGF0ZWRcbiAgICB0aGlzLnNfdWlkID0gbnVsbDsgLy8gZmlyc3Qgb3JpZ2luYXRpbmcgVVJDSEFOIHNyY1VJRFxuICAgIC8vIGZpbHRlcmluZyBzdXBwb3J0XG4gIH0gLy8gY29uc3RydWN0b3JcblxuICAvLy8gQUNDRVNTU09SIE1FVEhPRFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LlR5cGUoKSByZXR1cm5zIHRoZSBUUkFOU0FDVElPTl9UWVBFIG9mIHRoaXMgcGFja2V0XG4gICAqL1xuICBUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LlR5cGUoKSByZXR1cm5zIHRydWUgaWYgdHlwZSBtYXRjaGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSB0eXBlIHRvIGNvbXBhcmUgd2l0aCB0aGUgcGFja2V0J3MgdHlwZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIElzVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZTtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBOZXRQYWNrZXQuU2V0VHlwZSgpIHNldHMgdGhlIHR5cGUgb2YgdGhlIHBhY2tldC4gTXVzdCBiZSBhIGtub3duIHR5cGVcbiAgICogaW4gUEFDS0VUX1RZUEVTXG4gICAqL1xuICBTZXRUeXBlKHR5cGUpIHtcbiAgICB0aGlzLnR5cGUgPSBtX0NoZWNrVHlwZSh0eXBlKTtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiByZXR1cm5zIHRoZSBtZXNzYWdlIHN0cmluZyBvZiBmb3JtIENIQU5ORUw6TUVTU0FHRSwgd2hlcmUgQ0hBTk5FTDpcbiAgICogaXMgb3B0aW9uYWxcbiAgICovXG4gIE1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMubXNnO1xuICB9XG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiByZXR1cm5zIE1FU1NBR0Ugd2l0aG91dCB0aGUgQ0hBTk5FTDogcHJlZml4LiBUaGUgY2hhbm5lbCAoZS5nLlxuICAgKiBORVQsIExPQ0FMLCBTVEFURSkgaXMgYWxzbyBzZXQgdHJ1ZVxuICAgKi9cbiAgRGVjb2RlZE1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIE5ldFBhY2tldC5FeHRyYWN0Q2hhbm5lbCh0aGlzLm1zZyk7XG4gIH1cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqIE5ldFBhY2tldC5JcygpIHJldHVybnMgdHJ1dGh5IHZhbHVlICh0aGlzLmRhdGEpIGlmIHRoZSBwYXNzZWQgbXNnc3RyXG4gICAqICBtYXRjaGVzIHRoZSBtZXNzYWdlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIE5ldFBhY2tldFxuICAgKi9cbiAgSXMobXNnc3RyKSB7XG4gICAgcmV0dXJuIG1zZ3N0ciA9PT0gdGhpcy5tc2cgPyB0aGlzLmRhdGEgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LklzU2VydmVyTWVzc2FnZSgpIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gcmV0dXJuIHRydWUgaWZcbiAgICogc2VydmVyIG1lc3NhZ2UgKi9cbiAgSXNTZXJ2ZXJNZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLm1zZy5zdGFydHNXaXRoKCdORVQ6U1JWXycpO1xuICB9XG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqIE5ldFBhY2tldC5TZXRNZXNzYWdlKCkgc2V0cyB0aGUgbWVzc2FnZSBmaWVsZFxuICAgKi9cbiAgU2V0TWVzc2FnZShtc2dzdHIpIHtcbiAgICB0aGlzLm1zZyA9IG1zZ3N0cjtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBOZXRQYWNrZXQuRGF0YSgpIHJldHVybnMgdGhlIGVudGlyZSBkYXRhIHBheWxvYWQgb3IgdGhlIHByb3BlcnR5IHdpdGhpblxuICAgKiB0aGUgZGF0YSBwYXlsb2FkIChjYW4gcmV0dXJuIHVuZGVmaW5lZCBpZiBwcm9wZXJ0eSBkb2Vzbid0IGV4aXN0KVxuICAgKi9cbiAgRGF0YShwcm9wKSB7XG4gICAgaWYgKCFwcm9wKSByZXR1cm4gdGhpcy5kYXRhO1xuICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHJldHVybiB0aGlzLmRhdGFbcHJvcF07XG4gICAgdGhyb3cgRXJyb3IoRVJSX0JBRF9QUk9QKTtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gc2V0IGRhdGEgb2JqZWN0IGVudGlyZWx5XG4gICAqL1xuICBTZXREYXRhKHByb3BPclZhbCwgdmFsKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wT3JWYWwgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLmRhdGEgPSBwcm9wT3JWYWw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcE9yVmFsID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5kYXRhW3Byb3BPclZhbF0gPSB2YWw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IEVycm9yKEVSUl9CQURfUFJPUCk7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0Lk1lbW8oKSByZXR1cm5zIHRoZSAnbWVtbycgZmllbGQgb2YgdGhlIHBhY2tldCAqL1xuICBNZW1vKCkge1xuICAgIHJldHVybiB0aGlzLm1lbW87XG4gIH1cblxuICBTZXRNZW1vKG1lbW8pIHtcbiAgICB0aGlzLm1lbW8gPSBtZW1vO1xuICB9XG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqIE5ldFBhY2tldC5KU09OKCkgcmV0dXJucyBhIHN0cmluZ2lmaWVkIEpTT04gdmVyc2lvbiBvZiB0aGUgcGFja2V0LiAqL1xuICBKU09OKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBOZXRQYWNrZXQuU291cmNlR3JvdXBJZCgpIHJldHVybiB0aGUgc2Vzc2lvbiBncm91cCBpZCBhc3NvY2lhdGVkIHdpdGhcbiAgICogdGhpcyBwYWNrZXQuXG4gICAqL1xuICBTb3VyY2VHcm91cElEKCkge1xuICAgIHJldHVybiB0aGlzLnNfZ3JvdXA7XG4gIH1cblxuICAvLy8gVFJBTlNBQ1RJT04gU1VQUE9SVCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LlNlcU51bSgpIHJldHVybnMgYSBub24tcG9zaXRpdmUgaW50ZWdlciB0aGF0IGlzIHRoZSBudW1iZXIgb2ZcbiAgICogdGltZXMgdGhpcyBwYWNrZXQgd2FzIHJldXNlZCBkdXJpbmcgYSB0cmFuc2FjdGlvbiAoZS5nLiAnbWNhbGwnIHR5cGVzKS5cbiAgICovXG4gIFNlcU51bSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXFudW07XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LlNvdXJjZUFkZHJlc3MoKSByZXR1cm5zIHRoZSBvcmlnaW5hdGluZyBicm93c2VyIG9mIHRoZSBwYWNrZXQsXG4gICAqIHdoaWNoIGlzIHRoZSBzb2NrZXRuYW1lIG1haW50YWluZWQgYnkgdGhlIFVSU1lTIHNlcnZlci4gSXQgaXMgdmFsaWQgb25seVxuICAgKiBhZnRlciB0aGUgVVJTWVMgc2VydmVyIGhhcyByZWNlaXZlZCBpdCwgc28gaXQgaXMgaW52YWxpZCB3aGVuIGEgTmV0UGFja2V0XG4gICAqIHBhY2tldCBpcyBmaXJzdCBjcmVhdGVkLlxuICAgKi9cbiAgU291cmNlQWRkcmVzcygpIHtcbiAgICAvKi8gTk9URVxuXG4gICAgICAgIHNfdWFkZHIgaXMgdGhlIG1vc3QgcmVjZW50IHNlbmRpbmcgYnJvd3Nlci5cblxuICAgICAgICBJZiBhIE5ldFBhY2tldCBwYWNrZXQgaXMgcmV1c2VkIGluIGEgdHJhbnNhY3Rpb24gKGUuZy4gYSBjYWxsIHRoYXQgcmV0dXJuc1xuICAgICAgICBkYXRhKSB0aGVuIHRoZSBvcmlnaW5hdGluZyBicm93c2VyIGlzIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICBsb2cgLnNlcWxvZ1xuICAgIC8qL1xuICAgIC8vIGlzIHRoaXMgcGFja2V0IG9yaWdpbmF0aW5nIGZyb20gc2VydmVyIHRvIGEgcmVtb3RlP1xuICAgIGlmIChcbiAgICAgIHRoaXMuc191YWRkciA9PT0gTmV0UGFja2V0LkRlZmF1bHRTZXJ2ZXJVQUREUigpICYmXG4gICAgICAhdGhpcy5tc2cuc3RhcnRzV2l0aCgnTkVUOlNWUl8nKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXMuc191YWRkcjtcbiAgICB9XG4gICAgLy8gdGhpcyBpcyBhIHJlZ3VsYXIgbWVzc2FnZSBmb3J3YXJkIHRvIHJlbW90ZSBoYW5kbGVyc1xuICAgIHJldHVybiB0aGlzLklzVHJhbnNhY3Rpb24oKSA/IHRoaXMuc2VxbG9nWzBdIDogdGhpcy5zX3VhZGRyO1xuICB9XG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBSZXR1cm4gdHJ1ZSBpZiB0aGlzIHBrdCBpcyBmcm9tIHRoZSBzZXJ2ZXIgdGFyZ2V0aW5nIHJlbW90ZSBoYW5kbGVyc1xuICAgKi9cbiAgSXNTZXJ2ZXJPcmlnaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuU291cmNlQWRkcmVzcygpID09PSBOZXRQYWNrZXQuRGVmYXVsdFNlcnZlclVBRERSKCk7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LkNvcHlTb3VyY2VBZGRyZXNzKCkgY29waWVzIHRoZSBzb3VyY2UgYWRkcmVzcyBvZiBzZXRzIHRoZVxuICAgKiBjdXJyZW50IGFkZHJlc3MgdG8gdGhlIG9yaWdpbmF0aW5nIFVSU1lTIGJyb3dzZXIgYWRkcmVzcy4gVXNlZCBieSBzZXJ2ZXJcbiAgICogZm9yd2FyZGluZyBhbmQgcmV0dXJuaW5nIHBhY2tldHMgYmV0d2VlbiByZW1vdGVzLlxuICAgKiBAcGFyYW0ge05ldFBhY2tldH0gcGt0IC0gdGhlIHBhY2tldCB0byBjb3B5IHNvdXJjZSBmcm9tXG4gICAqL1xuICBDb3B5U291cmNlQWRkcmVzcyhwa3QpIHtcbiAgICBpZiAocGt0LmNvbnN0cnVjdG9yLm5hbWUgIT09ICdOZXRQYWNrZXQnKSB0aHJvdyBFcnJvcihFUlJfTk9UX1BBQ0tFVCk7XG4gICAgdGhpcy5zX3VhZGRyID0gcGt0LlNvdXJjZUFkZHJlc3MoKTtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gc2VydmVyLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBOZXRQYWNrZXQuSW5mbygpIHJldHVybnMgZGVidWcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHBhY2tldFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gdHlwZSBvZiBkZWJ1ZyBpbmZvIChhbHdheXMgJ3NyYycgY3VycmVudGx5KVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzb3VyY2UgYnJvd3NlciArIGdyb3VwIChpZiBzZXQpXG4gICAqL1xuICBJbmZvKGtleSkge1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlICdzcmMnOiAvKiBmYWxscy10aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5Tb3VyY2VHcm91cElEKClcbiAgICAgICAgICA/IGAke3RoaXMuU291cmNlQWRkcmVzcygpfSBbJHt0aGlzLlNvdXJjZUdyb3VwSUQoKX1dYFxuICAgICAgICAgIDogYCR7dGhpcy5Tb3VyY2VBZGRyZXNzKCl9YDtcbiAgICB9XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0Lk1ha2VOZXdJRCgpIGlzIGEgdXRpbGl0eSBtZXRob2QgdGhhdCBnZW5lcmF0ZXMgYSB1bmlxdWUgaWQgZm9yXG4gICAqIGVhY2ggTmV0UGFja2V0IHBhY2tldC4gV2hlbiBjb21iaW5lZCB3aXRoIHNfdWFkZHIgYW5kIHNfc3JjdWlkLCB0aGlzIGdpdmVzXG4gICAqIGEgcGFja2V0IGEgdW5pcXVlIElEIGFjcm9zcyB0aGUgZW50aXJlIFVSU1lTIG5ldHdvcmsuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHVuaXF1ZSBpZFxuICAgKi9cbiAgTWFrZU5ld0lEKCkge1xuICAgIGxldCBpZFN0ciA9ICgrK21faWRfY291bnRlcikudG9TdHJpbmcoKTtcbiAgICB0aGlzLmlkID0gbV9pZF9wcmVmaXggKyBpZFN0ci5wYWRTdGFydCg1LCAnMCcpO1xuICAgIHJldHVybiB0aGlzLmlkO1xuICB9XG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqIE5ldFBhY2tldC5Tb2NrZXRTZW5kKCkgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgdG8gbGV0IHBhY2tldHMgJ3NlbmRcbiAgICogdGhlbXNlbHZlcycgdG8gdGhlIG5ldHdvcmsgdmlhIHRoZSBVUlNZUyBzZXJ2ZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0PW1fc29ja2V0fSBzb2NrZXQgLSB3ZWIgc29ja2V0IG9iamVjdC4gbV9zb2NrZXRcbiAgICogaXMgZGVmaW5lZCBvbmx5IG9uIGJyb3dzZXJzOyBzZWUgTmV0UGFja2V0Lkdsb2JhbFNldHVwKClcbiAgICovXG4gIFNvY2tldFNlbmQoc29ja2V0ID0gbV9uZXRzb2NrZXQpIHtcbiAgICBpZiAobV9tb2RlID09PSBNX09OTElORSB8fCBtX21vZGUgPT09IE1fSU5JVCkge1xuICAgICAgdGhpcy5zX2dyb3VwID0gTmV0UGFja2V0Lkdsb2JhbEdyb3VwSUQoKTtcbiAgICAgIGxldCBkc3QgPSBzb2NrZXQuVUFERFIgfHwgJ3VucmVnaXN0ZXJlZCBzb2NrZXQnO1xuICAgICAgaWYgKCFzb2NrZXQpIHRocm93IEVycm9yKCdTb2NrZXRTZW5kKHNvY2spIHJlcXVpcmVzIGEgdmFsaWQgc29ja2V0Jyk7XG4gICAgICBpZiAoREJHLnNlbmQpIHtcbiAgICAgICAgbGV0IHN0YXR1cyA9IGBzZW5kaW5nICcke3RoaXMuTWVzc2FnZSgpfScgdG8gJHtkc3R9YDtcbiAgICAgICAgY29uc29sZS5sb2coUFIsIHN0YXR1cyk7XG4gICAgICB9XG4gICAgICAvLyBmb3Igc2VydmVyLXNpZGUgd3MgbGlicmFyeSwgc2VuZCBzdXBwb3J0cyBhIGZ1bmN0aW9uIGNhbGxiYWNrXG4gICAgICAvLyBmb3IgV2ViU29ja2V0LCB0aGlzIGlzIGlnbm9yZWRcbiAgICAgIHNvY2tldC5zZW5kKHRoaXMuSlNPTigpLCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSBjb25zb2xlLmVycm9yKGBcXG5zb2NrZXQgJHtzb2NrZXQuVUFERFJ9IHJlcG9ydHMgZXJyb3IgJHtlcnJ9XFxuYCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1fbW9kZSAhPT0gTV9TVEFOREFMT05FKSB7XG4gICAgICBjb25zb2xlLmxvZyhQUiwgXCJTb2NrZXRTZW5kOiBDYW4ndCBzZW5kIGJlY2F1c2UgTmV0UGFja2V0IG1vZGUgaXNcIiwgbV9tb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFBSLCAnU1RBTkRBTE9ORSBNT0RFOiBTb2NrZXRTZW5kKCkgc3VwcHJlc3NlZCEnKTtcbiAgICB9XG4gICAgLy8gRllJOiBnbG9iYWwgbV9uZXRzb2NrZXQgaXMgbm90IGRlZmluZWQgb24gc2VydmVyLCBzaW5jZSBwYWNrZXRzIGFycml2ZSBvbiBtdWx0aXBsZSBzb2NrZXRzXG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LlByb21pc2VUcmFuc2FjdGlvbigpIG1hcHMgYSBwYWNrZXQgdG8gYSByZXR1cm4gaGFuZGxlciB1c2luZyBhXG4gICAqIHVuaXF1ZSBrZXkuIFRoaXMga2V5IGFsbG93cyBhbiBpbmNvbWluZyBwYWNrZXQgdG8gYmUgbWFwcGVkIGJhY2sgdG8gdGhlXG4gICAqIGNhbGxlciBldmVuIGlmIGl0IGlzIHRlY2huaWNhbGx5IGEgZGlmZmVyZW50IG9iamVjdCByZWNlaXZlZCBvdmVyIHRoZVxuICAgKiBuZXR3b3JrLlxuICAgKiBAcGFyYW0ge09iamVjdD1tX3NvY2tldH0gc29ja2V0IC0gd2ViIHNvY2tldCBvYmplY3QuIG1fc29ja2V0IGlzIGRlZmluZWRcbiAgICogb25seSBvbiBicm93c2Vyczsgc2VlIE5ldFBhY2tldC5HbG9iYWxTZXR1cCgpXG4gICAqL1xuICBQcm9taXNlVHJhbnNhY3Rpb24oc29ja2V0ID0gbV9uZXRzb2NrZXQpIHtcbiAgICBpZiAobV9tb2RlID09PSBNX1NUQU5EQUxPTkUpIHtcbiAgICAgIGNvbnNvbGUud2FybihQUiwgJ1NUQU5EQUxPTkUgTU9ERTogUHJvbWlzZVRyYW5zYWN0aW9uKCkgc3VwcHJlc3NlZCEnKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLy8gZ2xvYmFsIG1fbmV0c29ja2V0IGlzIG5vdCBkZWZpbmVkIG9uIHNlcnZlciwgc2luY2UgcGFja2V0cyBhcnJpdmUgb24gbXVsdGlwbGUgc29ja2V0c1xuICAgIGlmICghc29ja2V0KSB0aHJvdyBFcnJvcignUHJvbWlzZVRyYW5zYWN0aW9uKHNvY2spIHJlcXVpcmVzIGEgdmFsaWQgc29ja2V0Jyk7XG4gICAgLy8gc2F2ZSBvdXIgY3VycmVudCBVQUREUlxuICAgIHRoaXMuc2VxbG9nLnB1c2goTmV0UGFja2V0LlVBRERSKTtcbiAgICBsZXQgZGJnID0gREJHLnRyYW5zYWN0ICYmICF0aGlzLklzU2VydmVyTWVzc2FnZSgpO1xuICAgIGxldCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IGhhc2ggPSBtX0dldEhhc2hLZXkodGhpcyk7XG4gICAgICBpZiAobV90cmFuc2FjdGlvbnNbaGFzaF0pIHtcbiAgICAgICAgcmVqZWN0KEVycm9yKGAke0VSUl9EVVBFX1RSQU5TfToke2hhc2h9YCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2F2ZSB0aGUgcmVzb2x2ZSBmdW5jdGlvbiBpbiB0cmFuc2FjdGlvbnMgdGFibGU7XG4gICAgICAgIC8vIHByb21pc2Ugd2lsbCByZXNvbHZlIG9uIHJlbW90ZSBpbnZvY2F0aW9uIHdpdGggZGF0YVxuICAgICAgICBtX3RyYW5zYWN0aW9uc1toYXNoXSA9IGRhdGEgPT4ge1xuICAgICAgICAgIGlmIChkYmcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFBSLCAncmVzb2x2aW5nIHByb21pc2Ugd2l0aCcsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5Tb2NrZXRTZW5kKHNvY2tldCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LlJvdXRpbmdNb2RlKCkgcmV0dXJucyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBwYWNrZXQgdG8gYVxuICAgKiBkZXN0aW5hdGlvbiBoYW5kbGVyIChyZXEpIG9yIGJhY2sgdG8gdGhlIG9yaWdpbiAocmVzKS4gICovXG4gIFJvdXRpbmdNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLnJtb2RlO1xuICB9XG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqIE5ldFBhY2tldC5Jc1JlcXVlc3QoKSByZXR1cm5zIHRydWUgaWYgdGhpcyBwYWNrZXQgaXMgb25lIGJlaW5nIHNlbnRcbiAgICogdG8gYSByZW1vdGUgaGFuZGxlclxuICAgKi9cbiAgSXNSZXF1ZXN0KCkge1xuICAgIHJldHVybiB0aGlzLnJtb2RlID09PSAncmVxJztcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBOZXRQYWNrZXQuSXNSZXNwb25zZSgpIHJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgcGFja2V0XG4gICAqIGJlaW5nIHJldHVybmVkIGZyb20gYSByZW1vdGUgaGFuZGxlclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGlzIGEgdHJhbnNhY3Rpb24gcmVzcG9uc2VcbiAgICovXG4gIElzUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucm1vZGUgPT09ICdyZXMnO1xuICAgIC8vIG1vcmUgYnVsbGV0cHJvb2YgY2hlY2ssIGJ1dCB1bm5lY2Vzc2FyeVxuICAgIC8vIHJldHVybiB0aGlzLnJtb3ZlID09PSdyZXMnICYmIHRoaXMuU291cmNlQWRkcmVzcygpID09PSBOZXRQYWNrZXQuVUFERFI7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LklzVHJhbnNhY3Rpb24oKSB0ZXN0cyB3aGV0aGVyIHRoZSBwYWNrZXQgaXMgYSByZXNwb25zZSB0byBhXG4gICAqIGNhbGwgdGhhdCB3YXMgc2VudCBvdXQgcHJldmlvdXNseS5cbiAgICovXG4gIElzVHJhbnNhY3Rpb24oKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucm1vZGUgIT09ICdyZXEnICYmXG4gICAgICB0aGlzLnNlcW51bSA+IDAgJiZcbiAgICAgIHRoaXMuc2VxbG9nWzBdID09PSBOZXRQYWNrZXQuVUFERFJcbiAgICApO1xuICB9XG5cbiAgLy8vXHQtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBOZXRQYWNrZXQuUmV0dXJuVHJhbnNhY3Rpb24oKSBpcyB1c2VkIHRvIHNlbmQgYSBwYWNrZXQgYmFjayB0byBpdHNcbiAgICogb3JpZ2luLiBJdCBzYXZlcyB0aGUgY3VycmVudCBicm93c2VyIGFkZHJlc3MgKHN0b3JlZCBpbiBOZXRQYWNrZXQuVUFERFIpLFxuICAgKiBzZXRzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHBhY2tldCwgYW5kIHB1dHMgaXQgb24gdGhlIHNvY2tldC5cbiAgICogQHBhcmFtIHtPYmplY3Q9bV9zb2NrZXR9IHNvY2tldCAtIHdlYiBzb2NrZXQgb2JqZWN0LiBtX3NvY2tldCBpcyBkZWZpbmVkXG4gICAqIG9ubHkgb24gYnJvd3NlcnM7IHNlZSBOZXRQYWNrZXQuR2xvYmFsU2V0dXAoKVxuICAgKi9cbiAgUmV0dXJuVHJhbnNhY3Rpb24oc29ja2V0ID0gbV9uZXRzb2NrZXQpIHtcbiAgICAvLyBnbG9iYWwgbV9uZXRzb2NrZXQgaXMgbm90IGRlZmluZWQgb24gc2VydmVyLCBzaW5jZSBwYWNrZXRzIGFycml2ZSBvbiBtdWx0aXBsZSBzb2NrZXRzXG4gICAgaWYgKCFzb2NrZXQpIHRocm93IEVycm9yKCdSZXR1cm5UcmFuc2FjdGlvbihzb2NrKSByZXF1aXJlcyBhIHZhbGlkIHNvY2tldCcpO1xuICAgIC8vIG5vdGU6IHNlcW51bSBpcyBhbHJlYWR5IGluY3JlbWVudGVkIGJ5IHRoZSBjb25zdHJ1Y3RvciBpZiB0aGlzIHdhc1xuICAgIC8vIGEgcmVjZWl2ZWQgcGFja2V0XG4gICAgLy8gYWRkIHRoaXMgdG8gdGhlIHNlcXVlbmNlIGxvZ1xuICAgIHRoaXMuc2VxbG9nLnB1c2goTmV0UGFja2V0LlVBRERSKTtcbiAgICB0aGlzLnJtb2RlID0gbV9DaGVja1JNb2RlKCdyZXMnKTtcbiAgICB0aGlzLlNvY2tldFNlbmQoc29ja2V0KTtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBOZXRQYWNrZXQuQ29tcGxldGVUcmFuc2FjdGlvbigpIGlzIGNhbGxlZCB3aGVuIGEgcGFja2V0IGlzIHJlY2VpdmVkIGJhY2tcbiAgICogZnJvbSB0aGUgcmVtb3RlIGhhbmRsZXIuIEF0IHRoaXMgcG9pbnQsIHRoZSBvcmlnaW5hbCBjYWxsZXIgbmVlZHMgdG8gYmVcbiAgICogaW5mb3JtZWQgdmlhIHRoZSBzYXZlZCBmdW5jdGlvbiBoYW5kbGVyIGNyZWF0ZWQgaW5cbiAgICogTmV0UGFja2V0LlByb21pc2VUcmFuc2FjdGlvbigpLlxuICAgKi9cbiAgQ29tcGxldGVUcmFuc2FjdGlvbigpIHtcbiAgICBsZXQgZGJnID0gREJHLnRyYW5zYWN0ICYmICF0aGlzLklzU2VydmVyTWVzc2FnZSgpO1xuICAgIGxldCBoYXNoID0gbV9HZXRIYXNoS2V5KHRoaXMpO1xuICAgIGxldCByZXNvbHZlckZ1bmMgPSBtX3RyYW5zYWN0aW9uc1toYXNoXTtcbiAgICBpZiAoZGJnKSBjb25zb2xlLmxvZyhQUiwgJ0NvbXBsZXRlVHJhbnNhY3Rpb24nLCBoYXNoKTtcbiAgICBpZiAodHlwZW9mIHJlc29sdmVyRnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGB0cmFuc2FjdGlvbiBbJHtoYXNofV0gcmVzb2x2ZXJGdW5jdGlvbiBpcyB0eXBlICR7dHlwZW9mIHJlc29sdmVyRnVuY31gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlckZ1bmModGhpcy5kYXRhKTtcbiAgICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkobV90cmFuc2FjdGlvbnNbaGFzaF0pO1xuICAgIH1cbiAgfVxufSAvLyBjbGFzcyBOZXRQYWNrZXRcblxuLy8vIFNUQVRJQyBDTEFTUyBNRVRIT0RTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIE5ldFBhY2tldC5HbG9iYWxTZXR1cCgpIGlzIGEgc3RhdGljIG1ldGhvZCB0aGF0IGluaXRpYWxpemVzIHNoYXJlZFxuICogcGFyYW1ldGVycyBmb3IgdXNlIGJ5IGFsbCBpbnN0YW5jZXMgb2YgdGhlIE5ldFBhY2tldCBjbGFzcy4gSXQgaXMgdXNlZCBvbmx5XG4gKiBvbiBicm93c2Vycywgd2hpY2ggaGF2ZSBhIHNpbmdsZSBzb2NrZXQgY29ubmVjdGlvbi5cbiAqXG4gKiBJZiBubyBuZXRzb2NrZXQgcHJvcGVydHkgaXMgZGVmaW5lZCwgdGhlbiBOZXRQYWNrZXQgaW5zdGFuY2VzIHdpbGwgc3VycHJlc3NcbiAqIHNlbmRpbmcgb2YgbmV0d29yayBtZXNzYWdlcyB3aGlsZSBhbGxvd2luZyBsb2NhbCBtZXNzYWdlcyB0byB3b3JrIG5vcm1hbGx5LlxuICogU2VlIE5ldFBhY2tldC5HbG9iYWxPZmZsaW5lTW9kZSgpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gLSBjb25maWd1cmF0aW9uIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcubmV0c29ja2V0XSAtIHZhbGlkIHdlYnNvY2tldCB0byBVUlNZUyBzZXJ2ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnVhZGRyXSAtIFVSU1lTIGJyb3dzZXIgYWRkcmVzc1xuICovXG5OZXRQYWNrZXQuR2xvYmFsU2V0dXAgPSAoY29uZmlnID0ge30pID0+IHtcbiAgbGV0IHsgdWFkZHIsIG5ldHNvY2tldCwgcGVlcnMsIGlzX2xvY2FsIH0gPSBjb25maWc7XG4gIGlmICh1YWRkcikgTmV0UGFja2V0LlVBRERSID0gdWFkZHI7XG4gIGlmIChwZWVycykgTmV0UGFja2V0LlBFRVJTID0gcGVlcnM7XG4gIGlmIChuZXRzb2NrZXQpIHtcbiAgICAvLyBOT1RFOiBtX25ldHNvY2tldCBpcyBzZXQgb25seSBvbiBjbGllbnRzIHNpbmNlIG9uIHNlcnZlciwgdGhlcmUgYXJlXG4gICAgLy8gbXVsdGlwbGUgc29ja2V0c1xuICAgIGlmICh0eXBlb2YgbmV0c29ja2V0LnNlbmQgIT09ICdmdW5jdGlvbicpIHRocm93IEVycm9yKEVSUl9CQURfU09DS0VUKTtcbiAgICBpZiAoREJHLnNldHVwKSBjb25zb2xlLmxvZyhQUiwgJ0dsb2JhbFNldHVwOiBuZXRzb2NrZXQgc2V0LCBtb2RlIG9ubGluZScpO1xuICAgIG1fbmV0c29ja2V0ID0gbmV0c29ja2V0O1xuICAgIG1fbW9kZSA9IE1fT05MSU5FO1xuICB9XG4gIGlmIChpc19sb2NhbCkgTmV0UGFja2V0LlVMT0NBTCA9IGlzX2xvY2FsO1xufTtcbk5ldFBhY2tldC5VQUREUiA9ICdVTkFTU0lHTkVEJztcbk5ldFBhY2tldC5VTE9DQUwgPSBmYWxzZTsgLy8gc2V0IGlmIGNvbm5lY3Rpb24gaXMgYSBsb2NhbCBjb25uZWN0aW9uXG5OZXRQYWNrZXQuUEVFUlMgPSB1bmRlZmluZWQ7XG5cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBOZXRQYWNrZXQuR2xvYmFsQ2xlYW51cCgpIGlzIGEgc3RhdGljIG1ldGhvZCBjYWxsZWQgb25seSBieSB0aGUgY2xpZW50LFxuICogd2hpY2ggZHJvcHMgdGhlIGN1cnJlbnQgc29ja2V0IGFuZCBwdXRzIHRoZSBhcHAgaW4gJ2Nsb3NlZCcgc3RhdGUuIEluXG4gKiBwcmFjdGljZSB0aGlzIGNhbGwgZG9lc24ndCBhY2NvbXBsaXNoIG11Y2gsIGJ1dCBpcyBoZXJlIGZvciBzeW1tZXRyeSB0b1xuICogR2xvYmFsU2V0dXAoKS5cbiAqIEBmdW5jdGlvblxuICovXG5OZXRQYWNrZXQuR2xvYmFsQ2xlYW51cCA9ICgpID0+IHtcbiAgaWYgKG1fbmV0c29ja2V0KSB7XG4gICAgaWYgKERCRy5zZXR1cClcbiAgICAgIGNvbnNvbGUubG9nKFBSLCAnR2xvYmFsQ2xlYW51cDogZGVhbGxvY2F0aW5nIG5ldHNvY2tldCwgbW9kZSBjbG9zZWQnKTtcbiAgICBtX25ldHNvY2tldCA9IG51bGw7XG4gICAgbV9tb2RlID0gTV9DTE9TRUQ7XG4gICAgTmV0UGFja2V0LlVMT0NBTCA9IGZhbHNlO1xuICB9XG59O1xuXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogU3RhdGljIG1ldGhvZCBOZXRQYWNrZXQuR2xvYmFsT2ZmbGluZU1vZGUoKSBleHBsaWNpdGx5IHNldHMgdGhlIG1vZGUgdG8gU1RBTkRBTE9ORSwgd2hpY2hcbiAqIGFjdGl2ZWx5IHN1cHByZXNzZXMgcmVtb3RlIG5ldHdvcmsgY29tbXVuaWNhdGlvbiB3aXRob3V0IHRocm93aW5nIGVycm9ycy5cbiAqIEl0J3MgdXNlZCBmb3Igc3RhdGljIGNvZGUgc25hcHNob3RzIG9mIHRoZSB3ZWJhcHAgdGhhdCBkb24ndCBuZWVkIHRoZVxuICogbmV0d29yay5cbiAqIEBmdW5jdGlvblxuICovXG5OZXRQYWNrZXQuR2xvYmFsT2ZmbGluZU1vZGUgPSAoKSA9PiB7XG4gIG1fbW9kZSA9IE1fU1RBTkRBTE9ORTtcbiAgaWYgKG1fbmV0c29ja2V0KSB7XG4gICAgY29uc29sZS5sb2coLi4uUFIoJ1NUQU5EQUxPTkUgTU9ERTogTmV0UGFja2V0IGRpc2FibGluZyBuZXR3b3JrJykpO1xuICAgIG1fbmV0c29ja2V0ID0gbnVsbDtcbiAgICBsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ1VSU1lTRGlzY29ubmVjdCcsIHt9KTtcbiAgICBjb25zb2xlLmxvZyguLi5QUignU1RBTkRBTE9ORSBNT0RFOiBzZW5kaW5nIFVSU1lTRGlzY29ubmVjdCcpKTtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxufTtcbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKlxuICogQ29udmVydHMgJ0NIQU5ORUw6TUVTU0FHRScgc3RyaW5nIHRvIGFuIG9iamVjdCB3aXRoIGNoYW5uZWwsIG1lc3NhZ2VcbiAqIHByb3BlcnRpZXMuIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgOiBpbiB0aGUgbWVzc2FnZSBzdHJpbmcsIGl0J3MgbGVmdFxuICogYXMgcGFydCBvZiB0aGUgbWVzc2FnZS4gQWxsIHByb3BlcnRpZXMgcmV0dXJuZWQgaW4gYXJlIFVQUEVSQ0FTRS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gbWVzc2FnZSB3aXRoIG9wdGlvbmFsIGNoYW5uZWwgcHJlZml4XG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIGNvbnRhaW5zIGNoYW5uZWwgKFVDKSB0aGF0IGFyZSBzZXRcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBwYXJzZWQgPSBOZXRQYWNrZXQuRGVjb2RlQ2hhbm5lbCgnTkVUOk1ZX01FU1NBR0UnKTtcbiAqIGlmIChwYXJzZWQuTkVUKSBjb25zb2xlLmxvZygndGhpcyBpcyB0cnVlJyk7XG4gKiBpZiAocGFyc2VkLkxPQ0FMKSBjb25zb2xlLmxvZygndGhpcyBpcyBmYWxzZScpO1xuICogY29uc29sZS5sb2coJ21lc3NhZ2UgaXMnLHBhcnNlZC5NRVNTQUdFKTtcbiAqL1xuTmV0UGFja2V0LkV4dHJhY3RDaGFubmVsID0gZnVuY3Rpb24gRXh0cmFjdENoYW5uZWwobXNnKSB7XG4gIGxldCBbY2hhbm5lbCwgTUVTU0FHRV0gPSBtc2cuc3BsaXQoJzonLCAyKTtcbiAgLy8gbm8gOiBmb3VuZCwgbXVzdCBiZSBsb2NhbFxuICBpZiAoIU1FU1NBR0UpIHtcbiAgICBNRVNTQUdFID0gY2hhbm5lbDtcbiAgICBjaGFubmVsID0gJyc7XG4gIH1cbiAgY29uc3QgcGFyc2VkID0geyBNRVNTQUdFIH07XG4gIGlmICghY2hhbm5lbCkge1xuICAgIHBhcnNlZC5MT0NBTCA9IHRydWU7XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBpZiAoY2hhbm5lbCA9PT0gJyonKSB7XG4gICAgVkFMSURfQ0hBTk5FTFMuZm9yRWFjaChjaGFuID0+IHtcbiAgICAgIHBhcnNlZFtjaGFuXSA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBpZiAoVkFMSURfQ0hBTk5FTFMuaW5jbHVkZXMoY2hhbm5lbCkpIHtcbiAgICBwYXJzZWRbY2hhbm5lbF0gPSB0cnVlO1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgLy8gbGVnYWN5IG1lc3NhZ2VzIHVzZSBpbnZhbGlkIGNoYW5uZWwgbmFtZXNcbiAgLy8gZm9yIG5vdyBmb3J3YXJkIHRoZW0gYXMtaXNcbiAgY29uc29sZS53YXJuKGAnJHttc2d9JyByZXBsYWNlIDogd2l0aCBfYCk7XG4gIHBhcnNlZC5MT0NBTCA9IHRydWU7XG4gIHJldHVybiBwYXJzZWQ7XG4gIC8vIHRoaXMgaXMgd2hhdCBzaG91bGQgYWN0dWFsbHkgaGFwcGVuXG4gIC8vIHRocm93IEVycm9yKGBpbnZhbGlkIGNoYW5uZWwgJyR7Y2hhbm5lbH0nYCk7XG59O1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIE5ldFBhY2tldC5Tb2NrZXRVQUREUigpIGlzIGEgc3RhdGljIG1ldGhvZCByZXR1cm5pbmcgdGhlIGNsYXNzLXdpZGUgc2V0dGluZ1xuICogb2YgdGhlIGJyb3dzZXIgVUFERFIuIFRoaXMgaXMgb25seSB1c2VkIG9uIGJyb3dzZXIgY29kZS5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge3N0cmluZ30gVVJTWVMgYWRkcmVzcyBvZiB0aGUgY3VycmVudCBicm93c2VyLCBhIFVSU1lTIGFkZHJlc3NcbiAqL1xuTmV0UGFja2V0LlNvY2tldFVBRERSID0gKCkgPT4ge1xuICByZXR1cm4gTmV0UGFja2V0LlVBRERSO1xufTtcbk5ldFBhY2tldC5QZWVycyA9ICgpID0+IHtcbiAgcmV0dXJuIE5ldFBhY2tldC5QRUVSUztcbn07XG5OZXRQYWNrZXQuSXNMb2NhbGhvc3QgPSAoKSA9PiB7XG4gIHJldHVybiBOZXRQYWNrZXQuVUxPQ0FMO1xufTtcblxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIE5ldFBhY2tldC5EZWZhdWx0U2VydmVyVUFERFIoKSBpcyBhIHN0YXRpYyBtZXRob2QgcmV0dXJuaW5nIGEgaGFyZGNvZGVkXG4gKiBVUlNZUyBhZGRyZXNzIHJlZmVycmluZyB0byB0aGUgVVJTWVMgc2VydmVyLiBJdCBpcyB1c2VkIGJ5IHRoZSBzZXJ2ZXItc2lkZVxuICogY29kZSB0byBzZXQgdGhlIHNlcnZlciBhZGRyZXNzLCBhbmQgdGhlIGJyb3dzZXIgY2FuIHJlbHkgb24gaXQgYXMgd2VsbC5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge3N0cmluZ30gVVJTWVMgYWRkcmVzcyBvZiB0aGUgc2VydmVyXG4gKi9cbk5ldFBhY2tldC5EZWZhdWx0U2VydmVyVUFERFIgPSAoKSA9PiB7XG4gIHJldHVybiAnU1ZSXzAxJztcbn07XG5cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBOZXRQYWNrZXQuR2xvYmFsR3JvdXBJRCgpIGlzIGEgc3RhdGljIG1ldGhvZCByZXR1cm5pbmcgdGhlIHNlc3Npb24ga2V5XG4gKiAoYWthIGdyb3VwLWlkKSBzZXQgZm9yIHRoaXMgYnJvd3NlciBpbnN0YW5jZVxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBzZXNzaW9uIGtleVxuICovXG5OZXRQYWNrZXQuR2xvYmFsR3JvdXBJRCA9ICgpID0+IHtcbiAgcmV0dXJuIG1fZ3JvdXBfaWQ7XG59O1xuXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogTmV0UGFja2V0Lkdsb2JhbFNldEdyb3VwSUQoKSBpcyBhIHN0YXRpYyBtZXRob2QgdGhhdCBzdG9yZXMgdGhlIHBhc3NlZFxuICogdG9rZW4gYXMgdGhlIEdyb3VwSURcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gc3BlY2lhbCBzZXNzaW9uIGtleSBkYXRhXG4gKi9cbk5ldFBhY2tldC5HbG9iYWxTZXRHcm91cElEID0gdG9rZW4gPT4ge1xuICBtX2dyb3VwX2lkID0gdG9rZW47XG59O1xuXG4vLy8gUFJJVkFURSBDTEFTUyBIRUxQRVJTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKi8gREVQUkVDQVRFPyBVdGlsaXR5IGZ1bmN0aW9uIHRvIGluY3JlbWVudCB0aGUgcGFja2V0J3Mgc2VxdWVuY2UgbnVtYmVyXG4gKiAgQHBhcmFtIHtOZXRQYWNrZXR9IHBrdCAtIHBhY2tldCB0byBtb2RpZnlcbi8qL1xuZnVuY3Rpb24gbV9TZXFJbmNyZW1lbnQocGt0KSB7XG4gIHBrdC5zZXFudW0rKztcbiAgcmV0dXJuIHBrdDtcbn1cbi8vL1x0LSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKi8gVXRpbGl0eSB0byBjcmVhdGUgYSB1bmlxdWUgaGFzaCBrZXkgZnJvbSBwYWNrZXQgaW5mb3JtYXRpb24uIFVzZWQgYnlcbiAqICBQcm9taXNlVHJhbnNhY3Rpb24oKS5cbiAqICBAcGFyYW0ge05ldFBhY2tldH0gcGt0IC0gcGFja2V0IHRvIHVzZVxuICogIEByZXR1cm4ge3N0cmluZ30gaGFzaCBrZXkgc3RyaW5nXG4vKi9cbmZ1bmN0aW9uIG1fR2V0SGFzaEtleShwa3QpIHtcbiAgbGV0IGhhc2ggPSBgJHtwa3QuU291cmNlQWRkcmVzcygpfToke3BrdC5pZH1gO1xuICByZXR1cm4gaGFzaDtcbn1cbi8vL1x0LSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKi8gVXRpbGl0eSB0byBlbnN1cmUgdGhhdCB0aGUgcGFzc2VkIHR5cGUgaXMgb25lIG9mIHRoZSBhbGxvd2VkIHBhY2tldCB0eXBlcy5cbiAqICBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgaXMgbm90LlxuICogIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gYSBzdHJpbmcgdG8gYmUgbWF0Y2hlZCBhZ2FpbnN0IFBBQ0tFVF9UWVBFU1xuICogIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBzdHJpbmcgdGhhdCBwYXNzZWQgdGhlIHR5cGUgY2hlY2tcbi8qL1xuZnVuY3Rpb24gbV9DaGVja1R5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdXN0IHBhc3MgYSB0eXBlIHN0cmluZywgbm90ICR7dHlwZX1gKTtcbiAgfVxuICBpZiAoIVBBQ0tFVF9UWVBFUy5pbmNsdWRlcyh0eXBlKSkgdGhyb3cgRXJyb3IoYCR7RVJSX1VOS05PV05fVFlQRX0gJyR7dHlwZX0nYCk7XG4gIHJldHVybiB0eXBlO1xufVxuLy8vXHQtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qLyBVdGlsaXR5IHRvIGVuc3VyZSB0aGUgcGFzc2VkIHRyYW5zYWN0aW9uIG1vZGUgaXMgb25lIG9mIHRoZSBhbGxvd2VkXG4gKiAgdHlwZXMuIFRocm93cyBhbiBlcnJvciBpZiBpdCBpcyBub3QuXG4gKiAgQHBhcmFtIHtzdHJpbmd9IG1vZGUgLSBhIHN0cmluZyB0byBiZSBtYXRjaGVkIGFnYWluc3QgVFJBTlNBQ1RJT05fTU9ERVxuICogIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBzdHJpbmcgdGhlIHBhc3NlZCB0aGUgbW9kZSBjaGVja1xuLyovXG5mdW5jdGlvbiBtX0NoZWNrUk1vZGUobW9kZSkge1xuICBpZiAobW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdXN0IHBhc3MgYSBtb2RlIHN0cmluZywgbm90ICR7bW9kZX1gKTtcbiAgfVxuICBpZiAoIVRSQU5TQUNUSU9OX01PREUuaW5jbHVkZXMobW9kZSkpXG4gICAgdGhyb3cgRXJyb3IoYCR7RVJSX1VOS05PV05fUk1PREV9ICcke21vZGV9J2ApO1xuICByZXR1cm4gbW9kZTtcbn1cblxuLy8vIEVYUE9SVCBDTEFTUyBERUZJTklUSU9OIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuTmV0UGFja2V0LkNPREVfT0sgPSAwO1xuTmV0UGFja2V0LkNPREVfTk9fTUVTU0FHRSA9IDE7IC8vIHJlcXVlc3RlZCBtZXNzYWdlIGRvZXNuJ3QgZXhpc3Rcbk5ldFBhY2tldC5DT0RFX1NPQ19OT1NPQ0sgPSAtMTAwO1xuTmV0UGFja2V0LkNPREVfU0VTX1JFUVVJUkVfS0VZID0gLTIwMDsgLy8gYWNjZXNzIGtleSBub3Qgc2V0XG5OZXRQYWNrZXQuQ09ERV9TRVNfUkVRVUlSRV9MT0dJTiA9IC0yMDE7IC8vIHNvY2tldCB3YXMgbm90IGxvZ2dlZC1pblxuTmV0UGFja2V0LkNPREVfU0VTX0lOVkFMSURfS0VZID0gLTIwMjsgLy8gcHJvdmlkZWQga2V5IGRpZG4ndCBtYXRjaCBzb2NrZXQga2V5XG5OZXRQYWNrZXQuQ09ERV9TRVNfUkVfUkVHSVNURVIgPSAtMjAzOyAvLyBzZXNzaW9uIGF0dGVtcHRlZCB0byBsb2dpbiBhZ2FpblxuTmV0UGFja2V0LkNPREVfU0VTX0lOVkFMSURfVE9LRU4gPSAtMjA0OyAvLyBzZXNzaW9uIGF0dGVtcHRlZCB0byBsb2dpbiBhZ2FpblxuTmV0UGFja2V0LkNPREVfUkVHX0RFTklFRCA9IC0zMDA7IC8vIHJlZ2lzdHJhdGlvbiBvZiBoYW5kbGVyIGRlbmllZFxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLy8vIHVzaW5nIENvbW1vbkpTIGZvcm1hdCBvbiBwdXJwb3NlIGZvciBub2RlIGNvbXBhdGliaWxpdHlcbm1vZHVsZS5leHBvcnRzID0gTmV0UGFja2V0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/class-netpacket.js\n");

/***/ }),

/***/ "./src/class-phase-machine.js":
/*!************************************!*\
  !*** ./src/class-phase-machine.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*///////////////////////////////// ABOUT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\n\n  URSYS PhaseMachine is a class to implement simple \"phased execution\" by\n  operation and group. It's used for implementing looping lifecycle events.\n\n  EXAMPLE:\n\n    const PM = new PhaseMachine({\n      PHASE_RUN: [ 'INIT', 'LOAD', 'RUN', 'STOP ]\n    });\n    // hook function to phase\n    PM.Hook('INIT',(...args)=>{});\n    PM.Hook('LOAD',(...args)=>new Promise((resolve,reject)=>{});\n    // invocation\n    (async () => {\n      await PM.Execute('INIT');\n      await PM.ExecutePhase('PHASE_RUN');\n      await PM.ExecutePhaseParallel('PHASE_RUN');\n    })();\n\n  NOTES:\n  * It is up to you to implement the logic for when to execute phase\n    operations. See client-exec.js for examples.\n  * if you subscribe to a phase group operation, you receive the list of\n    phases and the current index at the beginning of each phase\n\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ * /////////////////////////////////////*/\n/// LIBRARIES /////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nconst PROMPTS = __webpack_require__(/*! ./util/prompts */ \"./src/util/prompts.js\"); /// DEBUG CONSTANTS ///////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nconst DBG = {\n  subs: true,\n  ops: false,\n  phases: false,\n  init: false\n};\nconst IS_NODE = typeof window === 'undefined';\nconst PR = PROMPTS.makeStyleFormatter('UR.PHM'); /// CONSTANTS & DECLARATIONS //////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst m_machines = new Map(); // store phasemachines <machinename,instance>\n\nconst m_queue = new Map(); // store by <machinename,['op',f]>\n/// PRIVATE HELPERS ///////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** UTILITY: call the hook object's function. This used to do additional\n *  checks to see if the function should be called based on the route.\n */\n\nfunction m_InvokeHook(op, hook, ...args) {\n  if (hook.scope) throw Error('scope checking is not implemented in this version of URSYS'); // execute callbac and return possible Promise\n\n  if (hook.f) return hook.f(...args); // if no hook.f, this hook was implicitly mocked\n\n  return undefined;\n} // end m_InvokeHook\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** UTILITY: process queued hooks for a phasemachine name.\n */\n\n\nfunction m_ProcessQueueFor(pmkey) {\n  const pm = m_machines.get(pmkey);\n\n  if (!pm) {\n    console.warn(...PR(`${pmkey} not yet defined`));\n    return;\n  }\n\n  const qhooks = m_queue.get(pmkey) || [];\n  if (DBG.init) console.log(...PR(`phasemachine '${pmkey}' has ${qhooks.length} queued ops`));\n\n  try {\n    qhooks.forEach(element => {\n      const [op, f] = element;\n      pm.Hook(op, f);\n    });\n    m_queue.delete(pmkey);\n  } catch (e) {\n    console.warn(...PR('Error while processing queued phasemachine hooks'));\n    throw Error(e.toString());\n  }\n} // end m_ProcessQueueFor\n/// URSYS PhaseMachine CLASS //////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nclass PhaseMachine {\n  /** CONSTRUCTOR: phases is an object of upper-case KEYS containing\n   *  arrays of OPERATION strings.\n   */\n  constructor(shortName, phases) {\n    if (typeof shortName !== 'string') throw Error('arg1 must be string');\n    if (shortName.length < 1) throw Error('arg1 string.length must be > 1');\n    if (m_machines.has(shortName)) throw Error(`already registered '${shortName}'`);\n    this.NAME = shortName;\n    this.OP_HOOKS = new Map();\n    this.PHASES = phases;\n    Object.keys(phases).forEach(phaseKey => {\n      this.OP_HOOKS.set(phaseKey, []); // add the phase name to ophooks map as special case\n\n      this.PHASES[phaseKey].forEach(opKey => {\n        this.OP_HOOKS.set(opKey, []); // add each op in the phase to ophooks map\n      });\n    }); // bind functions to instance so it can be called inside promises\n    // and asynchronous handler context\n\n    this.Hook = this.Hook.bind(this);\n    this.Execute = this.Execute.bind(this);\n    this.ExecutePhase = this.ExecutePhase.bind(this);\n    this.ExecutePhaseParallel = this.ExecutePhaseParallel.bind(this);\n    this.GetHookFunctions = this.GetHookFunctions.bind(this);\n    this.GetPhaseFunctionsAsMap = this.GetPhaseFunctionsAsMap.bind(this); // save instance by name\n\n    m_machines.set(shortName, this);\n    if (DBG.init) console.log(...PR(`phasemachine '${shortName}' saved`)); // check queued hooks\n\n    m_ProcessQueueFor(shortName);\n  } // end constructor\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** API: register an Operations Handler. <op> is a string constant\n   *  define in PHASES and converted into the MAP. <f> is a function that\n   *  will be invoked during the operation, and it can return a promise or value.\n   */\n\n\n  Hook(op, f, scope = '') {\n    // don't run on server\n    if (IS_NODE) return; // vestigial scope parameter check if we need it someday\n\n    if (typeof scope !== 'string') throw Error('<arg1> scope should be included'); // does this operation name exist?\n\n    if (typeof op !== 'string') throw Error(\"<arg2> must be PHASENAME (e.g. 'LOAD_ASSETS')\");\n    if (!this.OP_HOOKS.has(op)) throw Error(`Phase handler '${this.NAME}':'${op}' is not defined`);\n    let status = 'REGD';\n\n    if (!(f instanceof Function)) {\n      // no function means \"implicit mock\"\n      status = 'MOCK';\n    } // get the list of promises associated with this op\n    // and add the new promise\n\n\n    const hook = {\n      f,\n      scope\n    };\n    this.OP_HOOKS.get(op).push(hook);\n    if (DBG.init) console.log(...PR(`${status} '${this.NAME}.${op}' Hook`));\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** API: Execute all Promises associated with a op, completing when\n   *  all the callback functions complete. If the callback function returns\n   *  a Promise, this is added to a list of Promises to wait for before the\n   *  function returns control to the calling code.\n   */\n\n\n  Execute(op, ...args) {\n    // note: contents of PHASE_HOOKs are promise-generating functions\n    if (!this.OP_HOOKS.has(op)) throw Error(`${op} is not a recognized EXEC op`);\n    if (op.startsWith('PHASE_') && DBG.phases) console.log(`warning:${op} phase group executed as single op`); // check that there are promises to execute\n\n    let hooks = this.OP_HOOKS.get(op);\n\n    if (hooks.length === 0) {\n      if (DBG.ops) console.log(...this.PR(`[${op}] no subscribers`));\n      return Promise.resolve();\n    } // now execute handlers and promises\n\n\n    let icount = 0; // get an array of promises\n    // o contains 'f', 'scope' pushed in Hook() above\n\n    const promises = [];\n    hooks.forEach(hook => {\n      let retval = m_InvokeHook(op, hook, ...args);\n\n      if (retval instanceof Promise) {\n        icount++;\n        promises.push(retval);\n      }\n    });\n    if (DBG.ops && hooks.length) console.log(...this.PR(`[${op}] HANDLERS PROCESSED : ${hooks.length}`));\n    if (DBG.ops && icount) console.log(...this.PR(`[${op}] PROMISES QUEUED    : ${icount}`)); // wait for all promises to execute\n\n    return Promise.all(promises).then(values => {\n      if (DBG.ops && values.length) console.log(...this.PR(`[${op}] PROMISES RETVALS  : ${values.length}`, values));\n      return values;\n    }).catch(err => {\n      if (DBG.ops) console.log(...this.PR(`[${op}]: ${err}`));\n      throw Error(`[${op}]: ${err}`);\n    });\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** API: Execute all Promises associated with a Phase Group in serial\n   *  css-tricks.com/why-using-reduce-to-sequentially-resolve-promises-works/\n   */\n\n\n  ExecutePhase(phaseName, ...args) {\n    if (DBG.phases) console.log(...this.PR(`ExecutePhase('${phaseName}')`));\n    const ops = this.PHASES[phaseName];\n    if (ops === undefined) throw Error(`Phase \"${phaseName}\" doesn't exist in ${this.NAME}`);\n    const phaseHookFuncs = this.GetHookFunctions(phaseName);\n    let index = 0;\n    return ops.reduce(async (previousPromise, nextOp) => {\n      phaseHookFuncs.forEach(f => f(ops, index++));\n      await previousPromise; // wait for previous promise to finish\n\n      return this.Execute(nextOp, ...args); // queue next promise\n    }, phaseHookFuncs.forEach(f => f(ops, index++))); // initial value of previousPromise\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** API: Execute all Promises associated with a Phase Group in parallel\n   */\n\n\n  ExecutePhaseParallel(phaseName, ...args) {\n    const ops = this.PHASES[phaseName];\n    if (ops === undefined) throw Error(`Phase \"${phaseName}\" doesn't exist`);\n    return Promise.all(ops.map(op => this.Execute(op, ...args))); // fix this and return promise\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** UTILITY: Return hooks array for a given operation. Useful when\n   *  using closures to create an optimal execution function as in\n   *  client-exec SystemRun()\n   */\n\n\n  GetHookFunctions(op) {\n    if (DBG.ops) console.log(...this.PR(`getting hook for '${op}'`));\n    return this.OP_HOOKS.get(op).map(hook => hook.f);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** UTILITY: Return a Map organized by phase:functions[]\n   */\n\n\n  GetPhaseFunctionsAsMap(phaseName) {\n    if (!phaseName.startsWith('PHASE_')) throw Error(`${phaseName} is not a Phase Group name`);\n    if (DBG.ops) console.log(...this.PR(`getting hook map for phase '${phaseName}'`));\n    const phaseOps = this.PHASES[phaseName]; // list of operations in the phase\n\n    const map = new WeakMap();\n    phaseOps.forEach(pop => {\n      map.set(pop, this.OP_HOOKS.get(phaseName).map(hook => hook.f));\n    });\n    return map;\n  }\n\n} /// STATIC METHODS ////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Queue hook requests even if machine isn't already defined.\n *  This routine can be used as the standard hook method for UR clients.\n */\n\n\nPhaseMachine.QueueHookFor = (pmName, op, f) => {\n  if (typeof pmName !== 'string') throw Error('arg1 must be phasemachine name');\n  if (typeof op !== 'string') throw Error('arg2 must be phaseop name');\n  if (typeof f !== 'function' && f !== undefined) throw Error('arg3 must be function or undefined'); //\n\n  const pm = m_machines.get(pmName); // if phasemachine is already valid, then just hook it directly\n\n  if (pm) {\n    pm.Hook(op, f);\n    return;\n  } // otherwise, queue the request\n\n\n  if (!m_queue.has(pmName)) m_queue.set(pmName, []);\n  const q = m_queue.get(pmName);\n  q.push([op, f]); // array of 2-element arrays\n}; /// EXPORT CLASS DEFINITION ///////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nmodule.exports = PhaseMachine;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2xhc3MtcGhhc2UtbWFjaGluZS5qcz9lNmMzIl0sIm5hbWVzIjpbIlBST01QVFMiLCJyZXF1aXJlIiwiREJHIiwic3VicyIsIm9wcyIsInBoYXNlcyIsImluaXQiLCJJU19OT0RFIiwid2luZG93IiwiUFIiLCJtYWtlU3R5bGVGb3JtYXR0ZXIiLCJtX21hY2hpbmVzIiwiTWFwIiwibV9xdWV1ZSIsIm1fSW52b2tlSG9vayIsIm9wIiwiaG9vayIsImFyZ3MiLCJzY29wZSIsIkVycm9yIiwiZiIsInVuZGVmaW5lZCIsIm1fUHJvY2Vzc1F1ZXVlRm9yIiwicG1rZXkiLCJwbSIsImdldCIsImNvbnNvbGUiLCJ3YXJuIiwicWhvb2tzIiwibG9nIiwibGVuZ3RoIiwiZm9yRWFjaCIsImVsZW1lbnQiLCJIb29rIiwiZGVsZXRlIiwiZSIsInRvU3RyaW5nIiwiUGhhc2VNYWNoaW5lIiwiY29uc3RydWN0b3IiLCJzaG9ydE5hbWUiLCJoYXMiLCJOQU1FIiwiT1BfSE9PS1MiLCJQSEFTRVMiLCJPYmplY3QiLCJrZXlzIiwicGhhc2VLZXkiLCJzZXQiLCJvcEtleSIsImJpbmQiLCJFeGVjdXRlIiwiRXhlY3V0ZVBoYXNlIiwiRXhlY3V0ZVBoYXNlUGFyYWxsZWwiLCJHZXRIb29rRnVuY3Rpb25zIiwiR2V0UGhhc2VGdW5jdGlvbnNBc01hcCIsInN0YXR1cyIsIkZ1bmN0aW9uIiwicHVzaCIsInN0YXJ0c1dpdGgiLCJob29rcyIsIlByb21pc2UiLCJyZXNvbHZlIiwiaWNvdW50IiwicHJvbWlzZXMiLCJyZXR2YWwiLCJhbGwiLCJ0aGVuIiwidmFsdWVzIiwiY2F0Y2giLCJlcnIiLCJwaGFzZU5hbWUiLCJwaGFzZUhvb2tGdW5jcyIsImluZGV4IiwicmVkdWNlIiwicHJldmlvdXNQcm9taXNlIiwibmV4dE9wIiwibWFwIiwicGhhc2VPcHMiLCJXZWFrTWFwIiwicG9wIiwiUXVldWVIb29rRm9yIiwicG1OYW1lIiwicSIsIm1vZHVsZSIsImV4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QUssQ0FBQyxnQ0FBRCxDQUFYO0FBQ2hDLE1BQUksT0FBT0osRUFBUCxLQUFjLFFBQWxCLEVBQTRCLE1BQU1JLEtBQUssQ0FBQywyQkFBRCxDQUFYO0FBQzVCLE1BQUksT0FBT0MsQ0FBUCxLQUFhLFVBQWIsSUFBMkJBLENBQUMsS0FBS0MsU0FBckMsRUFDRSxNQUFNRixLQUFLLENBQUMsb0NBQUQsQ0FBWCxDQUoyQyxDQUs3Qzs7QUFDQSxRQUFNSyxFQUFFLEdBQUdiLFVBQVUsQ0FBQ2MsR0FBWCxDQUFld0QsTUFBZixDQUFYLENBTjZDLENBTzdDOztBQUNBLE1BQUl6RCxFQUFKLEVBQVE7QUFDTkEsTUFBRSxDQUFDUyxJQUFILENBQVFsQixFQUFSLEVBQVlLLENBQVo7QUFDQTtBQUNELEdBWDRDLENBWTdDOzs7QUFDQSxNQUFJLENBQUNQLE9BQU8sQ0FBQzJCLEdBQVIsQ0FBWXlDLE1BQVosQ0FBTCxFQUEwQnBFLE9BQU8sQ0FBQ2tDLEdBQVIsQ0FBWWtDLE1BQVosRUFBb0IsRUFBcEI7QUFDMUIsUUFBTUMsQ0FBQyxHQUFHckUsT0FBTyxDQUFDWSxHQUFSLENBQVl3RCxNQUFaLENBQVY7QUFDQUMsR0FBQyxDQUFDekIsSUFBRixDQUFPLENBQUMxQyxFQUFELEVBQUtLLENBQUwsQ0FBUCxFQWY2QyxDQWU1QjtBQUNsQixDQWhCRCxDLENBa0JBO0FBQ0E7OztBQUNBK0QsTUFBTSxDQUFDQyxPQUFQLEdBQWlCL0MsWUFBakIiLCJmaWxlIjoiLi9zcmMvY2xhc3MtcGhhc2UtbWFjaGluZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIEFCT1VUIFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwqXFxcblxuICBVUlNZUyBQaGFzZU1hY2hpbmUgaXMgYSBjbGFzcyB0byBpbXBsZW1lbnQgc2ltcGxlIFwicGhhc2VkIGV4ZWN1dGlvblwiIGJ5XG4gIG9wZXJhdGlvbiBhbmQgZ3JvdXAuIEl0J3MgdXNlZCBmb3IgaW1wbGVtZW50aW5nIGxvb3BpbmcgbGlmZWN5Y2xlIGV2ZW50cy5cblxuICBFWEFNUExFOlxuXG4gICAgY29uc3QgUE0gPSBuZXcgUGhhc2VNYWNoaW5lKHtcbiAgICAgIFBIQVNFX1JVTjogWyAnSU5JVCcsICdMT0FEJywgJ1JVTicsICdTVE9QIF1cbiAgICB9KTtcbiAgICAvLyBob29rIGZ1bmN0aW9uIHRvIHBoYXNlXG4gICAgUE0uSG9vaygnSU5JVCcsKC4uLmFyZ3MpPT57fSk7XG4gICAgUE0uSG9vaygnTE9BRCcsKC4uLmFyZ3MpPT5uZXcgUHJvbWlzZSgocmVzb2x2ZSxyZWplY3QpPT57fSk7XG4gICAgLy8gaW52b2NhdGlvblxuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBQTS5FeGVjdXRlKCdJTklUJyk7XG4gICAgICBhd2FpdCBQTS5FeGVjdXRlUGhhc2UoJ1BIQVNFX1JVTicpO1xuICAgICAgYXdhaXQgUE0uRXhlY3V0ZVBoYXNlUGFyYWxsZWwoJ1BIQVNFX1JVTicpO1xuICAgIH0pKCk7XG5cbiAgTk9URVM6XG4gICogSXQgaXMgdXAgdG8geW91IHRvIGltcGxlbWVudCB0aGUgbG9naWMgZm9yIHdoZW4gdG8gZXhlY3V0ZSBwaGFzZVxuICAgIG9wZXJhdGlvbnMuIFNlZSBjbGllbnQtZXhlYy5qcyBmb3IgZXhhbXBsZXMuXG4gICogaWYgeW91IHN1YnNjcmliZSB0byBhIHBoYXNlIGdyb3VwIG9wZXJhdGlvbiwgeW91IHJlY2VpdmUgdGhlIGxpc3Qgb2ZcbiAgICBwaGFzZXMgYW5kIHRoZSBjdXJyZW50IGluZGV4IGF0IHRoZSBiZWdpbm5pbmcgb2YgZWFjaCBwaGFzZVxuXG5cXCpcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcICogLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyovXG5cbi8vLyBMSUJSQVJJRVMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbmNvbnN0IFBST01QVFMgPSByZXF1aXJlKCcuL3V0aWwvcHJvbXB0cycpO1xuXG4vLy8gREVCVUcgQ09OU1RBTlRTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5jb25zdCBEQkcgPSB7IHN1YnM6IHRydWUsIG9wczogZmFsc2UsIHBoYXNlczogZmFsc2UsIGluaXQ6IGZhbHNlIH07XG5jb25zdCBJU19OT0RFID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5cbmNvbnN0IFBSID0gUFJPTVBUUy5tYWtlU3R5bGVGb3JtYXR0ZXIoJ1VSLlBITScpO1xuXG4vLy8gQ09OU1RBTlRTICYgREVDTEFSQVRJT05TIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5jb25zdCBtX21hY2hpbmVzID0gbmV3IE1hcCgpOyAvLyBzdG9yZSBwaGFzZW1hY2hpbmVzIDxtYWNoaW5lbmFtZSxpbnN0YW5jZT5cbmNvbnN0IG1fcXVldWUgPSBuZXcgTWFwKCk7IC8vIHN0b3JlIGJ5IDxtYWNoaW5lbmFtZSxbJ29wJyxmXT5cblxuLy8vIFBSSVZBVEUgSEVMUEVSUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIFVUSUxJVFk6IGNhbGwgdGhlIGhvb2sgb2JqZWN0J3MgZnVuY3Rpb24uIFRoaXMgdXNlZCB0byBkbyBhZGRpdGlvbmFsXG4gKiAgY2hlY2tzIHRvIHNlZSBpZiB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBiYXNlZCBvbiB0aGUgcm91dGUuXG4gKi9cbmZ1bmN0aW9uIG1fSW52b2tlSG9vayhvcCwgaG9vaywgLi4uYXJncykge1xuICBpZiAoaG9vay5zY29wZSlcbiAgICB0aHJvdyBFcnJvcignc2NvcGUgY2hlY2tpbmcgaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgdmVyc2lvbiBvZiBVUlNZUycpO1xuICAvLyBleGVjdXRlIGNhbGxiYWMgYW5kIHJldHVybiBwb3NzaWJsZSBQcm9taXNlXG4gIGlmIChob29rLmYpIHJldHVybiBob29rLmYoLi4uYXJncyk7XG4gIC8vIGlmIG5vIGhvb2suZiwgdGhpcyBob29rIHdhcyBpbXBsaWNpdGx5IG1vY2tlZFxuICByZXR1cm4gdW5kZWZpbmVkO1xufSAvLyBlbmQgbV9JbnZva2VIb29rXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogVVRJTElUWTogcHJvY2VzcyBxdWV1ZWQgaG9va3MgZm9yIGEgcGhhc2VtYWNoaW5lIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIG1fUHJvY2Vzc1F1ZXVlRm9yKHBta2V5KSB7XG4gIGNvbnN0IHBtID0gbV9tYWNoaW5lcy5nZXQocG1rZXkpO1xuICBpZiAoIXBtKSB7XG4gICAgY29uc29sZS53YXJuKC4uLlBSKGAke3Bta2V5fSBub3QgeWV0IGRlZmluZWRgKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHFob29rcyA9IG1fcXVldWUuZ2V0KHBta2V5KSB8fCBbXTtcbiAgaWYgKERCRy5pbml0KVxuICAgIGNvbnNvbGUubG9nKC4uLlBSKGBwaGFzZW1hY2hpbmUgJyR7cG1rZXl9JyBoYXMgJHtxaG9va3MubGVuZ3RofSBxdWV1ZWQgb3BzYCkpO1xuICB0cnkge1xuICAgIHFob29rcy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgW29wLCBmXSA9IGVsZW1lbnQ7XG4gICAgICBwbS5Ib29rKG9wLCBmKTtcbiAgICB9KTtcbiAgICBtX3F1ZXVlLmRlbGV0ZShwbWtleSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLndhcm4oLi4uUFIoJ0Vycm9yIHdoaWxlIHByb2Nlc3NpbmcgcXVldWVkIHBoYXNlbWFjaGluZSBob29rcycpKTtcbiAgICB0aHJvdyBFcnJvcihlLnRvU3RyaW5nKCkpO1xuICB9XG59IC8vIGVuZCBtX1Byb2Nlc3NRdWV1ZUZvclxuXG4vLy8gVVJTWVMgUGhhc2VNYWNoaW5lIENMQVNTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5jbGFzcyBQaGFzZU1hY2hpbmUge1xuICAvKiogQ09OU1RSVUNUT1I6IHBoYXNlcyBpcyBhbiBvYmplY3Qgb2YgdXBwZXItY2FzZSBLRVlTIGNvbnRhaW5pbmdcbiAgICogIGFycmF5cyBvZiBPUEVSQVRJT04gc3RyaW5ncy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNob3J0TmFtZSwgcGhhc2VzKSB7XG4gICAgaWYgKHR5cGVvZiBzaG9ydE5hbWUgIT09ICdzdHJpbmcnKSB0aHJvdyBFcnJvcignYXJnMSBtdXN0IGJlIHN0cmluZycpO1xuICAgIGlmIChzaG9ydE5hbWUubGVuZ3RoIDwgMSkgdGhyb3cgRXJyb3IoJ2FyZzEgc3RyaW5nLmxlbmd0aCBtdXN0IGJlID4gMScpO1xuICAgIGlmIChtX21hY2hpbmVzLmhhcyhzaG9ydE5hbWUpKVxuICAgICAgdGhyb3cgRXJyb3IoYGFscmVhZHkgcmVnaXN0ZXJlZCAnJHtzaG9ydE5hbWV9J2ApO1xuICAgIHRoaXMuTkFNRSA9IHNob3J0TmFtZTtcbiAgICB0aGlzLk9QX0hPT0tTID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuUEhBU0VTID0gcGhhc2VzO1xuICAgIE9iamVjdC5rZXlzKHBoYXNlcykuZm9yRWFjaChwaGFzZUtleSA9PiB7XG4gICAgICB0aGlzLk9QX0hPT0tTLnNldChwaGFzZUtleSwgW10pOyAvLyBhZGQgdGhlIHBoYXNlIG5hbWUgdG8gb3Bob29rcyBtYXAgYXMgc3BlY2lhbCBjYXNlXG4gICAgICB0aGlzLlBIQVNFU1twaGFzZUtleV0uZm9yRWFjaChvcEtleSA9PiB7XG4gICAgICAgIHRoaXMuT1BfSE9PS1Muc2V0KG9wS2V5LCBbXSk7IC8vIGFkZCBlYWNoIG9wIGluIHRoZSBwaGFzZSB0byBvcGhvb2tzIG1hcFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gYmluZCBmdW5jdGlvbnMgdG8gaW5zdGFuY2Ugc28gaXQgY2FuIGJlIGNhbGxlZCBpbnNpZGUgcHJvbWlzZXNcbiAgICAvLyBhbmQgYXN5bmNocm9ub3VzIGhhbmRsZXIgY29udGV4dFxuICAgIHRoaXMuSG9vayA9IHRoaXMuSG9vay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuRXhlY3V0ZSA9IHRoaXMuRXhlY3V0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuRXhlY3V0ZVBoYXNlID0gdGhpcy5FeGVjdXRlUGhhc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLkV4ZWN1dGVQaGFzZVBhcmFsbGVsID0gdGhpcy5FeGVjdXRlUGhhc2VQYXJhbGxlbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuR2V0SG9va0Z1bmN0aW9ucyA9IHRoaXMuR2V0SG9va0Z1bmN0aW9ucy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuR2V0UGhhc2VGdW5jdGlvbnNBc01hcCA9IHRoaXMuR2V0UGhhc2VGdW5jdGlvbnNBc01hcC5iaW5kKHRoaXMpO1xuICAgIC8vIHNhdmUgaW5zdGFuY2UgYnkgbmFtZVxuICAgIG1fbWFjaGluZXMuc2V0KHNob3J0TmFtZSwgdGhpcyk7XG4gICAgaWYgKERCRy5pbml0KSBjb25zb2xlLmxvZyguLi5QUihgcGhhc2VtYWNoaW5lICcke3Nob3J0TmFtZX0nIHNhdmVkYCkpO1xuICAgIC8vIGNoZWNrIHF1ZXVlZCBob29rc1xuICAgIG1fUHJvY2Vzc1F1ZXVlRm9yKHNob3J0TmFtZSk7XG4gIH0gLy8gZW5kIGNvbnN0cnVjdG9yXG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqIEFQSTogcmVnaXN0ZXIgYW4gT3BlcmF0aW9ucyBIYW5kbGVyLiA8b3A+IGlzIGEgc3RyaW5nIGNvbnN0YW50XG4gICAqICBkZWZpbmUgaW4gUEhBU0VTIGFuZCBjb252ZXJ0ZWQgaW50byB0aGUgTUFQLiA8Zj4gaXMgYSBmdW5jdGlvbiB0aGF0XG4gICAqICB3aWxsIGJlIGludm9rZWQgZHVyaW5nIHRoZSBvcGVyYXRpb24sIGFuZCBpdCBjYW4gcmV0dXJuIGEgcHJvbWlzZSBvciB2YWx1ZS5cbiAgICovXG4gIEhvb2sob3AsIGYsIHNjb3BlID0gJycpIHtcbiAgICAvLyBkb24ndCBydW4gb24gc2VydmVyXG4gICAgaWYgKElTX05PREUpIHJldHVybjtcbiAgICAvLyB2ZXN0aWdpYWwgc2NvcGUgcGFyYW1ldGVyIGNoZWNrIGlmIHdlIG5lZWQgaXQgc29tZWRheVxuICAgIGlmICh0eXBlb2Ygc2NvcGUgIT09ICdzdHJpbmcnKSB0aHJvdyBFcnJvcignPGFyZzE+IHNjb3BlIHNob3VsZCBiZSBpbmNsdWRlZCcpO1xuICAgIC8vIGRvZXMgdGhpcyBvcGVyYXRpb24gbmFtZSBleGlzdD9cbiAgICBpZiAodHlwZW9mIG9wICE9PSAnc3RyaW5nJylcbiAgICAgIHRocm93IEVycm9yKFwiPGFyZzI+IG11c3QgYmUgUEhBU0VOQU1FIChlLmcuICdMT0FEX0FTU0VUUycpXCIpO1xuICAgIGlmICghdGhpcy5PUF9IT09LUy5oYXMob3ApKVxuICAgICAgdGhyb3cgRXJyb3IoYFBoYXNlIGhhbmRsZXIgJyR7dGhpcy5OQU1FfSc6JyR7b3B9JyBpcyBub3QgZGVmaW5lZGApO1xuICAgIGxldCBzdGF0dXMgPSAnUkVHRCc7XG4gICAgaWYgKCEoZiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgLy8gbm8gZnVuY3Rpb24gbWVhbnMgXCJpbXBsaWNpdCBtb2NrXCJcbiAgICAgIHN0YXR1cyA9ICdNT0NLJztcbiAgICB9XG4gICAgLy8gZ2V0IHRoZSBsaXN0IG9mIHByb21pc2VzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG9wXG4gICAgLy8gYW5kIGFkZCB0aGUgbmV3IHByb21pc2VcbiAgICBjb25zdCBob29rID0geyBmLCBzY29wZSB9O1xuICAgIHRoaXMuT1BfSE9PS1MuZ2V0KG9wKS5wdXNoKGhvb2spO1xuICAgIGlmIChEQkcuaW5pdCkgY29uc29sZS5sb2coLi4uUFIoYCR7c3RhdHVzfSAnJHt0aGlzLk5BTUV9LiR7b3B9JyBIb29rYCkpO1xuICB9XG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBBUEk6IEV4ZWN1dGUgYWxsIFByb21pc2VzIGFzc29jaWF0ZWQgd2l0aCBhIG9wLCBjb21wbGV0aW5nIHdoZW5cbiAgICogIGFsbCB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zIGNvbXBsZXRlLiBJZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJuc1xuICAgKiAgYSBQcm9taXNlLCB0aGlzIGlzIGFkZGVkIHRvIGEgbGlzdCBvZiBQcm9taXNlcyB0byB3YWl0IGZvciBiZWZvcmUgdGhlXG4gICAqICBmdW5jdGlvbiByZXR1cm5zIGNvbnRyb2wgdG8gdGhlIGNhbGxpbmcgY29kZS5cbiAgICovXG4gIEV4ZWN1dGUob3AsIC4uLmFyZ3MpIHtcbiAgICAvLyBub3RlOiBjb250ZW50cyBvZiBQSEFTRV9IT09LcyBhcmUgcHJvbWlzZS1nZW5lcmF0aW5nIGZ1bmN0aW9uc1xuICAgIGlmICghdGhpcy5PUF9IT09LUy5oYXMob3ApKSB0aHJvdyBFcnJvcihgJHtvcH0gaXMgbm90IGEgcmVjb2duaXplZCBFWEVDIG9wYCk7XG4gICAgaWYgKG9wLnN0YXJ0c1dpdGgoJ1BIQVNFXycpICYmIERCRy5waGFzZXMpXG4gICAgICBjb25zb2xlLmxvZyhgd2FybmluZzoke29wfSBwaGFzZSBncm91cCBleGVjdXRlZCBhcyBzaW5nbGUgb3BgKTtcblxuICAgIC8vIGNoZWNrIHRoYXQgdGhlcmUgYXJlIHByb21pc2VzIHRvIGV4ZWN1dGVcbiAgICBsZXQgaG9va3MgPSB0aGlzLk9QX0hPT0tTLmdldChvcCk7XG4gICAgaWYgKGhvb2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKERCRy5vcHMpIGNvbnNvbGUubG9nKC4uLnRoaXMuUFIoYFske29wfV0gbm8gc3Vic2NyaWJlcnNgKSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgLy8gbm93IGV4ZWN1dGUgaGFuZGxlcnMgYW5kIHByb21pc2VzXG4gICAgbGV0IGljb3VudCA9IDA7XG4gICAgLy8gZ2V0IGFuIGFycmF5IG9mIHByb21pc2VzXG4gICAgLy8gbyBjb250YWlucyAnZicsICdzY29wZScgcHVzaGVkIGluIEhvb2soKSBhYm92ZVxuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgaG9va3MuZm9yRWFjaChob29rID0+IHtcbiAgICAgIGxldCByZXR2YWwgPSBtX0ludm9rZUhvb2sob3AsIGhvb2ssIC4uLmFyZ3MpO1xuICAgICAgaWYgKHJldHZhbCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgaWNvdW50Kys7XG4gICAgICAgIHByb21pc2VzLnB1c2gocmV0dmFsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREJHLm9wcyAmJiBob29rcy5sZW5ndGgpXG4gICAgICBjb25zb2xlLmxvZyguLi50aGlzLlBSKGBbJHtvcH1dIEhBTkRMRVJTIFBST0NFU1NFRCA6ICR7aG9va3MubGVuZ3RofWApKTtcbiAgICBpZiAoREJHLm9wcyAmJiBpY291bnQpXG4gICAgICBjb25zb2xlLmxvZyguLi50aGlzLlBSKGBbJHtvcH1dIFBST01JU0VTIFFVRVVFRCAgICA6ICR7aWNvdW50fWApKTtcblxuICAgIC8vIHdhaXQgZm9yIGFsbCBwcm9taXNlcyB0byBleGVjdXRlXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgLnRoZW4odmFsdWVzID0+IHtcbiAgICAgICAgaWYgKERCRy5vcHMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIC4uLnRoaXMuUFIoYFske29wfV0gUFJPTUlTRVMgUkVUVkFMUyAgOiAke3ZhbHVlcy5sZW5ndGh9YCwgdmFsdWVzKVxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmIChEQkcub3BzKSBjb25zb2xlLmxvZyguLi50aGlzLlBSKGBbJHtvcH1dOiAke2Vycn1gKSk7XG4gICAgICAgIHRocm93IEVycm9yKGBbJHtvcH1dOiAke2Vycn1gKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqIEFQSTogRXhlY3V0ZSBhbGwgUHJvbWlzZXMgYXNzb2NpYXRlZCB3aXRoIGEgUGhhc2UgR3JvdXAgaW4gc2VyaWFsXG4gICAqICBjc3MtdHJpY2tzLmNvbS93aHktdXNpbmctcmVkdWNlLXRvLXNlcXVlbnRpYWxseS1yZXNvbHZlLXByb21pc2VzLXdvcmtzL1xuICAgKi9cbiAgRXhlY3V0ZVBoYXNlKHBoYXNlTmFtZSwgLi4uYXJncykge1xuICAgIGlmIChEQkcucGhhc2VzKSBjb25zb2xlLmxvZyguLi50aGlzLlBSKGBFeGVjdXRlUGhhc2UoJyR7cGhhc2VOYW1lfScpYCkpO1xuICAgIGNvbnN0IG9wcyA9IHRoaXMuUEhBU0VTW3BoYXNlTmFtZV07XG4gICAgaWYgKG9wcyA9PT0gdW5kZWZpbmVkKVxuICAgICAgdGhyb3cgRXJyb3IoYFBoYXNlIFwiJHtwaGFzZU5hbWV9XCIgZG9lc24ndCBleGlzdCBpbiAke3RoaXMuTkFNRX1gKTtcbiAgICBjb25zdCBwaGFzZUhvb2tGdW5jcyA9IHRoaXMuR2V0SG9va0Z1bmN0aW9ucyhwaGFzZU5hbWUpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgcmV0dXJuIG9wcy5yZWR1Y2UoXG4gICAgICBhc3luYyAocHJldmlvdXNQcm9taXNlLCBuZXh0T3ApID0+IHtcbiAgICAgICAgcGhhc2VIb29rRnVuY3MuZm9yRWFjaChmID0+IGYob3BzLCBpbmRleCsrKSk7XG4gICAgICAgIGF3YWl0IHByZXZpb3VzUHJvbWlzZTsgLy8gd2FpdCBmb3IgcHJldmlvdXMgcHJvbWlzZSB0byBmaW5pc2hcbiAgICAgICAgcmV0dXJuIHRoaXMuRXhlY3V0ZShuZXh0T3AsIC4uLmFyZ3MpOyAvLyBxdWV1ZSBuZXh0IHByb21pc2VcbiAgICAgIH0sXG4gICAgICBwaGFzZUhvb2tGdW5jcy5mb3JFYWNoKGYgPT4gZihvcHMsIGluZGV4KyspKVxuICAgICk7IC8vIGluaXRpYWwgdmFsdWUgb2YgcHJldmlvdXNQcm9taXNlXG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogQVBJOiBFeGVjdXRlIGFsbCBQcm9taXNlcyBhc3NvY2lhdGVkIHdpdGggYSBQaGFzZSBHcm91cCBpbiBwYXJhbGxlbFxuICAgKi9cbiAgRXhlY3V0ZVBoYXNlUGFyYWxsZWwocGhhc2VOYW1lLCAuLi5hcmdzKSB7XG4gICAgY29uc3Qgb3BzID0gdGhpcy5QSEFTRVNbcGhhc2VOYW1lXTtcbiAgICBpZiAob3BzID09PSB1bmRlZmluZWQpIHRocm93IEVycm9yKGBQaGFzZSBcIiR7cGhhc2VOYW1lfVwiIGRvZXNuJ3QgZXhpc3RgKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwob3BzLm1hcChvcCA9PiB0aGlzLkV4ZWN1dGUob3AsIC4uLmFyZ3MpKSk7XG4gICAgLy8gZml4IHRoaXMgYW5kIHJldHVybiBwcm9taXNlXG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogVVRJTElUWTogUmV0dXJuIGhvb2tzIGFycmF5IGZvciBhIGdpdmVuIG9wZXJhdGlvbi4gVXNlZnVsIHdoZW5cbiAgICogIHVzaW5nIGNsb3N1cmVzIHRvIGNyZWF0ZSBhbiBvcHRpbWFsIGV4ZWN1dGlvbiBmdW5jdGlvbiBhcyBpblxuICAgKiAgY2xpZW50LWV4ZWMgU3lzdGVtUnVuKClcbiAgICovXG4gIEdldEhvb2tGdW5jdGlvbnMob3ApIHtcbiAgICBpZiAoREJHLm9wcykgY29uc29sZS5sb2coLi4udGhpcy5QUihgZ2V0dGluZyBob29rIGZvciAnJHtvcH0nYCkpO1xuICAgIHJldHVybiB0aGlzLk9QX0hPT0tTLmdldChvcCkubWFwKGhvb2sgPT4gaG9vay5mKTtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBVVElMSVRZOiBSZXR1cm4gYSBNYXAgb3JnYW5pemVkIGJ5IHBoYXNlOmZ1bmN0aW9uc1tdXG4gICAqL1xuICBHZXRQaGFzZUZ1bmN0aW9uc0FzTWFwKHBoYXNlTmFtZSkge1xuICAgIGlmICghcGhhc2VOYW1lLnN0YXJ0c1dpdGgoJ1BIQVNFXycpKVxuICAgICAgdGhyb3cgRXJyb3IoYCR7cGhhc2VOYW1lfSBpcyBub3QgYSBQaGFzZSBHcm91cCBuYW1lYCk7XG4gICAgaWYgKERCRy5vcHMpXG4gICAgICBjb25zb2xlLmxvZyguLi50aGlzLlBSKGBnZXR0aW5nIGhvb2sgbWFwIGZvciBwaGFzZSAnJHtwaGFzZU5hbWV9J2ApKTtcbiAgICBjb25zdCBwaGFzZU9wcyA9IHRoaXMuUEhBU0VTW3BoYXNlTmFtZV07IC8vIGxpc3Qgb2Ygb3BlcmF0aW9ucyBpbiB0aGUgcGhhc2VcbiAgICBjb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIHBoYXNlT3BzLmZvckVhY2gocG9wID0+IHtcbiAgICAgIG1hcC5zZXQoXG4gICAgICAgIHBvcCxcbiAgICAgICAgdGhpcy5PUF9IT09LUy5nZXQocGhhc2VOYW1lKS5tYXAoaG9vayA9PiBob29rLmYpXG4gICAgICApO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXA7XG4gIH1cbn1cblxuLy8vIFNUQVRJQyBNRVRIT0RTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIFF1ZXVlIGhvb2sgcmVxdWVzdHMgZXZlbiBpZiBtYWNoaW5lIGlzbid0IGFscmVhZHkgZGVmaW5lZC5cbiAqICBUaGlzIHJvdXRpbmUgY2FuIGJlIHVzZWQgYXMgdGhlIHN0YW5kYXJkIGhvb2sgbWV0aG9kIGZvciBVUiBjbGllbnRzLlxuICovXG5QaGFzZU1hY2hpbmUuUXVldWVIb29rRm9yID0gKHBtTmFtZSwgb3AsIGYpID0+IHtcbiAgaWYgKHR5cGVvZiBwbU5hbWUgIT09ICdzdHJpbmcnKSB0aHJvdyBFcnJvcignYXJnMSBtdXN0IGJlIHBoYXNlbWFjaGluZSBuYW1lJyk7XG4gIGlmICh0eXBlb2Ygb3AgIT09ICdzdHJpbmcnKSB0aHJvdyBFcnJvcignYXJnMiBtdXN0IGJlIHBoYXNlb3AgbmFtZScpO1xuICBpZiAodHlwZW9mIGYgIT09ICdmdW5jdGlvbicgJiYgZiAhPT0gdW5kZWZpbmVkKVxuICAgIHRocm93IEVycm9yKCdhcmczIG11c3QgYmUgZnVuY3Rpb24gb3IgdW5kZWZpbmVkJyk7XG4gIC8vXG4gIGNvbnN0IHBtID0gbV9tYWNoaW5lcy5nZXQocG1OYW1lKTtcbiAgLy8gaWYgcGhhc2VtYWNoaW5lIGlzIGFscmVhZHkgdmFsaWQsIHRoZW4ganVzdCBob29rIGl0IGRpcmVjdGx5XG4gIGlmIChwbSkge1xuICAgIHBtLkhvb2sob3AsIGYpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBvdGhlcndpc2UsIHF1ZXVlIHRoZSByZXF1ZXN0XG4gIGlmICghbV9xdWV1ZS5oYXMocG1OYW1lKSkgbV9xdWV1ZS5zZXQocG1OYW1lLCBbXSk7XG4gIGNvbnN0IHEgPSBtX3F1ZXVlLmdldChwbU5hbWUpO1xuICBxLnB1c2goW29wLCBmXSk7IC8vIGFycmF5IG9mIDItZWxlbWVudCBhcnJheXNcbn07XG5cbi8vLyBFWFBPUlQgQ0xBU1MgREVGSU5JVElPTiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbm1vZHVsZS5leHBvcnRzID0gUGhhc2VNYWNoaW5lO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/class-phase-machine.js\n");

/***/ }),

/***/ "./src/client-channel.js":
/*!*******************************!*\
  !*** ./src/client-channel.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable prefer-promise-reject-errors */\n\n/* eslint-disable lines-between-class-members */\n\n/* eslint-disable func-names */\n\n/* eslint-disable no-param-reassign */\n\n/*//////////////////////////////// ABOUT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\n\n    URSYS CHANNEL CLASS (URCHAN)\n\n    A URCHAN (channel) represents a connection to the URSYS message-passing\n    system for the app and optionally other entities on the URSYS Net.\n\n    Instances are created with URSYS.Connect() with a unique name for logging\n    purposes.\n\n    Additionally, each URCHAN has a unique local id (UID) that is assigned\n    a device address (UADDR). These are used together to make multiple URCHAN\n    instances in an UR App uniquely addressable, though users of URSYS\n    don't need to know that.\n\n    Channels can:\n\n    * subscribe to a named message, locally and from the network\n    * publish to a named message, locally and to the network\n    * call a named message and receive a response asychronously\n    * update state change message, locally and to the network\n    * synch a state change message, locally and from the network\n    * hook into a lifecycle message, locally and from the network\n\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ * //////////////////////////////////////*/\n/// LIBRARIES /////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n// NOTE: This module uses the COMMONJS module format for compatibility\n// between node and browser-side Javascript.\nconst Messager = __webpack_require__(/*! ./class-messager */ \"./src/class-messager.js\");\n\nconst DataMap = __webpack_require__(/*! ./class-datamap */ \"./src/class-datamap.js\");\n\nconst URNet = __webpack_require__(/*! ./client-network */ \"./src/client-network.js\");\n\nconst PROMPTS = __webpack_require__(/*! ./util/prompts */ \"./src/util/prompts.js\");\n\nconst PR = PROMPTS.makeStyleFormatter('UR.CHN');\n/** implements endpoints for talking to the URSYS network\n * @module URChan\n */\n/// DEBUGGING /////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst DBG = {\n  create: false,\n  send: false,\n  return: false,\n  register: false\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst BAD_NAME = 'name parameter must be a string';\nconst BAD_UID = 'unexpected non-unique UID'; /// NODE MANAGEMENT ///////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst UNODE_MAP = new Map(); // URSYS connector node map (local)\n\nconst MAX_UNODES = 100;\nlet UNODE_COUNTER = 0; // URSYS connector node id counter\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nfunction m_GetUniqueId() {\n  const id = `${++UNODE_COUNTER}`.padStart(3, '0');\n  if (UNODE_COUNTER > MAX_UNODES) console.warn('Unexpectedly high number of URCHAN nodes created!');\n  return `UDL${id}`;\n} /// GLOBAL MESSAGES ///////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nlet MESSAGER = new Messager(); // all urlinks share a common messager\n/// URSYS NODE CLASS /////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Instances of this class can register/unregister message handlers and also\n * send messages. Constructor receives an owner, which is inspected for\n * properties to determine how to classify the created messager for debugging\n * purposes\n * @memberof URChan\n */\n\nclass URChan {\n  /** constructor\n   * @param {object} owner the class instance or code module object\n   * @param {string} owner.name code module name set manually\n   * @param {string} [owner.constructor.name] for classes\n   * @param {string} optName optional name to use instead owner.name or owner.constructor.name\n   */\n  constructor(name) {\n    if (name !== undefined && typeof name !== 'string') {\n      throw Error(BAD_NAME);\n    } // bind function\n\n\n    this.UID = this.UID.bind(this);\n    this.Name = this.Name.bind(this);\n    this.UADDR = this.UADDR.bind(this);\n    this.Subscribe = this.Subscribe.bind(this);\n    this.Unsubscribe = this.Unsubscribe.bind(this);\n    this.Call = this.Call.bind(this);\n    this.Publish = this.Publish.bind(this);\n    this.Signal = this.Signal.bind(this);\n    this.LocalCall = this.LocalCall.bind(this);\n    this.LocalPublish = this.LocalPublish.bind(this);\n    this.LocalSignal = this.LocalSignal.bind(this);\n    this.NetCall = this.NetCall.bind(this);\n    this.NetPublish = this.NetPublish.bind(this);\n    this.NetSignal = this.NetSignal.bind(this); // generate and save unique id\n\n    this.uid = m_GetUniqueId();\n    this.name = name; // save module in the global module list\n\n    if (UNODE_MAP.has(this.uid)) throw Error(BAD_UID + this.uid);\n    if (DBG.create) console.log(PR, `${this.uid} <-> '${this.name}'`);\n    UNODE_MAP.set(this.uid, this);\n  } /// UNIQUE URSYS ID for local application\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /// this is used to differentiate sources of events so they don't echo\n\n\n  UID() {\n    return this.uid;\n  }\n\n  Name() {\n    return this.name;\n  }\n\n  UADDR() {\n    return URNet.SocketUADDR();\n  } /// MESSAGES ////////////////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** mesgName is a string, and is an official event that's defined by the\n   * subclasser of UnisysNode\n   */\n\n\n  Subscribe(mesgName, listener) {\n    // uid is \"source uid\" of subscribing object, to avoid reflection\n    // if the subscribing object is also the originating state changer\n    if (DBG.register) console.log(`${this.uid} _${PR} `, `${this.name} handler added[${mesgName}]`);\n    MESSAGER.Subscribe(mesgName, listener, {\n      handlerUID: this.UID()\n    });\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** variation of Subscribe that receives from remotes as well\n   */\n\n\n  NetSubscribe(mesgName, listener) {\n    // uid is \"source uid\" of subscribing object, to avoid reflection\n    // if the subscribing object is also the originating state changer\n    if (DBG.register) console.log(`${this.uid} _${PR} `, `${this.name} nethandler added[${mesgName}]`);\n    MESSAGER.Subscribe(mesgName, listener, {\n      fromNet: true,\n      handlerUID: this.UID()\n    });\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** remove a listener from message\n   */\n\n\n  Unsubscribe(mesgName, listener) {\n    if (DBG.register) console.log(`${this.uid} _${PR} `, `${this.name} handler removed[${mesgName}]`);\n    MESSAGER.Unsubscribe(mesgName, listener);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** URCHAN wraps Messager.CallAsync(), which returns an agregate data\n   * bundle after executing a bunch of promises async/await-style!\n   */\n\n\n  Call(mesgName, inData = {}, options = {}) {\n    options = Object.assign(options, {\n      type: 'mcall'\n    });\n    options.srcUID = this.UID(); // returns promise that resolves to data object\n\n    let result = MESSAGER.CallAsync(mesgName, inData, options);\n    return result;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** Sends the data to all message implementors UNLESS it is originating from\n   *   the same URCHAN instance (avoid echoing back to self)\n   */\n\n\n  Publish(mesgName, inData = {}, options = {}) {\n    if (typeof inData === 'function') throw Error('did you intend to use Subscribe() instead of Publish()?');\n    options = Object.assign(options, {\n      type: 'msend'\n    });\n    options.srcUID = this.UID();\n    MESSAGER.Publish(mesgName, inData, options);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** Sends the data to all message implementors, irregardless of origin.\n   */\n\n\n  Signal(mesgName, inData = {}, options = {}) {\n    options = Object.assign(options, {\n      type: 'msig'\n    });\n    MESSAGER.Signal(mesgName, inData, options);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** version of Call that forces local-only calls\n   */\n\n\n  LocalCall(mesgName, inData, options = {}) {\n    options = Object.assign(options, {\n      type: 'mcall'\n    });\n    options.toLocal = true;\n    options.toNet = false; // returns promise that resolve to data object\n\n    return this.Call(mesgName, inData, options);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** version of Send that force local-only calls\n   */\n\n\n  LocalPublish(mesgName, inData, options = {}) {\n    options = Object.assign(options, {\n      type: 'msend'\n    });\n    options.toLocal = true;\n    options.toNet = false;\n    this.Publish(mesgName, inData, options);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** version of Send that force local-only calls\n   */\n\n\n  LocalSignal(mesgName, inData, options = {}) {\n    options = Object.assign(options, {\n      type: 'msig'\n    });\n    options.toLocal = true;\n    options.toNet = false;\n    this.Signal(mesgName, inData, options);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** version of Call that forces network-only calls\n   */\n\n\n  NetCall(mesgName, inData, options = {}) {\n    options = Object.assign(options, {\n      type: 'mcall'\n    });\n    options.toLocal = false;\n    options.toNet = true; // returns promise that resolve to data object\n\n    return this.Call(mesgName, inData, options);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** version of Send that force network-only calls\n   */\n\n\n  NetPublish(mesgName, inData, options = {}) {\n    options = Object.assign(options, {\n      type: 'msend'\n    });\n    options.toLocal = false;\n    options.toNet = true;\n    this.Publish(mesgName, inData, options);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** version of Signal that forces network-only signal\n   */\n\n\n  NetSignal(mesgName, inData, options = {}) {\n    options.toLocal = false;\n    options.toNet = true;\n    this.Signal(mesgName, inData, options);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\n  NullCallback() {\n    if (DBG.send) console.log(`${this.uid} _${PR} `, 'null_callback', this.UID());\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /**\n   * Inform URSYS server that we have the following subscribers for the passed\n   * list of messages.\n   * @param {Array<string>} [messages] optional list of messages to register.\n   * If messages is empty, then it's assumed that we are registering all message\n   * subscribers.\n   */\n\n\n  RegisterSubscribers(messages = []) {\n    if (URNet.IsStandaloneMode()) {\n      console.warn(PR, 'STANDALONE MODE: RegisterMessagesPromise() suppressed!');\n      return Promise.resolve();\n    } // if there are no messages passed, then\n\n\n    if (messages.length) {\n      messages = MESSAGER.ValidateMessageNames(messages);\n    } else {\n      messages = MESSAGER.NetMessageNames();\n    } // returns promise that resolve to data object\n\n\n    const result = this.NetCall('NET:SRV_REG_HANDLERS', {\n      messages\n    });\n    return result;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /**\n   * Perform data operation to server. Do not call directly, but use\n   * UR.DBQuery(cmd,data). The cmd is looks up the corresponding URSYS\n   * message (e.g. add -> NET:SRV_DBADD)\n   * @example\n   * DataMap.DBQuery('add', { teachers: { name: 'NewTeacher' }});\n   */\n\n\n  _DBQuery(cmd, data) {\n    const opmsg = DataMap.GetCommandMessage(cmd);\n    if (!opmsg) return Promise.reject(`invalid operation '${cmd}'`);\n    if (data.cmd) return Promise.reject(\"do not include 'cmd' prop in data pack\");\n    if (!data.key) return Promise.reject(\"data must have access key 'key' defined\");\n    data.cmd = cmd;\n    let res = DataMap.ValidateCollections(data);\n    if (!res) return Promise.reject(`no-op: no valid collections found ${res}`); // got this far, so let's do the call!\n    // returns promise that resolve to data object\n\n    return this.NetCall(opmsg, data);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** Cooperative database element lock on server\n   */\n\n\n  _DBLock(data) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const {\n      dbkey,\n      dbids,\n      key\n    } = data;\n    if (!DataMap.IsValidKey(dbkey)) return Promise.reject(`invalid dbkey ${dbkey}`);\n    if (!DataMap.IsValidIdsArray(dbids)) return Promise.reject('dbids must be array of ints');\n    if (!data.key) return Promise.reject(\"data must have access key 'key' defined\");\n    if (!data.uaddr) return Promise.reject('data must have uaddr defined');\n    return this.NetCall('NET:SRV_DBLOCK', data);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** Cooperative database element release on server\n   */\n\n\n  _DBRelease(data) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const {\n      dbkey,\n      dbids,\n      key\n    } = data;\n    if (!DataMap.IsValidKey(dbkey)) return Promise.reject(`invalid dbkey ${dbkey}`);\n    if (!DataMap.IsValidIdsArray(dbids)) return Promise.reject('dbids must be array of ints');\n    if (!data.key) return Promise.reject(\"data must have access key 'key' defined\");\n    if (!data.uaddr) return Promise.reject('data must have uaddr defined');\n    return this.NetCall('NET:SRV_DBRELEASE', data);\n  }\n\n} // class URChan\n/// EXPORT CLASS DEFINITION ///////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nmodule.exports = URChan;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50LWNoYW5uZWwuanM/OTY5ZSJdLCJuYW1lcyI6WyJNZXNzYWdlciIsInJlcXVpcmUiLCJEYXRhTWFwIiwiVVJOZXQiLCJQUk9NUFRTIiwiUFIiLCJtYWtlU3R5bGVGb3JtYXR0ZXIiLCJEQkciLCJjcmVhdGUiLCJzZW5kIiwicmV0dXJuIiwicmVnaXN0ZXIiLCJCQURfTkFNRSIsIkJBRF9VSUQiLCJVTk9ERV9NQVAiLCJNYXAiLCJNQVhfVU5PREVTIiwiVU5PREVfQ09VTlRFUiIsIm1fR2V0VW5pcXVlSWQiLCJpZCIsInBhZFN0YXJ0IiwiY29uc29sZSIsIndhcm4iLCJNRVNTQUdFUiIsIlVSQ2hhbiIsImNvbnN0cnVjdG9yIiwibmFtZSIsInVuZGVmaW5lZCIsIkVycm9yIiwiVUlEIiwiYmluZCIsIk5hbWUiLCJVQUREUiIsIlN1YnNjcmliZSIsIlVuc3Vic2NyaWJlIiwiQ2FsbCIsIlB1Ymxpc2giLCJTaWduYWwiLCJMb2NhbENhbGwiLCJMb2NhbFB1Ymxpc2giLCJMb2NhbFNpZ25hbCIsIk5ldENhbGwiLCJOZXRQdWJsaXNoIiwiTmV0U2lnbmFsIiwidWlkIiwiaGFzIiwibG9nIiwic2V0IiwiU29ja2V0VUFERFIiLCJtZXNnTmFtZSIsImxpc3RlbmVyIiwiaGFuZGxlclVJRCIsIk5ldFN1YnNjcmliZSIsImZyb21OZXQiLCJpbkRhdGEiLCJvcHRpb25zIiwiT2JqZWN0IiwiYXNzaWduIiwidHlwZSIsInNyY1VJRCIsInJlc3VsdCIsIkNhbGxBc3luYyIsInRvTG9jYWwiLCJ0b05ldCIsIk51bGxDYWxsYmFjayIsIlJlZ2lzdGVyU3Vic2NyaWJlcnMiLCJtZXNzYWdlcyIsIklzU3RhbmRhbG9uZU1vZGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImxlbmd0aCIsIlZhbGlkYXRlTWVzc2FnZU5hbWVzIiwiTmV0TWVzc2FnZU5hbWVzIiwiX0RCUXVlcnkiLCJjbWQiLCJkYXRhIiwib3Btc2ciLCJHZXRDb21tYW5kTWVzc2FnZSIsInJlamVjdCIsImtleSIsInJlcyIsIlZhbGlkYXRlQ29sbGVjdGlvbnMiLCJfREJMb2NrIiwiZGJrZXkiLCJkYmlkcyIsIklzVmFsaWRLZXkiLCJJc1ZhbGlkSWRzQXJyYXkiLCJ1YWRkciIsIl9EQlJlbGVhc2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1BLFFBQVEsR0FBR0MsbUJBQU8sQ0FBQyxpREFBRCxDQUF4Qjs7QUFDQSxNQUFNQyxPQUFPLEdBQUdELG1CQUFPLENBQUMsK0NBQUQsQ0FBdkI7O0FBQ0EsTUFBTUUsS0FBSyxHQUFHRixtQkFBTyxDQUFDLGlEQUFELENBQXJCOztBQUNBLE1BQU1HLE9BQU8sR0FBR0gsbUJBQU8sQ0FBQyw2Q0FBRCxDQUF2Qjs7QUFFQSxNQUFNSSxFQUFFLEdBQUdELE9BQU8sQ0FBQ0Usa0JBQVIsQ0FBMkIsUUFBM0IsQ0FBWDtBQUVBOzs7QUFHQTtBQUNBOztBQUNBLE1BQU1DLEdBQUcsR0FBRztBQUFFQyxRQUFNLEVBQUUsS0FBVjtBQUFpQkMsTUFBSSxFQUFFLEtBQXZCO0FBQThCQyxRQUFNLEVBQUUsS0FBdEM7QUFBNkNDLFVBQVEsRUFBRTtBQUF2RCxDQUFaLEMsQ0FDQTs7QUFDQSxNQUFNQyxRQUFRLEdBQUcsaUNBQWpCO0FBQ0EsTUFBTUMsT0FBTyxHQUFHLDJCQUFoQixDLENBRUE7QUFDQTs7QUFDQSxNQUFNQyxTQUFTLEdBQUcsSUFBSUMsR0FBSixFQUFsQixDLENBQTZCOztBQUM3QixNQUFNQyxVQUFVLEdBQUcsR0FBbkI7QUFDQSxJQUFJQyxhQUFhLEdBQUcsQ0FBcEIsQyxDQUF1QjtBQUN2Qjs7QUFDQSxTQUFTQyxhQUFULEdBQXlCO0FBQ3ZCLFFBQU1DLEVBQUUsR0FBSSxHQUFFLEVBQUVGLGFBQWMsRUFBbkIsQ0FBcUJHLFFBQXJCLENBQThCLENBQTlCLEVBQWlDLEdB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bkIsQ0FBTCxFQUNFLE9BQU9mLE9BQU8sQ0FBQ1UsTUFBUixDQUFnQixpQkFBZ0JLLEtBQU0sRUFBdEMsQ0FBUDtBQUNGLFFBQUksQ0FBQ2pGLE9BQU8sQ0FBQ29GLGVBQVIsQ0FBd0JGLEtBQXhCLENBQUwsRUFDRSxPQUFPaEIsT0FBTyxDQUFDVSxNQUFSLENBQWUsNkJBQWYsQ0FBUDtBQUNGLFFBQUksQ0FBQ0gsSUFBSSxDQUFDSSxHQUFWLEVBQ0UsT0FBT1gsT0FBTyxDQUFDVSxNQUFSLENBQWUseUNBQWYsQ0FBUDtBQUNGLFFBQUksQ0FBQ0gsSUFBSSxDQUFDWSxLQUFWLEVBQWlCLE9BQU9uQixPQUFPLENBQUNVLE1BQVIsQ0FBZSw4QkFBZixDQUFQO0FBQ2pCLFdBQU8sS0FBS3JDLE9BQUwsQ0FBYSxtQkFBYixFQUFrQ2tDLElBQWxDLENBQVA7QUFDRDs7QUExUVUsQyxDQTJRWDtBQUVGO0FBQ0E7OztBQUNBYyxNQUFNLENBQUNDLE9BQVAsR0FBaUJsRSxNQUFqQiIsImZpbGUiOiIuL3NyYy9jbGllbnQtY2hhbm5lbC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1wcm9taXNlLXJlamVjdC1lcnJvcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIGxpbmVzLWJldHdlZW4tY2xhc3MtbWVtYmVycyAqL1xuLyogZXNsaW50LWRpc2FibGUgZnVuYy1uYW1lcyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbi8qLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gQUJPVVQgXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcKlxcXG5cbiAgICBVUlNZUyBDSEFOTkVMIENMQVNTIChVUkNIQU4pXG5cbiAgICBBIFVSQ0hBTiAoY2hhbm5lbCkgcmVwcmVzZW50cyBhIGNvbm5lY3Rpb24gdG8gdGhlIFVSU1lTIG1lc3NhZ2UtcGFzc2luZ1xuICAgIHN5c3RlbSBmb3IgdGhlIGFwcCBhbmQgb3B0aW9uYWxseSBvdGhlciBlbnRpdGllcyBvbiB0aGUgVVJTWVMgTmV0LlxuXG4gICAgSW5zdGFuY2VzIGFyZSBjcmVhdGVkIHdpdGggVVJTWVMuQ29ubmVjdCgpIHdpdGggYSB1bmlxdWUgbmFtZSBmb3IgbG9nZ2luZ1xuICAgIHB1cnBvc2VzLlxuXG4gICAgQWRkaXRpb25hbGx5LCBlYWNoIFVSQ0hBTiBoYXMgYSB1bmlxdWUgbG9jYWwgaWQgKFVJRCkgdGhhdCBpcyBhc3NpZ25lZFxuICAgIGEgZGV2aWNlIGFkZHJlc3MgKFVBRERSKS4gVGhlc2UgYXJlIHVzZWQgdG9nZXRoZXIgdG8gbWFrZSBtdWx0aXBsZSBVUkNIQU5cbiAgICBpbnN0YW5jZXMgaW4gYW4gVVIgQXBwIHVuaXF1ZWx5IGFkZHJlc3NhYmxlLCB0aG91Z2ggdXNlcnMgb2YgVVJTWVNcbiAgICBkb24ndCBuZWVkIHRvIGtub3cgdGhhdC5cblxuICAgIENoYW5uZWxzIGNhbjpcblxuICAgICogc3Vic2NyaWJlIHRvIGEgbmFtZWQgbWVzc2FnZSwgbG9jYWxseSBhbmQgZnJvbSB0aGUgbmV0d29ya1xuICAgICogcHVibGlzaCB0byBhIG5hbWVkIG1lc3NhZ2UsIGxvY2FsbHkgYW5kIHRvIHRoZSBuZXR3b3JrXG4gICAgKiBjYWxsIGEgbmFtZWQgbWVzc2FnZSBhbmQgcmVjZWl2ZSBhIHJlc3BvbnNlIGFzeWNocm9ub3VzbHlcbiAgICAqIHVwZGF0ZSBzdGF0ZSBjaGFuZ2UgbWVzc2FnZSwgbG9jYWxseSBhbmQgdG8gdGhlIG5ldHdvcmtcbiAgICAqIHN5bmNoIGEgc3RhdGUgY2hhbmdlIG1lc3NhZ2UsIGxvY2FsbHkgYW5kIGZyb20gdGhlIG5ldHdvcmtcbiAgICAqIGhvb2sgaW50byBhIGxpZmVjeWNsZSBtZXNzYWdlLCBsb2NhbGx5IGFuZCBmcm9tIHRoZSBuZXR3b3JrXG5cblxcKlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcICogLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8qL1xuXG4vLy8gTElCUkFSSUVTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vLyBOT1RFOiBUaGlzIG1vZHVsZSB1c2VzIHRoZSBDT01NT05KUyBtb2R1bGUgZm9ybWF0IGZvciBjb21wYXRpYmlsaXR5XG4vLyBiZXR3ZWVuIG5vZGUgYW5kIGJyb3dzZXItc2lkZSBKYXZhc2NyaXB0LlxuY29uc3QgTWVzc2FnZXIgPSByZXF1aXJlKCcuL2NsYXNzLW1lc3NhZ2VyJyk7XG5jb25zdCBEYXRhTWFwID0gcmVxdWlyZSgnLi9jbGFzcy1kYXRhbWFwJyk7XG5jb25zdCBVUk5ldCA9IHJlcXVpcmUoJy4vY2xpZW50LW5ldHdvcmsnKTtcbmNvbnN0IFBST01QVFMgPSByZXF1aXJlKCcuL3V0aWwvcHJvbXB0cycpO1xuXG5jb25zdCBQUiA9IFBST01QVFMubWFrZVN0eWxlRm9ybWF0dGVyKCdVUi5DSE4nKTtcblxuLyoqIGltcGxlbWVudHMgZW5kcG9pbnRzIGZvciB0YWxraW5nIHRvIHRoZSBVUlNZUyBuZXR3b3JrXG4gKiBAbW9kdWxlIFVSQ2hhblxuICovXG4vLy8gREVCVUdHSU5HIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5jb25zdCBEQkcgPSB7IGNyZWF0ZTogZmFsc2UsIHNlbmQ6IGZhbHNlLCByZXR1cm46IGZhbHNlLCByZWdpc3RlcjogZmFsc2UgfTtcbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbmNvbnN0IEJBRF9OQU1FID0gJ25hbWUgcGFyYW1ldGVyIG11c3QgYmUgYSBzdHJpbmcnO1xuY29uc3QgQkFEX1VJRCA9ICd1bmV4cGVjdGVkIG5vbi11bmlxdWUgVUlEJztcblxuLy8vIE5PREUgTUFOQUdFTUVOVCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuY29uc3QgVU5PREVfTUFQID0gbmV3IE1hcCgpOyAvLyBVUlNZUyBjb25uZWN0b3Igbm9kZSBtYXAgKGxvY2FsKVxuY29uc3QgTUFYX1VOT0RFUyA9IDEwMDtcbmxldCBVTk9ERV9DT1VOVEVSID0gMDsgLy8gVVJTWVMgY29ubmVjdG9yIG5vZGUgaWQgY291bnRlclxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuZnVuY3Rpb24gbV9HZXRVbmlxdWVJZCgpIHtcbiAgY29uc3QgaWQgPSBgJHsrK1VOT0RFX0NPVU5URVJ9YC5wYWRTdGFydCgzLCAnMCcpO1xuICBpZiAoVU5PREVfQ09VTlRFUiA+IE1BWF9VTk9ERVMpXG4gICAgY29uc29sZS53YXJuKCdVbmV4cGVjdGVkbHkgaGlnaCBudW1iZXIgb2YgVVJDSEFOIG5vZGVzIGNyZWF0ZWQhJyk7XG4gIHJldHVybiBgVURMJHtpZH1gO1xufVxuXG4vLy8gR0xPQkFMIE1FU1NBR0VTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5sZXQgTUVTU0FHRVIgPSBuZXcgTWVzc2FnZXIoKTsgLy8gYWxsIHVybGlua3Mgc2hhcmUgYSBjb21tb24gbWVzc2FnZXJcblxuLy8vIFVSU1lTIE5PREUgQ0xBU1MgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgY2FuIHJlZ2lzdGVyL3VucmVnaXN0ZXIgbWVzc2FnZSBoYW5kbGVycyBhbmQgYWxzb1xuICogc2VuZCBtZXNzYWdlcy4gQ29uc3RydWN0b3IgcmVjZWl2ZXMgYW4gb3duZXIsIHdoaWNoIGlzIGluc3BlY3RlZCBmb3JcbiAqIHByb3BlcnRpZXMgdG8gZGV0ZXJtaW5lIGhvdyB0byBjbGFzc2lmeSB0aGUgY3JlYXRlZCBtZXNzYWdlciBmb3IgZGVidWdnaW5nXG4gKiBwdXJwb3Nlc1xuICogQG1lbWJlcm9mIFVSQ2hhblxuICovXG5jbGFzcyBVUkNoYW4ge1xuICAvKiogY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtvYmplY3R9IG93bmVyIHRoZSBjbGFzcyBpbnN0YW5jZSBvciBjb2RlIG1vZHVsZSBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IG93bmVyLm5hbWUgY29kZSBtb2R1bGUgbmFtZSBzZXQgbWFudWFsbHlcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvd25lci5jb25zdHJ1Y3Rvci5uYW1lXSBmb3IgY2xhc3Nlc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0TmFtZSBvcHRpb25hbCBuYW1lIHRvIHVzZSBpbnN0ZWFkIG93bmVyLm5hbWUgb3Igb3duZXIuY29uc3RydWN0b3IubmFtZVxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBFcnJvcihCQURfTkFNRSk7XG4gICAgfVxuICAgIC8vIGJpbmQgZnVuY3Rpb25cbiAgICB0aGlzLlVJRCA9IHRoaXMuVUlELmJpbmQodGhpcyk7XG4gICAgdGhpcy5OYW1lID0gdGhpcy5OYW1lLmJpbmQodGhpcyk7XG4gICAgdGhpcy5VQUREUiA9IHRoaXMuVUFERFIuYmluZCh0aGlzKTtcbiAgICB0aGlzLlN1YnNjcmliZSA9IHRoaXMuU3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5VbnN1YnNjcmliZSA9IHRoaXMuVW5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLkNhbGwgPSB0aGlzLkNhbGwuYmluZCh0aGlzKTtcbiAgICB0aGlzLlB1Ymxpc2ggPSB0aGlzLlB1Ymxpc2guYmluZCh0aGlzKTtcbiAgICB0aGlzLlNpZ25hbCA9IHRoaXMuU2lnbmFsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5Mb2NhbENhbGwgPSB0aGlzLkxvY2FsQ2FsbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuTG9jYWxQdWJsaXNoID0gdGhpcy5Mb2NhbFB1Ymxpc2guYmluZCh0aGlzKTtcbiAgICB0aGlzLkxvY2FsU2lnbmFsID0gdGhpcy5Mb2NhbFNpZ25hbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuTmV0Q2FsbCA9IHRoaXMuTmV0Q2FsbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuTmV0UHVibGlzaCA9IHRoaXMuTmV0UHVibGlzaC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuTmV0U2lnbmFsID0gdGhpcy5OZXRTaWduYWwuYmluZCh0aGlzKTtcblxuICAgIC8vIGdlbmVyYXRlIGFuZCBzYXZlIHVuaXF1ZSBpZFxuICAgIHRoaXMudWlkID0gbV9HZXRVbmlxdWVJZCgpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgLy8gc2F2ZSBtb2R1bGUgaW4gdGhlIGdsb2JhbCBtb2R1bGUgbGlzdFxuICAgIGlmIChVTk9ERV9NQVAuaGFzKHRoaXMudWlkKSkgdGhyb3cgRXJyb3IoQkFEX1VJRCArIHRoaXMudWlkKTtcbiAgICBpZiAoREJHLmNyZWF0ZSkgY29uc29sZS5sb2coUFIsIGAke3RoaXMudWlkfSA8LT4gJyR7dGhpcy5uYW1lfSdgKTtcbiAgICBVTk9ERV9NQVAuc2V0KHRoaXMudWlkLCB0aGlzKTtcbiAgfVxuXG4gIC8vLyBVTklRVUUgVVJTWVMgSUQgZm9yIGxvY2FsIGFwcGxpY2F0aW9uXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8vLyB0aGlzIGlzIHVzZWQgdG8gZGlmZmVyZW50aWF0ZSBzb3VyY2VzIG9mIGV2ZW50cyBzbyB0aGV5IGRvbid0IGVjaG9cbiAgVUlEKCkge1xuICAgIHJldHVybiB0aGlzLnVpZDtcbiAgfVxuXG4gIE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIFVBRERSKCkge1xuICAgIHJldHVybiBVUk5ldC5Tb2NrZXRVQUREUigpO1xuICB9XG5cbiAgLy8vIE1FU1NBR0VTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqIG1lc2dOYW1lIGlzIGEgc3RyaW5nLCBhbmQgaXMgYW4gb2ZmaWNpYWwgZXZlbnQgdGhhdCdzIGRlZmluZWQgYnkgdGhlXG4gICAqIHN1YmNsYXNzZXIgb2YgVW5pc3lzTm9kZVxuICAgKi9cbiAgU3Vic2NyaWJlKG1lc2dOYW1lLCBsaXN0ZW5lcikge1xuICAgIC8vIHVpZCBpcyBcInNvdXJjZSB1aWRcIiBvZiBzdWJzY3JpYmluZyBvYmplY3QsIHRvIGF2b2lkIHJlZmxlY3Rpb25cbiAgICAvLyBpZiB0aGUgc3Vic2NyaWJpbmcgb2JqZWN0IGlzIGFsc28gdGhlIG9yaWdpbmF0aW5nIHN0YXRlIGNoYW5nZXJcbiAgICBpZiAoREJHLnJlZ2lzdGVyKVxuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGAke3RoaXMudWlkfSBfJHtQUn0gYCxcbiAgICAgICAgYCR7dGhpcy5uYW1lfSBoYW5kbGVyIGFkZGVkWyR7bWVzZ05hbWV9XWBcbiAgICAgICk7XG4gICAgTUVTU0FHRVIuU3Vic2NyaWJlKG1lc2dOYW1lLCBsaXN0ZW5lciwgeyBoYW5kbGVyVUlEOiB0aGlzLlVJRCgpIH0pO1xuICB9XG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiB2YXJpYXRpb24gb2YgU3Vic2NyaWJlIHRoYXQgcmVjZWl2ZXMgZnJvbSByZW1vdGVzIGFzIHdlbGxcbiAgICovXG4gIE5ldFN1YnNjcmliZShtZXNnTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAvLyB1aWQgaXMgXCJzb3VyY2UgdWlkXCIgb2Ygc3Vic2NyaWJpbmcgb2JqZWN0LCB0byBhdm9pZCByZWZsZWN0aW9uXG4gICAgLy8gaWYgdGhlIHN1YnNjcmliaW5nIG9iamVjdCBpcyBhbHNvIHRoZSBvcmlnaW5hdGluZyBzdGF0ZSBjaGFuZ2VyXG4gICAgaWYgKERCRy5yZWdpc3RlcilcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBgJHt0aGlzLnVpZH0gXyR7UFJ9IGAsXG4gICAgICAgIGAke3RoaXMubmFtZX0gbmV0aGFuZGxlciBhZGRlZFske21lc2dOYW1lfV1gXG4gICAgICApO1xuICAgIE1FU1NBR0VSLlN1YnNjcmliZShtZXNnTmFtZSwgbGlzdGVuZXIsIHtcbiAgICAgIGZyb21OZXQ6IHRydWUsXG4gICAgICBoYW5kbGVyVUlEOiB0aGlzLlVJRCgpXG4gICAgfSk7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogcmVtb3ZlIGEgbGlzdGVuZXIgZnJvbSBtZXNzYWdlXG4gICAqL1xuICBVbnN1YnNjcmliZShtZXNnTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoREJHLnJlZ2lzdGVyKVxuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGAke3RoaXMudWlkfSBfJHtQUn0gYCxcbiAgICAgICAgYCR7dGhpcy5uYW1lfSBoYW5kbGVyIHJlbW92ZWRbJHttZXNnTmFtZX1dYFxuICAgICAgKTtcbiAgICBNRVNTQUdFUi5VbnN1YnNjcmliZShtZXNnTmFtZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqIFVSQ0hBTiB3cmFwcyBNZXNzYWdlci5DYWxsQXN5bmMoKSwgd2hpY2ggcmV0dXJucyBhbiBhZ3JlZ2F0ZSBkYXRhXG4gICAqIGJ1bmRsZSBhZnRlciBleGVjdXRpbmcgYSBidW5jaCBvZiBwcm9taXNlcyBhc3luYy9hd2FpdC1zdHlsZSFcbiAgICovXG4gIENhbGwobWVzZ05hbWUsIGluRGF0YSA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7IHR5cGU6ICdtY2FsbCcgfSk7XG4gICAgb3B0aW9ucy5zcmNVSUQgPSB0aGlzLlVJRCgpO1xuICAgIC8vIHJldHVybnMgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGRhdGEgb2JqZWN0XG4gICAgbGV0IHJlc3VsdCA9IE1FU1NBR0VSLkNhbGxBc3luYyhtZXNnTmFtZSwgaW5EYXRhLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqIFNlbmRzIHRoZSBkYXRhIHRvIGFsbCBtZXNzYWdlIGltcGxlbWVudG9ycyBVTkxFU1MgaXQgaXMgb3JpZ2luYXRpbmcgZnJvbVxuICAgKiAgIHRoZSBzYW1lIFVSQ0hBTiBpbnN0YW5jZSAoYXZvaWQgZWNob2luZyBiYWNrIHRvIHNlbGYpXG4gICAqL1xuICBQdWJsaXNoKG1lc2dOYW1lLCBpbkRhdGEgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBpbkRhdGEgPT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBFcnJvcignZGlkIHlvdSBpbnRlbmQgdG8gdXNlIFN1YnNjcmliZSgpIGluc3RlYWQgb2YgUHVibGlzaCgpPycpO1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHsgdHlwZTogJ21zZW5kJyB9KTtcbiAgICBvcHRpb25zLnNyY1VJRCA9IHRoaXMuVUlEKCk7XG4gICAgTUVTU0FHRVIuUHVibGlzaChtZXNnTmFtZSwgaW5EYXRhLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBTZW5kcyB0aGUgZGF0YSB0byBhbGwgbWVzc2FnZSBpbXBsZW1lbnRvcnMsIGlycmVnYXJkbGVzcyBvZiBvcmlnaW4uXG4gICAqL1xuICBTaWduYWwobWVzZ05hbWUsIGluRGF0YSA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7IHR5cGU6ICdtc2lnJyB9KTtcbiAgICBNRVNTQUdFUi5TaWduYWwobWVzZ05hbWUsIGluRGF0YSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogdmVyc2lvbiBvZiBDYWxsIHRoYXQgZm9yY2VzIGxvY2FsLW9ubHkgY2FsbHNcbiAgICovXG4gIExvY2FsQ2FsbChtZXNnTmFtZSwgaW5EYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7IHR5cGU6ICdtY2FsbCcgfSk7XG4gICAgb3B0aW9ucy50b0xvY2FsID0gdHJ1ZTtcbiAgICBvcHRpb25zLnRvTmV0ID0gZmFsc2U7XG4gICAgLy8gcmV0dXJucyBwcm9taXNlIHRoYXQgcmVzb2x2ZSB0byBkYXRhIG9iamVjdFxuICAgIHJldHVybiB0aGlzLkNhbGwobWVzZ05hbWUsIGluRGF0YSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogdmVyc2lvbiBvZiBTZW5kIHRoYXQgZm9yY2UgbG9jYWwtb25seSBjYWxsc1xuICAgKi9cbiAgTG9jYWxQdWJsaXNoKG1lc2dOYW1lLCBpbkRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHsgdHlwZTogJ21zZW5kJyB9KTtcbiAgICBvcHRpb25zLnRvTG9jYWwgPSB0cnVlO1xuICAgIG9wdGlvbnMudG9OZXQgPSBmYWxzZTtcbiAgICB0aGlzLlB1Ymxpc2gobWVzZ05hbWUsIGluRGF0YSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogdmVyc2lvbiBvZiBTZW5kIHRoYXQgZm9yY2UgbG9jYWwtb25seSBjYWxsc1xuICAgKi9cbiAgTG9jYWxTaWduYWwobWVzZ05hbWUsIGluRGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24ob3B0aW9ucywgeyB0eXBlOiAnbXNpZycgfSk7XG4gICAgb3B0aW9ucy50b0xvY2FsID0gdHJ1ZTtcbiAgICBvcHRpb25zLnRvTmV0ID0gZmFsc2U7XG4gICAgdGhpcy5TaWduYWwobWVzZ05hbWUsIGluRGF0YSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogdmVyc2lvbiBvZiBDYWxsIHRoYXQgZm9yY2VzIG5ldHdvcmstb25seSBjYWxsc1xuICAgKi9cbiAgTmV0Q2FsbChtZXNnTmFtZSwgaW5EYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7IHR5cGU6ICdtY2FsbCcgfSk7XG4gICAgb3B0aW9ucy50b0xvY2FsID0gZmFsc2U7XG4gICAgb3B0aW9ucy50b05ldCA9IHRydWU7XG4gICAgLy8gcmV0dXJucyBwcm9taXNlIHRoYXQgcmVzb2x2ZSB0byBkYXRhIG9iamVjdFxuICAgIHJldHVybiB0aGlzLkNhbGwobWVzZ05hbWUsIGluRGF0YSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogdmVyc2lvbiBvZiBTZW5kIHRoYXQgZm9yY2UgbmV0d29yay1vbmx5IGNhbGxzXG4gICAqL1xuICBOZXRQdWJsaXNoKG1lc2dOYW1lLCBpbkRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHsgdHlwZTogJ21zZW5kJyB9KTtcbiAgICBvcHRpb25zLnRvTG9jYWwgPSBmYWxzZTtcbiAgICBvcHRpb25zLnRvTmV0ID0gdHJ1ZTtcbiAgICB0aGlzLlB1Ymxpc2gobWVzZ05hbWUsIGluRGF0YSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogdmVyc2lvbiBvZiBTaWduYWwgdGhhdCBmb3JjZXMgbmV0d29yay1vbmx5IHNpZ25hbFxuICAgKi9cbiAgTmV0U2lnbmFsKG1lc2dOYW1lLCBpbkRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMudG9Mb2NhbCA9IGZhbHNlO1xuICAgIG9wdGlvbnMudG9OZXQgPSB0cnVlO1xuICAgIHRoaXMuU2lnbmFsKG1lc2dOYW1lLCBpbkRhdGEsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgTnVsbENhbGxiYWNrKCkge1xuICAgIGlmIChEQkcuc2VuZCkgY29uc29sZS5sb2coYCR7dGhpcy51aWR9IF8ke1BSfSBgLCAnbnVsbF9jYWxsYmFjaycsIHRoaXMuVUlEKCkpO1xuICB9XG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqXG4gICAqIEluZm9ybSBVUlNZUyBzZXJ2ZXIgdGhhdCB3ZSBoYXZlIHRoZSBmb2xsb3dpbmcgc3Vic2NyaWJlcnMgZm9yIHRoZSBwYXNzZWRcbiAgICogbGlzdCBvZiBtZXNzYWdlcy5cbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbbWVzc2FnZXNdIG9wdGlvbmFsIGxpc3Qgb2YgbWVzc2FnZXMgdG8gcmVnaXN0ZXIuXG4gICAqIElmIG1lc3NhZ2VzIGlzIGVtcHR5LCB0aGVuIGl0J3MgYXNzdW1lZCB0aGF0IHdlIGFyZSByZWdpc3RlcmluZyBhbGwgbWVzc2FnZVxuICAgKiBzdWJzY3JpYmVycy5cbiAgICovXG4gIFJlZ2lzdGVyU3Vic2NyaWJlcnMobWVzc2FnZXMgPSBbXSkge1xuICAgIGlmIChVUk5ldC5Jc1N0YW5kYWxvbmVNb2RlKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihQUiwgJ1NUQU5EQUxPTkUgTU9ERTogUmVnaXN0ZXJNZXNzYWdlc1Byb21pc2UoKSBzdXBwcmVzc2VkIScpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbWVzc2FnZXMgcGFzc2VkLCB0aGVuXG4gICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgbWVzc2FnZXMgPSBNRVNTQUdFUi5WYWxpZGF0ZU1lc3NhZ2VOYW1lcyhtZXNzYWdlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2VzID0gTUVTU0FHRVIuTmV0TWVzc2FnZU5hbWVzKCk7XG4gICAgfVxuICAgIC8vIHJldHVybnMgcHJvbWlzZSB0aGF0IHJlc29sdmUgdG8gZGF0YSBvYmplY3RcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLk5ldENhbGwoJ05FVDpTUlZfUkVHX0hBTkRMRVJTJywgeyBtZXNzYWdlcyB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKlxuICAgKiBQZXJmb3JtIGRhdGEgb3BlcmF0aW9uIHRvIHNlcnZlci4gRG8gbm90IGNhbGwgZGlyZWN0bHksIGJ1dCB1c2VcbiAgICogVVIuREJRdWVyeShjbWQsZGF0YSkuIFRoZSBjbWQgaXMgbG9va3MgdXAgdGhlIGNvcnJlc3BvbmRpbmcgVVJTWVNcbiAgICogbWVzc2FnZSAoZS5nLiBhZGQgLT4gTkVUOlNSVl9EQkFERClcbiAgICogQGV4YW1wbGVcbiAgICogRGF0YU1hcC5EQlF1ZXJ5KCdhZGQnLCB7IHRlYWNoZXJzOiB7IG5hbWU6ICdOZXdUZWFjaGVyJyB9fSk7XG4gICAqL1xuICBfREJRdWVyeShjbWQsIGRhdGEpIHtcbiAgICBjb25zdCBvcG1zZyA9IERhdGFNYXAuR2V0Q29tbWFuZE1lc3NhZ2UoY21kKTtcbiAgICBpZiAoIW9wbXNnKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoYGludmFsaWQgb3BlcmF0aW9uICcke2NtZH0nYCk7XG4gICAgaWYgKGRhdGEuY21kKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJkbyBub3QgaW5jbHVkZSAnY21kJyBwcm9wIGluIGRhdGEgcGFja1wiKTtcbiAgICBpZiAoIWRhdGEua2V5KVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiZGF0YSBtdXN0IGhhdmUgYWNjZXNzIGtleSAna2V5JyBkZWZpbmVkXCIpO1xuICAgIGRhdGEuY21kID0gY21kO1xuICAgIGxldCByZXMgPSBEYXRhTWFwLlZhbGlkYXRlQ29sbGVjdGlvbnMoZGF0YSk7XG4gICAgaWYgKCFyZXMpIHJldHVybiBQcm9taXNlLnJlamVjdChgbm8tb3A6IG5vIHZhbGlkIGNvbGxlY3Rpb25zIGZvdW5kICR7cmVzfWApO1xuICAgIC8vIGdvdCB0aGlzIGZhciwgc28gbGV0J3MgZG8gdGhlIGNhbGwhXG4gICAgLy8gcmV0dXJucyBwcm9taXNlIHRoYXQgcmVzb2x2ZSB0byBkYXRhIG9iamVjdFxuICAgIHJldHVybiB0aGlzLk5ldENhbGwob3Btc2csIGRhdGEpO1xuICB9XG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBDb29wZXJhdGl2ZSBkYXRhYmFzZSBlbGVtZW50IGxvY2sgb24gc2VydmVyXG4gICAqL1xuICBfREJMb2NrKGRhdGEpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgY29uc3QgeyBkYmtleSwgZGJpZHMsIGtleSB9ID0gZGF0YTtcbiAgICBpZiAoIURhdGFNYXAuSXNWYWxpZEtleShkYmtleSkpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYGludmFsaWQgZGJrZXkgJHtkYmtleX1gKTtcbiAgICBpZiAoIURhdGFNYXAuSXNWYWxpZElkc0FycmF5KGRiaWRzKSlcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnZGJpZHMgbXVzdCBiZSBhcnJheSBvZiBpbnRzJyk7XG4gICAgaWYgKCFkYXRhLmtleSlcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcImRhdGEgbXVzdCBoYXZlIGFjY2VzcyBrZXkgJ2tleScgZGVmaW5lZFwiKTtcbiAgICBpZiAoIWRhdGEudWFkZHIpIHJldHVybiBQcm9taXNlLnJlamVjdCgnZGF0YSBtdXN0IGhhdmUgdWFkZHIgZGVmaW5lZCcpO1xuICAgIHJldHVybiB0aGlzLk5ldENhbGwoJ05FVDpTUlZfREJMT0NLJywgZGF0YSk7XG4gIH1cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqIENvb3BlcmF0aXZlIGRhdGFiYXNlIGVsZW1lbnQgcmVsZWFzZSBvbiBzZXJ2ZXJcbiAgICovXG4gIF9EQlJlbGVhc2UoZGF0YSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBjb25zdCB7IGRia2V5LCBkYmlkcywga2V5IH0gPSBkYXRhO1xuICAgIGlmICghRGF0YU1hcC5Jc1ZhbGlkS2V5KGRia2V5KSlcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChgaW52YWxpZCBkYmtleSAke2Ria2V5fWApO1xuICAgIGlmICghRGF0YU1hcC5Jc1ZhbGlkSWRzQXJyYXkoZGJpZHMpKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdkYmlkcyBtdXN0IGJlIGFycmF5IG9mIGludHMnKTtcbiAgICBpZiAoIWRhdGEua2V5KVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiZGF0YSBtdXN0IGhhdmUgYWNjZXNzIGtleSAna2V5JyBkZWZpbmVkXCIpO1xuICAgIGlmICghZGF0YS51YWRkcikgcmV0dXJuIFByb21pc2UucmVqZWN0KCdkYXRhIG11c3QgaGF2ZSB1YWRkciBkZWZpbmVkJyk7XG4gICAgcmV0dXJuIHRoaXMuTmV0Q2FsbCgnTkVUOlNSVl9EQlJFTEVBU0UnLCBkYXRhKTtcbiAgfVxufSAvLyBjbGFzcyBVUkNoYW5cblxuLy8vIEVYUE9SVCBDTEFTUyBERUZJTklUSU9OIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxubW9kdWxlLmV4cG9ydHMgPSBVUkNoYW47XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/client-channel.js\n");

/***/ }),

/***/ "./src/client-exec.js":
/*!****************************!*\
  !*** ./src/client-exec.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable @typescript-eslint/no-use-before-define */\n\n/* eslint-disable consistent-return */\n\n/* eslint-disable no-debugger */\n\n/*///////////////////////////////// ABOUT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\n\n  URSYS Application Lifecycle Controller\n\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ * /////////////////////////////////////*/\n\n/**\n * @module URExec\n */\n/// LIBRARIES /////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nconst URSession = __webpack_require__(/*! ./client-session */ \"./src/client-session.ts\");\n\nconst URPhaseMachine = __webpack_require__(/*! ./class-phase-machine */ \"./src/class-phase-machine.js\");\n\nconst PR = __webpack_require__(/*! ./util/prompts */ \"./src/util/prompts.js\").makeStyleFormatter('UR.EXC'); /// CONSTANTS /////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nconst DBG = false; /// PRIVATE DECLARATIONS //////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst PHASES = {\n  PHASE_BOOT: ['TEST_INIT', // set any testing parameters or modes\n  'SYS_BOOTSTRAP' // grab initial props to load the rest of URSYS\n  ],\n  PHASE_INIT: ['SYS_INIT', // initialize key runtime parameters\n  'DOM_READY', // the dom is stable\n  'TEST_LOCAL' // run local tests that don't require network calls\n  ],\n  PHASE_CONNECT: ['NET_CONNECT', // initiate connection\n  'NET_REGISTER', // initiate registration\n  'NET_READY', // the network is stable\n  'TEST_NET' // run tests that require network readiness\n  ],\n  PHASE_LOAD: ['APP_LOAD' // app modules can request asynchronous loads\n  ],\n  PHASE_CONFIG: ['APP_CONFIGURE' // app modules can configure data structure from loaded data\n  ],\n  PHASE_READY: ['APP_READY' // all apps have loaded and configured and are ready to run\n  ],\n  PHASE_RUN: ['APP_STAGE', // app modules receive reset params prior to starting\n  'APP_START', // app modules start execution, all modules are ready\n  'APP_RUN', // app modules enter run mode\n  'APP_UPDATE', // app modules configuration update\n  'APP_RESET' // app_module will jump back to APP_RUN\n  ],\n  PHASE_PAUSED: ['APP_PAUSE', // app modules should enter \"paused state\"\n  'APP_UPDATE', // app modules configuration update\n  'APP_UNPAUSE' // app modules cleanup, then back to 'APP_LOOP'\n  ],\n  PHASE_UNLOAD: ['APP_STOP', // app is stopping\n  'APP_UNLOAD', // app is shutting down; release assets\n  'APP_SHUTDOWN' // app is shut down\n  ],\n  PHASE_REBOOT: ['SYS_REBOOT' // system is about to reboot back to PHASE_BOOT\n  ]\n}; /// PHASER ////////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nlet PHASE_MACHINE = new URPhaseMachine('UR', PHASES, '');\nconst {\n  ExecutePhase,\n  Execute\n} = PHASE_MACHINE; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** UTILITY: check options passed to SystemBoot, etc\n */\n\nfunction m_CheckOptions(options) {\n  const {\n    autoRun,\n    netProps,\n    ...other\n  } = options;\n  const unknown = Object.keys(other);\n\n  if (unknown.length) {\n    console.log(...PR(`warn - L1_OPTION unknown param: ${unknown.join(', ')}`));\n    throw Error('URSYS: bad option object');\n  } // return true if there were no unknown option properties\n\n\n  return unknown.length === 0;\n} /// RUNTIME API CALLS /////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** API: start the lifecycle state engine\n */\n\n\nasync function SystemBoot(options = {}) {\n  //\n  if (DBG) console.groupCollapsed('** URSYS: Boot');\n  m_CheckOptions(options);\n  URSession.InitializeNetProps(options.netProps); //\n\n  await ExecutePhase('PHASE_BOOT');\n  await ExecutePhase('PHASE_INIT');\n  await ExecutePhase('PHASE_CONNECT');\n  await ExecutePhase('PHASE_LOAD');\n  await ExecutePhase('PHASE_CONFIG');\n  await ExecutePhase('PHASE_READY'); //\n\n  if (options.autoRun) {\n    if (DBG) console.log(...PR('info - autoRun to next phase'));\n    if (DBG) console.groupEnd();\n    SystemRun(options);\n  }\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** API: start the lifecycle run engine. This code is a bit convoluted because\n *  I'm trying to avoid allocating temporary variables that cause the heap\n *  to grow for each timer.\n */\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nasync function SystemRun(options = {}) {\n  // PART 1 - SYSTEM RUN\n  if (DBG) console.groupCollapsed('** URSYS: Run');\n  m_CheckOptions(options); //\n\n  await Execute('APP_STAGE');\n  await Execute('APP_START');\n  await Execute('APP_RUN');\n  if (DBG) console.groupEnd();\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** API: something important application-wide has updated\n */\n\n\nasync function SystemUpdate() {\n  if (DBG) console.groupCollapsed('** URSYS: Restage'); //\n\n  await Execute('APP_UPDATE'); //\n\n  if (DBG) console.groupEnd();\n  SystemRun();\n} /// - - - - - - - - -\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** API: force loop back to run\n */\n\n\nasync function SystemRestage() {\n  if (DBG) console.groupCollapsed('** URSYS: Restage'); //\n\n  await Execute('APP_RESET'); //\n\n  if (DBG) console.groupEnd();\n  SystemRun();\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** API: end the lifecycle state engine\n */\n\n\nasync function SystemUnload() {\n  if (DBG) console.groupCollapsed('** URSYS: Unload'); //\n\n  await ExecutePhase('PHASE_UNLOAD'); //\n\n  if (DBG) console.groupEnd();\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** API: restart the lifecycle from boot\n */\n\n\nasync function SystemReboot() {\n  if (DBG) console.groupCollapsed('** URSYS: Reboot'); //\n\n  await ExecutePhase('PHASE_REBOOT'); //\n\n  if (DBG) console.groupEnd();\n} /// EXPORTS ///////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nmodule.exports = {\n  SystemBoot,\n  SystemRun,\n  SystemUpdate,\n  SystemRestage,\n  SystemUnload,\n  SystemReboot\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50LWV4ZWMuanM/NDc1OCJdLCJuYW1lcyI6WyJVUlNlc3Npb24iLCJyZXF1aXJlIiwiVVJQaGFzZU1hY2hpbmUiLCJQUiIsIm1ha2VTdHlsZUZvcm1hdHRlciIsIkRCRyIsIlBIQVNFUyIsIlBIQVNFX0JPT1QiLCJQSEFTRV9JTklUIiwiUEhBU0VfQ09OTkVDVCIsIlBIQVNFX0xPQUQiLCJQSEFTRV9DT05GSUciLCJQSEFTRV9SRUFEWSIsIlBIQVNFX1JVTiIsIlBIQVNFX1BBVVNFRCIsIlBIQVNFX1VOTE9BRCIsIlBIQVNFX1JFQk9PVCIsIlBIQVNFX01BQ0hJTkUiLCJFeGVjdXRlUGhhc2UiLCJFeGVjdXRlIiwibV9DaGVja09wdGlvbnMiLCJvcHRpb25zIiwiYXV0b1J1biIsIm5ldFByb3BzIiwib3RoZXIiLCJ1bmtub3duIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImNvbnNvbGUiLCJsb2ciLCJqb2luIiwiRXJyb3IiLCJTeXN0ZW1Cb290IiwiZ3JvdXBDb2xsYXBzZWQiLCJJbml0aWFsaXplTmV0UHJvcHMiLCJncm91cEVuZCIsIlN5c3RlbVJ1biIsIlN5c3RlbVVwZGF0ZSIsIlN5c3RlbVJlc3RhZ2UiLCJTeXN0ZW1VbmxvYWQiLCJTeXN0ZW1SZWJvb3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBTUE7OztBQUdBO0FBQ0E7QUFDQSxNQUFNQSxTQUFTLEdBQUdDLG1CQUFPLENBQUMsaURBQUQsQ0FBekI7O0FBQ0EsTUFBTUMsY0FBYyxHQUFHRCxtQkFBTyxDQUFDLDJEQUFELENBQTlCOztBQUNBLE1BQU1FLEVBQUUsR0FBR0YsbUJBQU8sQ0FBQyw2Q0FBRCxDQUFQLENBQTBCRyxrQkFBMUIsQ0FBNkMsUUFBN0MsQ0FBWCxDLENBRUE7QUFDQTs7O0FBQ0EsTUFBTUMsR0FBRyxHQUFHLEtBQVosQyxDQUVBO0FBQ0E7O0FBQ0EsTUFBTUMsTUFBTSxHQUFHO0FBQ2JDLFlBQVUsRUFBRSxDQUNWLFdBRFUsRUFDRztBQUNiLGlCQUZVLENBRU07QUFGTixHQURDO0FBS2JDLFlBQVUsRUFBRSxDQUNWLFVBRFUsRUFDRTtBQUNaLGFBRlUsRUFFRztBQUNiLGNBSFUsQ0FHRztBQUhILEdBTEM7QUFVYkMsZUFBYSxFQUFFLENBQ2IsYUFEYSxFQUNFO0FBQ2YsZ0JBRmEsRUFFRztBQUNoQixhQUhhLEVBR0E7QUFDYixZQUphLENBSUY7QUFKRSxHQVZGO0FBZ0JiQyxZQUFVLEVBQUUsQ0FDVixVQURVLENBQ0M7QUFERCxHQWhCQztBQW1CYkMsY0FBWSxFQUFFLENBQ1osZUFEWSxDQUNJO0FBREosR0FuQkQ7QUFzQmJDLGFBQVcsRUFBRSxDQUNYLFdBRFcsQ0FDQztBQURELEdBdEJBO0FBeUJiQyxXQUFTLEVBQUUsQ0FDVCxXQURTLEVBQ0k7QUFDYixhQUZTLEVBRUk7QUFDYixXQUhTLEVBR0U7QUFDWCxjQUpTLEVBSUs7QUFDZCxhQUxTLENBS0c7QUFMSCxHQXpCRTtBQWdDYkMsY0FBWSxFQUFFLENBQ1osV0FEWSxFQUNDO0FBQ2IsY0FGWSxFQUVFO0FBQ2QsZUFIWSxDQUdFO0FBSEYsR0FoQ0Q7QUFxQ2JDLGNBQVksRUFBRSxDQUNaLFVBRFksRUFDQTtBQUNaLGNBRlksRUFFRTtBQUNkLGdCQUhZLENBR0c7QUFISCxHQXJDRDtBQTBDYkMsY0FBWSxFQUFFLENBQ1osWUFEWSxDQUNDO0FBREQ7QUExQ0QsQ0FBZixDLENBK0NBO0FBQ0E7O0FBQ0EsSUFBSUMsYUFBYSxHQUFHLElBQUlmLGNBQUosQ0FBbUIsSUFBbkIsRUFBeUJJLE1BQXpCLEVBQWlDLEVBQWpDLENBQXBCO0FBQ0EsTUFBTTtBQUFFWSxjQUFGO0FBQWdCQztBQUFoQixJQUE0QkYsYUFBbEMsQyxDQUVBOztBQUNBOzs7QUFFQSxTQUFTRyxjQUFULENBQXdCQyxPQUF4QixFQUFpQztBQUMvQixRQUFNO0FBQUVDLFdBQUY7QUFBV0MsWUFBWDtBQUFxQixPQUFHQztBQUF4QixNQUFrQ0gsT0FBeEM7QUFDQSxRQUFNSSxPQUFPLEdBQUdDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZSCxLQUFaLENBQWhCOztBQUNBLE1BQUlDLE9BQU8sQ0FBQ0csTUFBWixFQUFvQjtBQUNsQkMsV0FBTyxDQUFDQyxHQUFSLENBQVksR0FBRzNCLEVBQUUsQ0FBRSxtQ0FBa0NzQixPQUFPLENBQUNNLElBQVIsQ0FBYSxJQUFiLENBQW1CLEVBQXZELENBQWpCO0FBQ0EsVUFBTUMsS0FBSyxDQUFDLDBCQUFELENBQVg7QUFDRCxHQU44QixDQU8vQjs7O0FBQ0EsU0FBT1AsT0FBTyxDQUFDRyxNQUFSLEtBQW1CLENBQTFCO0FBQ0QsQyxDQUVEO0FBQ0E7O0FBQ0E7Ozs7QUFFQSxlQUFlSyxVQUFmLENBQTBCWixPQUFPLEdBQUcsRUFBcEMsRUFBd0M7QUFDdEM7QUFDQSxNQUFJaEIsR0FBSixFQUFTd0IsT0FBTyxDQUFDSyxjQUFSLENBQXVCLGdCQUF2QjtBQUNUZCxnQkFBYyxDQUFDQyxPQUFELENBQWQ7QUFDQXJCLFdBQVMsQ0FBQ21DLGtCQUFWLENBQTZCZCxPQUFPLENBQUNFLFFBQXJDLEVBSnNDLENBS3RDOztBQUNBLFFBQU1MLFlBQVksQ0FBQyxZQUFELENBQWxCO0FBQ0EsUUFBTUEsWUFBWSxDQUFDLFlBQUQsQ0FBbEI7QUFDQSxRQUFNQSxZQUFZLENBQUMsZUFBRCxDQUFsQjtBQUNBLFFBQU1BLFlBQVksQ0FBQyxZQUFELENBQWxCO0FBQ0EsUUFBTUEsWUFBWSxDQUFDLGNBQUQsQ0FBbEI7QUFDQSxRQUFNQSxZQUFZLENBQUMsYUFBRCxDQUFsQixDQVhzQyxDQVl0Qzs7QUFDQSxNQUFJRyxPQUFPLENBQUNDLE9BQVosRUFBcUI7QUFDbkIsUUFBSWpCLEdBQUosRUFBU3dCLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLEdBQUczQixFQUFFLENBQUMsOEJBQUQsQ0FBakI7QUFDVCxRQUFJRSxHQUFKLEVBQVN3QixPQUFPLENBQUNPLFFBQVI7QUFDVEMsYUFBUyxDQUFDaEIsT0FBRCxDQUFUO0FBQ0Q7QUFDRixDLENBQ0Q7O0FBQ0E7Ozs7QUFJQTs7O0FBQ0EsZUFBZWdCLFNBQWYsQ0FBeUJoQixPQUFPLEdBQUcsRUFBbkMsRUFBdUM7QUFDckM7QUFDQSxNQUFJaEIsR0FBSixFQUFTd0IsT0FBTyxDQUFDSyxjQUFSLENBQXVCLGVBQXZCO0FBQ1RkLGdCQUFjLENBQUNDLE9BQUQsQ0FBZCxDQUhxQyxDQUlyQzs7QUFDQSxRQUFNRixPQUFPLENBQUMsV0FBRCxDQUFiO0FBQ0EsUUFBTUEsT0FBTyxDQUFDLFdBQUQsQ0FBYjtBQUNBLFFBQU1BLE9BQU8sQ0FBQyxTQUFELENBQWI7QUFFQSxNQUFJZCxHQUFKLEVBQVN3QixPQUFPLENBQUNPLFFBQVI7QUFDVixDLENBQ0Q7O0FBQ0E7Ozs7QUFFQSxlQUFlRSxZQUFmLEdBQThCO0FBQzVCLE1BQUlqQyxHQUFKLEVBQVN3QixPQUFPLENBQUNLLGNBQVIsQ0FBdUIsbUJBQXZCLEVBRG1CLENBRTVCOztBQUNBLFFBQU1mLE9BQU8sQ0FBQyxZQUFELENBQWIsQ0FINEIsQ0FJNUI7O0FBQ0EsTUFBSWQsR0FBSixFQUFTd0IsT0FBTyxDQUFDTyxRQUFSO0FBQ1RDLFdBQVM7QUFDVixDLENBQ0Q7QUFDQTs7QUFDQTs7OztBQUVBLGVBQWVFLGFBQWYsR0FBK0I7QUFDN0IsTUFBSWxDLEdBQUosRUFBU3dCLE9BQU8sQ0FBQ0ssY0FBUixDQUF1QixtQkFBdkIsRUFEb0IsQ0FFN0I7O0FBQ0EsUUFBTWYsT0FBTyxDQUFDLFdBQUQsQ0FBYixDQUg2QixDQUk3Qjs7QUFDQSxNQUFJZCxHQUFKLEVBQVN3QixPQUFPLENBQUNPLFFBQVI7QUFDVEMsV0FBUztBQUNWLEMsQ0FDRDs7QUFDQTs7OztBQUVBLGVBQWVHLFlBQWYsR0FBOEI7QUFDNUIsTUFBSW5DLEdBQUosRUFBU3dCLE9BQU8sQ0FBQ0ssY0FBUixDQUF1QixrQkFBdkIsRUFEbUIsQ0FFNUI7O0FBQ0EsUUFBTWhCLFlBQVksQ0FBQyxjQUFELENBQWxCLENBSDRCLENBSTVCOztBQUNBLE1BQUliLEdBQUosRUFBU3dCLE9BQU8sQ0FBQ08sUUFBUjtBQUNWLEMsQ0FDRDs7QUFDQTs7OztBQUVBLGVBQWVLLFlBQWYsR0FBOEI7QUFDNUIsTUFBSXBDLEdBQUosRUFBU3dCLE9BQU8sQ0FBQ0ssY0FBUixDQUF1QixrQkFBdkIsRUFEbUIsQ0FFNUI7O0FBQ0EsUUFBTWhCLFlBQVksQ0FBQyxjQUFELENBQWxCLENBSDRCLENBSTVCOztBQUNBLE1BQUliLEdBQUosRUFBU3dCLE9BQU8sQ0FBQ08sUUFBUjtBQUNWLEMsQ0FFRDtBQUNBOzs7QUFDQU0sTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBQ2ZWLFlBRGU7QUFFZkksV0FGZTtBQUdmQyxjQUhlO0FBSWZDLGVBSmU7QUFLZkMsY0FMZTtBQU1mQztBQU5lLENBQWpCIiwiZmlsZSI6Ii4vc3JjL2NsaWVudC1leGVjLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG4vKiBlc2xpbnQtZGlzYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cbi8qLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIEFCT1VUIFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwqXFxcblxuICBVUlNZUyBBcHBsaWNhdGlvbiBMaWZlY3ljbGUgQ29udHJvbGxlclxuXG5cXCpcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcICogLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyovXG5cbi8qKlxuICogQG1vZHVsZSBVUkV4ZWNcbiAqL1xuLy8vIExJQlJBUklFUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuY29uc3QgVVJTZXNzaW9uID0gcmVxdWlyZSgnLi9jbGllbnQtc2Vzc2lvbicpO1xuY29uc3QgVVJQaGFzZU1hY2hpbmUgPSByZXF1aXJlKCcuL2NsYXNzLXBoYXNlLW1hY2hpbmUnKTtcbmNvbnN0IFBSID0gcmVxdWlyZSgnLi91dGlsL3Byb21wdHMnKS5tYWtlU3R5bGVGb3JtYXR0ZXIoJ1VSLkVYQycpO1xuXG4vLy8gQ09OU1RBTlRTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5jb25zdCBEQkcgPSBmYWxzZTtcblxuLy8vIFBSSVZBVEUgREVDTEFSQVRJT05TIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuY29uc3QgUEhBU0VTID0ge1xuICBQSEFTRV9CT09UOiBbXG4gICAgJ1RFU1RfSU5JVCcsIC8vIHNldCBhbnkgdGVzdGluZyBwYXJhbWV0ZXJzIG9yIG1vZGVzXG4gICAgJ1NZU19CT09UU1RSQVAnIC8vIGdyYWIgaW5pdGlhbCBwcm9wcyB0byBsb2FkIHRoZSByZXN0IG9mIFVSU1lTXG4gIF0sXG4gIFBIQVNFX0lOSVQ6IFtcbiAgICAnU1lTX0lOSVQnLCAvLyBpbml0aWFsaXplIGtleSBydW50aW1lIHBhcmFtZXRlcnNcbiAgICAnRE9NX1JFQURZJywgLy8gdGhlIGRvbSBpcyBzdGFibGVcbiAgICAnVEVTVF9MT0NBTCcgLy8gcnVuIGxvY2FsIHRlc3RzIHRoYXQgZG9uJ3QgcmVxdWlyZSBuZXR3b3JrIGNhbGxzXG4gIF0sXG4gIFBIQVNFX0NPTk5FQ1Q6IFtcbiAgICAnTkVUX0NPTk5FQ1QnLCAvLyBpbml0aWF0ZSBjb25uZWN0aW9uXG4gICAgJ05FVF9SRUdJU1RFUicsIC8vIGluaXRpYXRlIHJlZ2lzdHJhdGlvblxuICAgICdORVRfUkVBRFknLCAvLyB0aGUgbmV0d29yayBpcyBzdGFibGVcbiAgICAnVEVTVF9ORVQnIC8vIHJ1biB0ZXN0cyB0aGF0IHJlcXVpcmUgbmV0d29yayByZWFkaW5lc3NcbiAgXSxcbiAgUEhBU0VfTE9BRDogW1xuICAgICdBUFBfTE9BRCcgLy8gYXBwIG1vZHVsZXMgY2FuIHJlcXVlc3QgYXN5bmNocm9ub3VzIGxvYWRzXG4gIF0sXG4gIFBIQVNFX0NPTkZJRzogW1xuICAgICdBUFBfQ09ORklHVVJFJyAvLyBhcHAgbW9kdWxlcyBjYW4gY29uZmlndXJlIGRhdGEgc3RydWN0dXJlIGZyb20gbG9hZGVkIGRhdGFcbiAgXSxcbiAgUEhBU0VfUkVBRFk6IFtcbiAgICAnQVBQX1JFQURZJyAvLyBhbGwgYXBwcyBoYXZlIGxvYWRlZCBhbmQgY29uZmlndXJlZCBhbmQgYXJlIHJlYWR5IHRvIHJ1blxuICBdLFxuICBQSEFTRV9SVU46IFtcbiAgICAnQVBQX1NUQUdFJywgLy8gYXBwIG1vZHVsZXMgcmVjZWl2ZSByZXNldCBwYXJhbXMgcHJpb3IgdG8gc3RhcnRpbmdcbiAgICAnQVBQX1NUQVJUJywgLy8gYXBwIG1vZHVsZXMgc3RhcnQgZXhlY3V0aW9uLCBhbGwgbW9kdWxlcyBhcmUgcmVhZHlcbiAgICAnQVBQX1JVTicsIC8vIGFwcCBtb2R1bGVzIGVudGVyIHJ1biBtb2RlXG4gICAgJ0FQUF9VUERBVEUnLCAvLyBhcHAgbW9kdWxlcyBjb25maWd1cmF0aW9uIHVwZGF0ZVxuICAgICdBUFBfUkVTRVQnIC8vIGFwcF9tb2R1bGUgd2lsbCBqdW1wIGJhY2sgdG8gQVBQX1JVTlxuICBdLFxuICBQSEFTRV9QQVVTRUQ6IFtcbiAgICAnQVBQX1BBVVNFJywgLy8gYXBwIG1vZHVsZXMgc2hvdWxkIGVudGVyIFwicGF1c2VkIHN0YXRlXCJcbiAgICAnQVBQX1VQREFURScsIC8vIGFwcCBtb2R1bGVzIGNvbmZpZ3VyYXRpb24gdXBkYXRlXG4gICAgJ0FQUF9VTlBBVVNFJyAvLyBhcHAgbW9kdWxlcyBjbGVhbnVwLCB0aGVuIGJhY2sgdG8gJ0FQUF9MT09QJ1xuICBdLFxuICBQSEFTRV9VTkxPQUQ6IFtcbiAgICAnQVBQX1NUT1AnLCAvLyBhcHAgaXMgc3RvcHBpbmdcbiAgICAnQVBQX1VOTE9BRCcsIC8vIGFwcCBpcyBzaHV0dGluZyBkb3duOyByZWxlYXNlIGFzc2V0c1xuICAgICdBUFBfU0hVVERPV04nIC8vIGFwcCBpcyBzaHV0IGRvd25cbiAgXSxcbiAgUEhBU0VfUkVCT09UOiBbXG4gICAgJ1NZU19SRUJPT1QnIC8vIHN5c3RlbSBpcyBhYm91dCB0byByZWJvb3QgYmFjayB0byBQSEFTRV9CT09UXG4gIF1cbn07XG5cbi8vLyBQSEFTRVIgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbmxldCBQSEFTRV9NQUNISU5FID0gbmV3IFVSUGhhc2VNYWNoaW5lKCdVUicsIFBIQVNFUywgJycpO1xuY29uc3QgeyBFeGVjdXRlUGhhc2UsIEV4ZWN1dGUgfSA9IFBIQVNFX01BQ0hJTkU7XG5cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBVVElMSVRZOiBjaGVjayBvcHRpb25zIHBhc3NlZCB0byBTeXN0ZW1Cb290LCBldGNcbiAqL1xuZnVuY3Rpb24gbV9DaGVja09wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCB7IGF1dG9SdW4sIG5ldFByb3BzLCAuLi5vdGhlciB9ID0gb3B0aW9ucztcbiAgY29uc3QgdW5rbm93biA9IE9iamVjdC5rZXlzKG90aGVyKTtcbiAgaWYgKHVua25vd24ubGVuZ3RoKSB7XG4gICAgY29uc29sZS5sb2coLi4uUFIoYHdhcm4gLSBMMV9PUFRJT04gdW5rbm93biBwYXJhbTogJHt1bmtub3duLmpvaW4oJywgJyl9YCkpO1xuICAgIHRocm93IEVycm9yKCdVUlNZUzogYmFkIG9wdGlvbiBvYmplY3QnKTtcbiAgfVxuICAvLyByZXR1cm4gdHJ1ZSBpZiB0aGVyZSB3ZXJlIG5vIHVua25vd24gb3B0aW9uIHByb3BlcnRpZXNcbiAgcmV0dXJuIHVua25vd24ubGVuZ3RoID09PSAwO1xufVxuXG4vLy8gUlVOVElNRSBBUEkgQ0FMTFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogQVBJOiBzdGFydCB0aGUgbGlmZWN5Y2xlIHN0YXRlIGVuZ2luZVxuICovXG5hc3luYyBmdW5jdGlvbiBTeXN0ZW1Cb290KG9wdGlvbnMgPSB7fSkge1xuICAvL1xuICBpZiAoREJHKSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKCcqKiBVUlNZUzogQm9vdCcpO1xuICBtX0NoZWNrT3B0aW9ucyhvcHRpb25zKTtcbiAgVVJTZXNzaW9uLkluaXRpYWxpemVOZXRQcm9wcyhvcHRpb25zLm5ldFByb3BzKTtcbiAgLy9cbiAgYXdhaXQgRXhlY3V0ZVBoYXNlKCdQSEFTRV9CT09UJyk7XG4gIGF3YWl0IEV4ZWN1dGVQaGFzZSgnUEhBU0VfSU5JVCcpO1xuICBhd2FpdCBFeGVjdXRlUGhhc2UoJ1BIQVNFX0NPTk5FQ1QnKTtcbiAgYXdhaXQgRXhlY3V0ZVBoYXNlKCdQSEFTRV9MT0FEJyk7XG4gIGF3YWl0IEV4ZWN1dGVQaGFzZSgnUEhBU0VfQ09ORklHJyk7XG4gIGF3YWl0IEV4ZWN1dGVQaGFzZSgnUEhBU0VfUkVBRFknKTtcbiAgLy9cbiAgaWYgKG9wdGlvbnMuYXV0b1J1bikge1xuICAgIGlmIChEQkcpIGNvbnNvbGUubG9nKC4uLlBSKCdpbmZvIC0gYXV0b1J1biB0byBuZXh0IHBoYXNlJykpO1xuICAgIGlmIChEQkcpIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICBTeXN0ZW1SdW4ob3B0aW9ucyk7XG4gIH1cbn1cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBBUEk6IHN0YXJ0IHRoZSBsaWZlY3ljbGUgcnVuIGVuZ2luZS4gVGhpcyBjb2RlIGlzIGEgYml0IGNvbnZvbHV0ZWQgYmVjYXVzZVxuICogIEknbSB0cnlpbmcgdG8gYXZvaWQgYWxsb2NhdGluZyB0ZW1wb3JhcnkgdmFyaWFibGVzIHRoYXQgY2F1c2UgdGhlIGhlYXBcbiAqICB0byBncm93IGZvciBlYWNoIHRpbWVyLlxuICovXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5hc3luYyBmdW5jdGlvbiBTeXN0ZW1SdW4ob3B0aW9ucyA9IHt9KSB7XG4gIC8vIFBBUlQgMSAtIFNZU1RFTSBSVU5cbiAgaWYgKERCRykgY29uc29sZS5ncm91cENvbGxhcHNlZCgnKiogVVJTWVM6IFJ1bicpO1xuICBtX0NoZWNrT3B0aW9ucyhvcHRpb25zKTtcbiAgLy9cbiAgYXdhaXQgRXhlY3V0ZSgnQVBQX1NUQUdFJyk7XG4gIGF3YWl0IEV4ZWN1dGUoJ0FQUF9TVEFSVCcpO1xuICBhd2FpdCBFeGVjdXRlKCdBUFBfUlVOJyk7XG5cbiAgaWYgKERCRykgY29uc29sZS5ncm91cEVuZCgpO1xufVxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIEFQSTogc29tZXRoaW5nIGltcG9ydGFudCBhcHBsaWNhdGlvbi13aWRlIGhhcyB1cGRhdGVkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIFN5c3RlbVVwZGF0ZSgpIHtcbiAgaWYgKERCRykgY29uc29sZS5ncm91cENvbGxhcHNlZCgnKiogVVJTWVM6IFJlc3RhZ2UnKTtcbiAgLy9cbiAgYXdhaXQgRXhlY3V0ZSgnQVBQX1VQREFURScpO1xuICAvL1xuICBpZiAoREJHKSBjb25zb2xlLmdyb3VwRW5kKCk7XG4gIFN5c3RlbVJ1bigpO1xufVxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogQVBJOiBmb3JjZSBsb29wIGJhY2sgdG8gcnVuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIFN5c3RlbVJlc3RhZ2UoKSB7XG4gIGlmIChEQkcpIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoJyoqIFVSU1lTOiBSZXN0YWdlJyk7XG4gIC8vXG4gIGF3YWl0IEV4ZWN1dGUoJ0FQUF9SRVNFVCcpO1xuICAvL1xuICBpZiAoREJHKSBjb25zb2xlLmdyb3VwRW5kKCk7XG4gIFN5c3RlbVJ1bigpO1xufVxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIEFQSTogZW5kIHRoZSBsaWZlY3ljbGUgc3RhdGUgZW5naW5lXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIFN5c3RlbVVubG9hZCgpIHtcbiAgaWYgKERCRykgY29uc29sZS5ncm91cENvbGxhcHNlZCgnKiogVVJTWVM6IFVubG9hZCcpO1xuICAvL1xuICBhd2FpdCBFeGVjdXRlUGhhc2UoJ1BIQVNFX1VOTE9BRCcpO1xuICAvL1xuICBpZiAoREJHKSBjb25zb2xlLmdyb3VwRW5kKCk7XG59XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogQVBJOiByZXN0YXJ0IHRoZSBsaWZlY3ljbGUgZnJvbSBib290XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIFN5c3RlbVJlYm9vdCgpIHtcbiAgaWYgKERCRykgY29uc29sZS5ncm91cENvbGxhcHNlZCgnKiogVVJTWVM6IFJlYm9vdCcpO1xuICAvL1xuICBhd2FpdCBFeGVjdXRlUGhhc2UoJ1BIQVNFX1JFQk9PVCcpO1xuICAvL1xuICBpZiAoREJHKSBjb25zb2xlLmdyb3VwRW5kKCk7XG59XG5cbi8vLyBFWFBPUlRTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBTeXN0ZW1Cb290LFxuICBTeXN0ZW1SdW4sXG4gIFN5c3RlbVVwZGF0ZSxcbiAgU3lzdGVtUmVzdGFnZSxcbiAgU3lzdGVtVW5sb2FkLFxuICBTeXN0ZW1SZWJvb3Rcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/client-exec.js\n");

/***/ }),

/***/ "./src/client-network.js":
/*!*******************************!*\
  !*** ./src/client-network.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable @typescript-eslint/no-use-before-define */\n\n/* eslint-disable no-param-reassign */\n\n/*//////////////////////////////// ABOUT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\n\n    URSYS NETWORK implements network controls and synchronization.\n    It initializes a network connection on the CONNECT lifecycle.\n\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ * //////////////////////////////////////*/\nconst NetPacket = __webpack_require__(/*! ./class-netpacket */ \"./src/class-netpacket.js\");\n\nconst URSession = __webpack_require__(/*! ./client-session */ \"./src/client-session.ts\");\n\nconst PR = __webpack_require__(/*! ./util/prompts */ \"./src/util/prompts.js\").makeStyleFormatter('UR.NET'); /// DECLARATIONS /////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nconst DBG = {\n  connect: false,\n  hello: true,\n  handle: false,\n  reg: false\n}; ///\n\nconst ERR_NO_SOCKET = 'Network socket has not been established yet';\nconst ERR_BAD_URCHAN = \"An instance of 'URChan' is required\"; /// NETWORK ID VALUES /////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst M0_INIT = 0;\nconst M1_CONNECTING = 1;\nconst M2_CONNECTED = 2;\nconst M3_REGISTERED = 3;\nconst M4_READY = 4;\nconst M_STANDALONE = 5; /// DECLARATIONS //////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nlet m_socket; // contain socket information on registration message\n\nlet m_urlink; // assigned during NETWORK.Connect()\n\nlet m_options;\nlet m_status = M0_INIT; /// NETWORK LISTENERS /////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nfunction m_AddListener(event, handlerFunction) {\n  if (m_socket instanceof WebSocket) {\n    m_socket.addEventListener(event, handlerFunction);\n  } else {\n    throw Error(ERR_NO_SOCKET);\n  }\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nfunction m_RemoveListener(event, handlerFunction) {\n  if (m_socket instanceof WebSocket) {\n    m_socket.removeEventListener(event, handlerFunction);\n  } else {\n    throw Error(ERR_NO_SOCKET);\n  }\n} /// API HELPERS ///////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** After 'open' event, we expect the first message on the socket to contain\n *  network session-related messages\n */\n\n\nfunction m_HandleRegistrationMessage(msgEvent) {\n  let regData = JSON.parse(msgEvent.data);\n  let {\n    HELLO,\n    UADDR,\n    SERVER_UADDR,\n    PEERS,\n    ULOCAL\n  } = regData; // (1) after receiving the initial message, switch over to regular\n  // message handler\n\n  m_RemoveListener('message', m_HandleRegistrationMessage);\n  m_status = M3_REGISTERED; // (2) initialize global settings for netmessage\n\n  if (DBG.connect || DBG.hello) console.log(...PR(`'${HELLO}'`));\n  m_socket.UADDR = NetPacket.DefaultServerUADDR();\n  NetPacket.GlobalSetup({\n    uaddr: UADDR,\n    netsocket: m_socket,\n    server_uaddr: SERVER_UADDR,\n    peers: PEERS,\n    is_local: ULOCAL\n  }); // (3) connect regular message handler\n\n  m_AddListener('message', m_HandleMessage);\n  m_status = M4_READY; // (4) network is initialized\n\n  if (typeof m_options.success === 'function') m_options.success(); // (5) also update window.URSESSION with UADDR\n\n  if (window.URSESSION) {\n    if (DBG.reg) console.log('updating URSESSION with registration data');\n    window.URSESSION.CLIENT_UADDR = UADDR;\n    window.URSESSION.USRV_UADDR = SERVER_UADDR;\n  }\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Dispatch incoming event object from the network.\n *  @param {SocketEvent} msgEvent -incoming event object from websocket\n */\n\n\nfunction m_HandleMessage(msgEvent) {\n  let pkt = new NetPacket(msgEvent.data);\n  let msg = pkt.Message(); // (1) If this packet is a response packet, then it must be one of\n  // our OWN previously-sent messages that we expected a return value.\n  // Call CompleteTransaction() to invoke the function handler\n\n  if (pkt.IsResponse()) {\n    if (DBG.handle) console.log(...PR(`completing transaction ${msg}`));\n    pkt.CompleteTransaction();\n    return;\n  } // (2) Otherwise, the incoming network message has been routed to\n  // us to handle.\n\n\n  let data = pkt.Data();\n  let type = pkt.Type();\n  let dbgout = DBG.handle && !msg.startsWith('NET:SRV_'); // (3) handle each packet type as necessary\n\n  switch (type) {\n    case 'state':\n      // unimplemented netstate\n      if (dbgout) console.log(...PR(`received state change ${msg}`));\n      break;\n\n    case 'msig':\n      // network signal to raise\n      if (dbgout) cout_ReceivedStatus(pkt);\n      m_urlink.LocalSignal(msg, data, {\n        fromNet: true\n      });\n      pkt.ReturnTransaction();\n      break;\n\n    case 'msend':\n      // network message received\n      if (dbgout) cout_ReceivedStatus(pkt);\n      m_urlink.LocalPublish(msg, data, {\n        fromNet: true\n      });\n      pkt.ReturnTransaction();\n      break;\n\n    case 'mcall':\n      // network call received\n      if (dbgout) cout_ReceivedStatus(pkt);\n      m_urlink.LocalCall(msg, data, {\n        fromNet: true\n      }).then(result => {\n        if (dbgout) cout_ForwardedStatus(pkt, result); // now return the packet\n\n        pkt.SetData(result);\n        pkt.ReturnTransaction();\n      });\n      break;\n\n    default:\n      throw Error('unknown packet type', type);\n  } // DEBUG OUT UTILITY\n\n\n  function cout_ReceivedStatus(pkt) {\n    console.warn(...PR(`ME_${NetPacket.SocketUADDR()} received '${pkt.Type()}' '${pkt.Message()}' from ${pkt.SourceAddress()}`), pkt.Data());\n  } // DEBUG OUT UTILITY\n\n\n  function cout_ForwardedStatus(pkt, result) {\n    console.log(...PR(`ME_${NetPacket.SocketUADDR()} forwarded '${pkt.Message()}', returning ${JSON.stringify(result)}`));\n  }\n} /// API ///////////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nconst NETWORK = {}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Establish connection to URSYS server. This is called by client.js during\n *  NetworkInitialize(), which itself fires after the application has rendered\n *  completely.\n *  @param datalink - an urchannel endpoint\n *  @param opt - { success, failure } functions\n */\n\nNETWORK.Connect = (datalink, opt) => {\n  return new Promise(resolve => {\n    if (m_status > 0) {\n      let err = 'called twice...other views may be calling URSYS outside of lifecycle';\n      console.error(...PR(err));\n      return;\n    }\n\n    m_status = M1_CONNECTING; // check and save parms\n\n    if (datalink.constructor.name !== 'URChan') {\n      throw Error(ERR_BAD_URCHAN);\n    }\n\n    if (!m_urlink) m_urlink = datalink;\n    m_options = opt || {}; // create websocket\n    // uses values that are set by UR-EXEC SystemBoot()\n\n    const {\n      host: USRV_Host,\n      port: USRV_MsgPort\n    } = URSession.GetNetBroker();\n    let wsURI = `ws://${USRV_Host}:${USRV_MsgPort}`;\n    m_socket = new WebSocket(wsURI);\n    if (DBG.connect) console.log(...PR(`OPEN SOCKET TO ${wsURI}`)); // create listeners\n\n    m_AddListener('open', event => {\n      if (DBG.connect) console.log(...PR(`...OPEN ${event.target.url}`));\n      m_status = M2_CONNECTED; // message handling continues in 'message' handler\n      // the first message is assumed to be registration data\n\n      if (DBG.connect) console.log(...PR('CONNECTED'));\n      resolve();\n    });\n    m_AddListener('close', event => {\n      if (DBG.connect) console.log(...PR(`..CLOSE ${event.target.url}`));\n      NetPacket.GlobalOfflineMode();\n      m_status = M_STANDALONE;\n    }); // handle incoming messages\n\n    m_AddListener('message', m_HandleRegistrationMessage);\n  });\n}; // Connect()\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Force close of connection, for example if URSYS.AppReady() fails\n */\n\n\nNETWORK.Close = (code, reason) => {\n  code = code || 1000;\n  reason = reason || 'URSYS forced close';\n  m_socket.close(code, reason);\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Return the current uaddr of this client, which is stored in NetPacket\n *  when the client initializes.\n */\n\n\nNETWORK.SocketUADDR = () => {\n  return NetPacket.SocketUADDR();\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Return TRUE if client is in \"standalone\" mode. This was a NetCreate\n *  that was used to disable network communication for HTML-only snapshots.\n */\n\n\nNETWORK.IsStandaloneMode = () => {\n  return m_status === M_STANDALONE;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Return TRUE if client is running with the localhost as server.\n *  This can be used as quick way to enable admin-only features.\n */\n\n\nNETWORK.IsLocalhost = () => NetPacket.IsLocalhost(); /// EXPORT MODULE DEFINITION //////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nmodule.exports = NETWORK;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50LW5ldHdvcmsuanM/YmJjYSJdLCJuYW1lcyI6WyJOZXRQYWNrZXQiLCJyZXF1aXJlIiwiVVJTZXNzaW9uIiwiUFIiLCJtYWtlU3R5bGVGb3JtYXR0ZXIiLCJEQkciLCJjb25uZWN0IiwiaGVsbG8iLCJoYW5kbGUiLCJyZWciLCJFUlJfTk9fU09DS0VUIiwiRVJSX0JBRF9VUkNIQU4iLCJNMF9JTklUIiwiTTFfQ09OTkVDVElORyIsIk0yX0NPTk5FQ1RFRCIsIk0zX1JFR0lTVEVSRUQiLCJNNF9SRUFEWSIsIk1fU1RBTkRBTE9ORSIsIm1fc29ja2V0IiwibV91cmxpbmsiLCJtX29wdGlvbnMiLCJtX3N0YXR1cyIsIm1fQWRkTGlzdGVuZXIiLCJldmVudCIsImhhbmRsZXJGdW5jdGlvbiIsIldlYlNvY2tldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJFcnJvciIsIm1fUmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibV9IYW5kbGVSZWdpc3RyYXRpb25NZXNzYWdlIiwibXNnRXZlbnQiLCJyZWdEYXRhIiwiSlNPTiIsInBhcnNlIiwiZGF0YSIsIkhFTExPIiwiVUFERFIiLCJTRVJWRVJfVUFERFIiLCJQRUVSUyIsIlVMT0NBTCIsImNvbnNvbGUiLCJsb2ciLCJEZWZhdWx0U2VydmVyVUFERFIiLCJHbG9iYWxTZXR1cCIsInVhZGRyIiwibmV0c29ja2V0Iiwic2VydmVyX3VhZGRyIiwicGVlcnMiLCJpc19sb2NhbCIsIm1fSGFuZGxlTWVzc2FnZSIsInN1Y2Nlc3MiLCJ3aW5kb3ciLCJVUlNFU1NJT04iLCJDTElFTlRfVUFERFIiLCJVU1JWX1VBRERSIiwicGt0IiwibXNnIiwiTWVzc2FnZSIsIklzUmVzcG9uc2UiLCJDb21wbGV0ZVRyYW5zYWN0aW9uIiwiRGF0YSIsInR5cGUiLCJUeXBlIiwiZGJnb3V0Iiwic3RhcnRzV2l0aCIsImNvdXRfUmVjZWl2ZWRTdGF0dXMiLCJMb2NhbFNpZ25hbCIsImZyb21OZXQiLCJSZXR1cm5UcmFuc2FjdGlvbiIsIkxvY2FsUHVibGlzaCIsIkxvY2FsQ2FsbCIsInRoZW4iLCJyZXN1bHQiLCJjb3V0X0ZvcndhcmRlZFN0YXR1cyIsIlNldERhdGEiLCJ3YXJuIiwiU29ja2V0VUFERFIiLCJTb3VyY2VBZGRyZXNzIiwic3RyaW5naWZ5IiwiTkVUV09SSyIsIkNvbm5lY3QiLCJkYXRhbGluayIsIm9wdCIsIlByb21pc2UiLCJyZXNvbHZlIiwiZXJyIiwiZXJyb3IiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJob3N0IiwiVVNSVl9Ib3N0IiwicG9ydCIsIlVTUlZfTXNnUG9ydCIsIkdldE5ldEJyb2tlciIsIndzVVJJIiwidGFyZ2V0IiwidXJsIiwiR2xvYmFsT2ZmbGluZU1vZGUiLCJDbG9zZSIsImNvZGUiLCJyZWFzb24iLCJjbG9zZSIsIklzU3RhbmRhbG9uZU1vZGUiLCJJc0xvY2FsaG9zdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBOztBQUNBOzs7Ozs7QUFNQSxNQUFNQSxTQUFTLEdBQUdDLG1CQUFPLENBQUMsbURBQUQsQ0FBekI7O0FBQ0EsTUFBTUMsU0FBUyxHQUFHRCxtQkFBTyxDQUFDLGlEQUFELENBQXpCOztBQUNBLE1BQU1FLEVBQUUsR0FBR0YsbUJBQU8sQ0FBQyw2Q0FBRCxDQUFQLENBQTBCRyxrQkFBMUIsQ0FBNkMsUUFBN0MsQ0FBWCxDLENBRUE7QUFDQTs7O0FBQ0EsTUFBTUMsR0FBRyxHQUFHO0FBQUVDLFNBQU8sRUFBRSxLQUFYO0FBQWtCQyxPQUFLLEVBQUUsSUFBekI7QUFBK0JDLFFBQU0sRUFBRSxLQUF2QztBQUE4Q0MsS0FBRyxFQUFFO0FBQW5ELENBQVosQyxDQUNBOztBQUNBLE1BQU1DLGFBQWEsR0FBRyw2Q0FBdEI7QUFDQSxNQUFNQyxjQUFjLEdBQUcscUNBQXZCLEMsQ0FFQTtBQUNBOztBQUNBLE1BQU1DLE9BQU8sR0FBRyxDQUFoQjtBQUNBLE1BQU1DLGFBQWEsR0FBRyxDQUF0QjtBQUNBLE1BQU1DLFlBQVksR0FBRyxDQUFyQjtBQUNBLE1BQU1DLGFBQWEsR0FBRyxDQUF0QjtBQUNBLE1BQU1DLFFBQVEsR0FBRyxDQUFqQjtBQUNBLE1BQU1DLFlBQVksR0FBRyxDQUFyQixDLENBRUE7QUFDQTs7QUFDQSxJQUFJQyxRQUFKLEMsQ0FBYzs7QUFDZCxJQUFJQyxRQUFKLEMsQ0FBYzs7QUFDZCxJQUFJQyxTQUFKO0FBQ0EsSUFBSUMsUUFBUSxHQUFHVCxPQUFmLEMsQ0FFQTtBQUNBOztBQUNBLFNBQVNVLGFBQVQsQ0FBdUJDLEtBQXZCLEVBQThCQyxlQUE5QixFQUErQztBQUM3QyxNQUFJTixRQUFRLFlBQVlPLFNBQXhCLEVBQW1DO0FBQ2pDUCxZQUFRLENBQUNRLGdCQUFULENBQTBCSCxLQUExQixFQUFpQ0MsZUFBakM7QUFDRCxHQUZELE1BRU87QUFDTCxVQUFNRyxLQUFLLENBQUNqQixhQUFELENBQVg7QUFDRDtBQUNGLEMsQ0FDRDs7O0FBQ0EsU0FBU2tCLGdCQUFULENBQTBCTCxLQUExQixFQUFpQ0MsZUFBakMsRUFBa0Q7QUFDaEQsTUFBSU4sUUFBUSxZQUFZTyxTQUF4QixFQUFtQztBQUNqQ1AsWUFBUSxDQUFDVyxtQkFBVCxDQUE2Qk4sS0FBN0IsRUFBb0NDLGVBQXBDO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsVUFBTUcsS0FBSyxDQUFDakIsYUFBRCxDQUFYO0FBQ0Q7QUFDRixDLENBRUQ7QUFDQTs7QUFDQTs7Ozs7QUFHQSxTQUFTb0IsMkJBQVQsQ0FBcUNDLFFBQXJDLEVBQStDO0FBQzdDLE1BQUlDLE9BQU8sR0FBR0MsSUFBSSxDQUFDQyxLQUFMLENBQVdILFFBQVEsQ0FBQ0ksSUFBcEIsQ0FBZDtBQUNBLE1BQUk7QUFBRUMsU0FBRjtBQUFTQyxTQUFUO0FBQWdCQyxnQkFBaEI7QUFBOEJDLFNBQTlCO0FBQXFDQztBQUFyQyxNQUFnRFIsT0FBcEQsQ0FGNkMsQ0FHN0M7QUFDQTs7QUFDQUosa0JBQWdCLENBQUMsU0FBRCxFQUFZRSwyQkFBWixDQUFoQjtBQUNBVCxVQUFRLEdBQUdOLGFBQVgsQ0FONkMsQ0FPN0M7O0FBQ0EsTUFBSVYsR0FBRyxDQUFDQyxPQUFKLElBQWVELEdBQUcsQ0FBQ0UsS0FBdkIsRUFBOEJrQyxPQUFPLENBQUNDLEdBQVIsQ0FBWSxHQUFHdkMsRUFBRSxDQUFFLElBQUdpQyxLQUFNLEdBQVgsQ0FBakI7QUFDOUJsQixVQUFRLENBQUNtQixLQUFULEdBQWlCckMsU0FBUyxDQUFDMkMsa0JBQVYsRUFBakI7QUFDQTNDLFdBQVMsQ0FBQzRDLFdBQVYsQ0FBc0I7QUFDcEJDLFNBQUssRUFBRVIsS0FEYTtBQUVwQlMsYUFBUyxFQUFFNUIsUUFGUztBQUdwQjZCLGdCQUFZLEVBQUVULFlBSE07QUFJcEJVLFNBQUssRUFBRVQsS0FKYTtBQUtwQlUsWUFBUSxFQUFFVDtBQUxVLEdBQXRCLEVBVjZDLENBaUI3Qzs7QUFDQWxCLGVBQWEsQ0FBQyxTQUFELEVBQVk0QixlQUFaLENBQWI7QUFDQTdCLFVBQVEsR0FBR0wsUUFBWCxDQW5CNkMsQ0FvQjdDOztBQUNBLE1BQUksT0FBT0ksU0FBUyxDQUFDK0IsT0FBakIsS0FBNkIsVUFBakMsRUFBNkMvQixTQUFTLENBQUMrQixPQUFWLEdBckJBLENBc0I3Qzs7QUFDQSxNQUFJQyxNQUFNLENBQUNDLFNBQVgsRUFBc0I7QUFDcEIsUUFBSWhELEdBQUcsQ0FBQ0ksR0FBUixFQUFhZ0MsT0FBTyxDQUFDQyxHQUFSLENBQVksMkNBQVo7QUFDYlUsVUFBTSxDQUFDQyxTQUFQLENBQWlCQyxZQUFqQixHQUFnQ2pCLEtBQWhDO0FBQ0FlLFVBQU0sQ0FBQ0MsU0FBUCxDQUFpQkUsVUFBakIsR0FBOEJqQixZQUE5QjtBQUNEO0FBQ0YsQyxDQUNEOztBQUNBOzs7OztBQUdBLFNBQVNZLGVBQVQsQ0FBeUJuQixRQUF6QixFQUFtQztBQUNqQyxNQUFJeUIsR0FBRyxHQUFHLElBQUl4RCxTQUFKLENBQWMrQixRQUFRLENBQUNJLElBQXZCLENBQVY7QUFDQSxNQUFJc0IsR0FBRyxHQUFHRCxHQUFHLENBQUNFLE9BQUosRUFBVixDQUZpQyxDQUdqQztBQUNBO0FBQ0E7O0FBQ0EsTUFBSUYsR0FBRyxDQUFDRyxVQUFKLEVBQUosRUFBc0I7QUFDcEIsUUFBSXRELEdBQUcsQ0FBQ0csTUFBUixFQUFnQmlDLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLEdBQUd2QyxFQUFFLENBQUUsMEJBQXlCc0QsR0FBSSxFQUEvQixDQUFqQjtBQUNoQkQsT0FBRyxDQUFDSSxtQkFBSjtBQUNBO0FBQ0QsR0FWZ0MsQ0FXakM7QUFDQTs7O0FBQ0EsTUFBSXpCLElBQUksR0FBR3FCLEdBQUcsQ0FBQ0ssSUFBSixFQUFYO0FBQ0EsTUFBSUMsSUFBSSxHQUFHTixHQUFHLENBQUNPLElBQUosRUFBWDtBQUNBLE1BQUlDLE1BQU0sR0FBRzNELEdBQUcsQ0FBQ0csTUFBSixJQUFjLENBQUNpRCxHQUFHLENBQUNRLFVBQUosQ0FBZSxVQUFmLENBQTVCLENBZmlDLENBaUJqQzs7QUFDQSxVQUFRSCxJQUFSO0FBQ0UsU0FBSyxPQUFMO0FBQ0U7QUFDQSxVQUFJRSxNQUFKLEVBQVl2QixPQUFPLENBQUNDLEdBQVIsQ0FBWSxHQUFHdkMsRUFBRSxDQUFFLHlCQUF3QnNELEdBQUksRUFBOUIsQ0FBakI7QUFDWjs7QUFDRixTQUFLLE1BQUw7QUFDRTtBQUNBLFVBQUlPLE1BQUosRUFBWUUsbUJBQW1CLENBQUNWLEdBQUQsQ0FBbkI7QUFDWnJDLGNBQVEsQ0FBQ2dELFdBQVQsQ0FBcUJWLEdBQXJCLEVBQTBCdEIsSUFBMUIsRUFBZ0M7QUFBRWlDLGVBQU8sRUFBRTtBQUFYLE9BQWhDO0FBQ0FaLFNBQUcsQ0FBQ2EsaUJBQUo7QUFDQTs7QUFDRixTQUFLLE9BQUw7QUFDRTtBQUNBLFVBQUlMLE1BQUosRUFBWUUsbUJBQW1CLENBQUNWLEdBQUQsQ0FBbkI7QUFDWnJDLGNBQVEsQ0FBQ21ELFlBQVQsQ0FBc0JiLEdBQXRCLEVBQTJCdEIsSUFBM0IsRUFBaUM7QUFBRWlDLGVBQU8sRUFBRTtBQUFYLE9BQWpDO0FBQ0FaLFNBQUcsQ0FBQ2EsaUJBQUo7QUFDQTs7QUFDRixTQUFLLE9BQUw7QUFDRTtBQUNBLFVBQUlMLE1BQUosRUFBWUUsbUJBQW1CLENBQUNWLEdBQUQsQ0FBbkI7QUFDWnJDLGNBQVEsQ0FBQ29ELFNBQVQsQ0FBbUJkLEdBQW5CLEVBQXdCdEIsSUFBeEIsRUFBOEI7QUFBRWlDLGVBQU8sRUFBRTtBQUFYLE9BQTlCLEVBQWlESSxJQUFqRCxDQUFzREMsTUFBTSxJQUFJO0FBQzlELFlBQUlULE1BQUosRUFBWVUsb0JBQW9CLENBQUNsQixHQUFELEVBQU1pQixNQUFOLENBQXBCLENBRGtELENBRTlEOztBQUNBakIsV0FBRyxDQUFDbUIsT0FBSixDQUFZRixNQUFaO0FBQ0FqQixXQUFHLENBQUNhLGlCQUFKO0FBQ0QsT0FMRDtBQU1BOztBQUNGO0FBQ0UsWUFBTTFDLEtBQUssQ0FBQyxxQkFBRCxFQUF3Qm1DLElBQXhCLENBQVg7QUE1QkosR0FsQmlDLENBZ0RqQzs7O0FBQ0EsV0FBU0ksbUJBQVQsQ0FBNkJWLEdBQTdCLEVBQWtDO0FBQ2hDZixXQUFPLENBQUNtQyxJQUFSLENBQ0UsR0FBR3pFLEVBQUUsQ0FDRixNQUFLSCxTQUFTLENBQUM2RSxXQUFWLEVBQXdCLGNBQWFyQixHQUFHLENBQUNPLElBQUosRUFBVyxNQUFLUCxHQUFHLENBQUNFLE9BQUosRUFBYyxVQUFTRixHQUFHLENBQUNzQixhQUFKLEVBQW9CLEVBRG5HLENBRFAsRUFJRXRCLEdBQUcsQ0FBQ0ssSUFBSixFQUpGO0FBTUQsR0F4RGdDLENBeURqQzs7O0FBQ0EsV0FBU2Esb0JBQVQsQ0FBOEJsQixHQUE5QixFQUFtQ2lCLE1BQW5DLEVBQTJDO0FBQ3pDaEMsV0FBTyxDQUFDQyxHQUFSLENBQ0UsR0FBR3ZDLEVBQUUsQ0FDRixNQUFLSCxTQUFTLENBQUM2RSxXQUFWLEVBQXdCLGVBQWNyQixHQUFHLENBQUNFLE9BQUosRUFBYyxnQkFBZXpCLElBQUksQ0FBQzhDLFNBQUwsQ0FDdkVOLE1BRHVFLENBRXZFLEVBSEMsQ0FEUDtBQU9EO0FBQ0YsQyxDQUVEO0FBQ0E7OztBQUNBLE1BQU1PLE9BQU8sR0FBRyxFQUFoQixDLENBQ0E7O0FBQ0E7Ozs7Ozs7QUFNQUEsT0FBTyxDQUFDQyxPQUFSLEdBQWtCLENBQUNDLFFBQUQsRUFBV0MsR0FBWCxLQUFtQjtBQUNuQyxTQUFPLElBQUlDLE9BQUosQ0FBWUMsT0FBTyxJQUFJO0FBQzVCLFFBQUloRSxRQUFRLEdBQUcsQ0FBZixFQUFrQjtBQUNoQixVQUFJaUUsR0FBRyxHQUNMLHNFQURGO0FBRUE3QyxhQUFPLENBQUM4QyxLQUFSLENBQWMsR0FBR3BGLEVBQUUsQ0FBQ21GLEdBQUQsQ0FBbkI7QUFDQTtBQUNEOztBQUNEakUsWUFBUSxHQUFHUixhQUFYLENBUDRCLENBUzVCOztBQUNBLFFBQUlxRSxRQUFRLENBQUNNLFdBQVQsQ0FBcUJDLElBQXJCLEtBQThCLFFBQWxDLEVBQTRDO0FBQzFDLFlBQU05RCxLQUFLLENBQUNoQixjQUFELENBQVg7QUFDRDs7QUFDRCxRQUFJLENBQUNRLFFBQUwsRUFBZUEsUUFBUSxHQUFHK0QsUUFBWDtBQUNmOUQsYUFBUyxHQUFHK0QsR0FBRyxJQUFJLEVBQW5CLENBZDRCLENBZ0I1QjtBQUNBOztBQUNBLFVBQU07QUFBRU8sVUFBSSxFQUFFQyxTQUFSO0FBQW1CQyxVQUFJLEVBQUVDO0FBQXpCLFFBQTBDM0YsU0FBUyxDQUFDNEYsWUFBVixFQUFoRDtBQUNBLFFBQUlDLEtBQUssR0FBSSxRQUFPSixTQUFVLElBQUdFLFlBQWEsRUFBOUM7QUFDQTNFLFlBQVEsR0FBRyxJQUFJTyxTQUFKLENBQWNzRSxLQUFkLENBQVg7QUFDQSxRQUFJMUYsR0FBRyxDQUFDQyxPQUFSLEVBQWlCbUMsT0FBTyxDQUFDQyxHQUFSLENBQVksR0FBR3ZDLEVBQUUsQ0FBRSxrQkFBaUI0RixLQUFNLEVBQXpCLENBQWpCLEVBckJXLENBdUI1Qjs7QUFDQXpFLGlCQUFhLENBQUMsTUFBRCxFQUFTQyxLQUFLLElBQUk7QUFDN0IsVUFBSWxCLEdBQUcsQ0FBQ0MsT0FBUixFQUFpQm1DLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLEdBQUd2QyxFQUFFLENBQUUsV0FBVW9CLEtBQUssQ0FBQ3lFLE1BQU4sQ0FBYUMsR0FBSSxFQUE3QixDQUFqQjtBQUNqQjVFLGNBQVEsR0FBR1AsWUFBWCxDQUY2QixDQUc3QjtBQUNBOztBQUNBLFVBQUlULEdBQUcsQ0FBQ0MsT0FBUixFQUFpQm1DLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLEdBQUd2QyxFQUFFLENBQUMsV0FBRCxDQUFqQjtBQUNqQmtGLGFBQU87QUFDUixLQVBZLENBQWI7QUFRQS9ELGlCQUFhLENBQUMsT0FBRCxFQUFVQyxLQUFLLElBQUk7QUFDOUIsVUFBSWxCLEdBQUcsQ0FBQ0MsT0FBUixFQUFpQm1DLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLEdBQUd2QyxFQUFFLENBQUUsV0FBVW9CLEtBQUssQ0FBQ3lFLE1BQU4sQ0FBYUMsR0FBSSxFQUE3QixDQUFqQjtBQUNqQmpHLGVBQVMsQ0FBQ2tHLGlCQUFWO0FBQ0E3RSxjQUFRLEdBQUdKLFlBQVg7QUFDRCxLQUpZLENBQWIsQ0FoQzRCLENBcUM1Qjs7QUFDQUssaUJBQWEsQ0FBQyxTQUFELEVBQVlRLDJCQUFaLENBQWI7QUFDRCxHQXZDTSxDQUFQO0FBd0NELENBekNELEMsQ0F5Q0c7QUFDSDs7QUFDQTs7OztBQUVBa0QsT0FBTyxDQUFDbUIsS0FBUixHQUFnQixDQUFDQyxJQUFELEVBQU9DLE1BQVAsS0FBa0I7QUFDaENELE1BQUksR0FBR0EsSUFBSSxJQUFJLElBQWY7QUFDQUMsUUFBTSxHQUFHQSxNQUFNLElBQUksb0JBQW5CO0FBQ0FuRixVQUFRLENBQUNvRixLQUFULENBQWVGLElBQWYsRUFBcUJDLE1BQXJCO0FBQ0QsQ0FKRCxDLENBS0E7O0FBQ0E7Ozs7O0FBR0FyQixPQUFPLENBQUNILFdBQVIsR0FBc0IsTUFBTTtBQUMxQixTQUFPN0UsU0FBUyxDQUFDNkUsV0FBVixFQUFQO0FBQ0QsQ0FGRCxDLENBR0E7O0FBQ0E7Ozs7O0FBR0FHLE9BQU8sQ0FBQ3VCLGdCQUFSLEdBQTJCLE1BQU07QUFDL0IsU0FBT2xGLFFBQVEsS0FBS0osWUFBcEI7QUFDRCxDQUZELEMsQ0FHQTs7QUFDQTs7Ozs7QUFHQStELE9BQU8sQ0FBQ3dCLFdBQVIsR0FBc0IsTUFBTXhHLFNBQVMsQ0FBQ3dHLFdBQVYsRUFBNUIsQyxDQUVBO0FBQ0E7OztBQUNBQyxNQUFNLENBQUNDLE9BQVAsR0FBaUIxQixPQUFqQiIsImZpbGUiOiIuL3NyYy9jbGllbnQtbmV0d29yay5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZSAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbi8qLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gQUJPVVQgXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcKlxcXG5cbiAgICBVUlNZUyBORVRXT1JLIGltcGxlbWVudHMgbmV0d29yayBjb250cm9scyBhbmQgc3luY2hyb25pemF0aW9uLlxuICAgIEl0IGluaXRpYWxpemVzIGEgbmV0d29yayBjb25uZWN0aW9uIG9uIHRoZSBDT05ORUNUIGxpZmVjeWNsZS5cblxuXFwqXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwgKiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyovXG5jb25zdCBOZXRQYWNrZXQgPSByZXF1aXJlKCcuL2NsYXNzLW5ldHBhY2tldCcpO1xuY29uc3QgVVJTZXNzaW9uID0gcmVxdWlyZSgnLi9jbGllbnQtc2Vzc2lvbicpO1xuY29uc3QgUFIgPSByZXF1aXJlKCcuL3V0aWwvcHJvbXB0cycpLm1ha2VTdHlsZUZvcm1hdHRlcignVVIuTkVUJyk7XG5cbi8vLyBERUNMQVJBVElPTlMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5jb25zdCBEQkcgPSB7IGNvbm5lY3Q6IGZhbHNlLCBoZWxsbzogdHJ1ZSwgaGFuZGxlOiBmYWxzZSwgcmVnOiBmYWxzZSB9O1xuLy8vXG5jb25zdCBFUlJfTk9fU09DS0VUID0gJ05ldHdvcmsgc29ja2V0IGhhcyBub3QgYmVlbiBlc3RhYmxpc2hlZCB5ZXQnO1xuY29uc3QgRVJSX0JBRF9VUkNIQU4gPSBcIkFuIGluc3RhbmNlIG9mICdVUkNoYW4nIGlzIHJlcXVpcmVkXCI7XG5cbi8vLyBORVRXT1JLIElEIFZBTFVFUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbmNvbnN0IE0wX0lOSVQgPSAwO1xuY29uc3QgTTFfQ09OTkVDVElORyA9IDE7XG5jb25zdCBNMl9DT05ORUNURUQgPSAyO1xuY29uc3QgTTNfUkVHSVNURVJFRCA9IDM7XG5jb25zdCBNNF9SRUFEWSA9IDQ7XG5jb25zdCBNX1NUQU5EQUxPTkUgPSA1O1xuXG4vLy8gREVDTEFSQVRJT05TIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5sZXQgbV9zb2NrZXQ7IC8vIGNvbnRhaW4gc29ja2V0IGluZm9ybWF0aW9uIG9uIHJlZ2lzdHJhdGlvbiBtZXNzYWdlXG5sZXQgbV91cmxpbms7IC8vIGFzc2lnbmVkIGR1cmluZyBORVRXT1JLLkNvbm5lY3QoKVxubGV0IG1fb3B0aW9ucztcbmxldCBtX3N0YXR1cyA9IE0wX0lOSVQ7XG5cbi8vLyBORVRXT1JLIExJU1RFTkVSUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbmZ1bmN0aW9uIG1fQWRkTGlzdGVuZXIoZXZlbnQsIGhhbmRsZXJGdW5jdGlvbikge1xuICBpZiAobV9zb2NrZXQgaW5zdGFuY2VvZiBXZWJTb2NrZXQpIHtcbiAgICBtX3NvY2tldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyRnVuY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKEVSUl9OT19TT0NLRVQpO1xuICB9XG59XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5mdW5jdGlvbiBtX1JlbW92ZUxpc3RlbmVyKGV2ZW50LCBoYW5kbGVyRnVuY3Rpb24pIHtcbiAgaWYgKG1fc29ja2V0IGluc3RhbmNlb2YgV2ViU29ja2V0KSB7XG4gICAgbV9zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlckZ1bmN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihFUlJfTk9fU09DS0VUKTtcbiAgfVxufVxuXG4vLy8gQVBJIEhFTFBFUlMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogQWZ0ZXIgJ29wZW4nIGV2ZW50LCB3ZSBleHBlY3QgdGhlIGZpcnN0IG1lc3NhZ2Ugb24gdGhlIHNvY2tldCB0byBjb250YWluXG4gKiAgbmV0d29yayBzZXNzaW9uLXJlbGF0ZWQgbWVzc2FnZXNcbiAqL1xuZnVuY3Rpb24gbV9IYW5kbGVSZWdpc3RyYXRpb25NZXNzYWdlKG1zZ0V2ZW50KSB7XG4gIGxldCByZWdEYXRhID0gSlNPTi5wYXJzZShtc2dFdmVudC5kYXRhKTtcbiAgbGV0IHsgSEVMTE8sIFVBRERSLCBTRVJWRVJfVUFERFIsIFBFRVJTLCBVTE9DQUwgfSA9IHJlZ0RhdGE7XG4gIC8vICgxKSBhZnRlciByZWNlaXZpbmcgdGhlIGluaXRpYWwgbWVzc2FnZSwgc3dpdGNoIG92ZXIgdG8gcmVndWxhclxuICAvLyBtZXNzYWdlIGhhbmRsZXJcbiAgbV9SZW1vdmVMaXN0ZW5lcignbWVzc2FnZScsIG1fSGFuZGxlUmVnaXN0cmF0aW9uTWVzc2FnZSk7XG4gIG1fc3RhdHVzID0gTTNfUkVHSVNURVJFRDtcbiAgLy8gKDIpIGluaXRpYWxpemUgZ2xvYmFsIHNldHRpbmdzIGZvciBuZXRtZXNzYWdlXG4gIGlmIChEQkcuY29ubmVjdCB8fCBEQkcuaGVsbG8pIGNvbnNvbGUubG9nKC4uLlBSKGAnJHtIRUxMT30nYCkpO1xuICBtX3NvY2tldC5VQUREUiA9IE5ldFBhY2tldC5EZWZhdWx0U2VydmVyVUFERFIoKTtcbiAgTmV0UGFja2V0Lkdsb2JhbFNldHVwKHtcbiAgICB1YWRkcjogVUFERFIsXG4gICAgbmV0c29ja2V0OiBtX3NvY2tldCxcbiAgICBzZXJ2ZXJfdWFkZHI6IFNFUlZFUl9VQUREUixcbiAgICBwZWVyczogUEVFUlMsXG4gICAgaXNfbG9jYWw6IFVMT0NBTFxuICB9KTtcbiAgLy8gKDMpIGNvbm5lY3QgcmVndWxhciBtZXNzYWdlIGhhbmRsZXJcbiAgbV9BZGRMaXN0ZW5lcignbWVzc2FnZScsIG1fSGFuZGxlTWVzc2FnZSk7XG4gIG1fc3RhdHVzID0gTTRfUkVBRFk7XG4gIC8vICg0KSBuZXR3b3JrIGlzIGluaXRpYWxpemVkXG4gIGlmICh0eXBlb2YgbV9vcHRpb25zLnN1Y2Nlc3MgPT09ICdmdW5jdGlvbicpIG1fb3B0aW9ucy5zdWNjZXNzKCk7XG4gIC8vICg1KSBhbHNvIHVwZGF0ZSB3aW5kb3cuVVJTRVNTSU9OIHdpdGggVUFERFJcbiAgaWYgKHdpbmRvdy5VUlNFU1NJT04pIHtcbiAgICBpZiAoREJHLnJlZykgY29uc29sZS5sb2coJ3VwZGF0aW5nIFVSU0VTU0lPTiB3aXRoIHJlZ2lzdHJhdGlvbiBkYXRhJyk7XG4gICAgd2luZG93LlVSU0VTU0lPTi5DTElFTlRfVUFERFIgPSBVQUREUjtcbiAgICB3aW5kb3cuVVJTRVNTSU9OLlVTUlZfVUFERFIgPSBTRVJWRVJfVUFERFI7XG4gIH1cbn1cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBEaXNwYXRjaCBpbmNvbWluZyBldmVudCBvYmplY3QgZnJvbSB0aGUgbmV0d29yay5cbiAqICBAcGFyYW0ge1NvY2tldEV2ZW50fSBtc2dFdmVudCAtaW5jb21pbmcgZXZlbnQgb2JqZWN0IGZyb20gd2Vic29ja2V0XG4gKi9cbmZ1bmN0aW9uIG1fSGFuZGxlTWVzc2FnZShtc2dFdmVudCkge1xuICBsZXQgcGt0ID0gbmV3IE5ldFBhY2tldChtc2dFdmVudC5kYXRhKTtcbiAgbGV0IG1zZyA9IHBrdC5NZXNzYWdlKCk7XG4gIC8vICgxKSBJZiB0aGlzIHBhY2tldCBpcyBhIHJlc3BvbnNlIHBhY2tldCwgdGhlbiBpdCBtdXN0IGJlIG9uZSBvZlxuICAvLyBvdXIgT1dOIHByZXZpb3VzbHktc2VudCBtZXNzYWdlcyB0aGF0IHdlIGV4cGVjdGVkIGEgcmV0dXJuIHZhbHVlLlxuICAvLyBDYWxsIENvbXBsZXRlVHJhbnNhY3Rpb24oKSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIGhhbmRsZXJcbiAgaWYgKHBrdC5Jc1Jlc3BvbnNlKCkpIHtcbiAgICBpZiAoREJHLmhhbmRsZSkgY29uc29sZS5sb2coLi4uUFIoYGNvbXBsZXRpbmcgdHJhbnNhY3Rpb24gJHttc2d9YCkpO1xuICAgIHBrdC5Db21wbGV0ZVRyYW5zYWN0aW9uKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vICgyKSBPdGhlcndpc2UsIHRoZSBpbmNvbWluZyBuZXR3b3JrIG1lc3NhZ2UgaGFzIGJlZW4gcm91dGVkIHRvXG4gIC8vIHVzIHRvIGhhbmRsZS5cbiAgbGV0IGRhdGEgPSBwa3QuRGF0YSgpO1xuICBsZXQgdHlwZSA9IHBrdC5UeXBlKCk7XG4gIGxldCBkYmdvdXQgPSBEQkcuaGFuZGxlICYmICFtc2cuc3RhcnRzV2l0aCgnTkVUOlNSVl8nKTtcblxuICAvLyAoMykgaGFuZGxlIGVhY2ggcGFja2V0IHR5cGUgYXMgbmVjZXNzYXJ5XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N0YXRlJzpcbiAgICAgIC8vIHVuaW1wbGVtZW50ZWQgbmV0c3RhdGVcbiAgICAgIGlmIChkYmdvdXQpIGNvbnNvbGUubG9nKC4uLlBSKGByZWNlaXZlZCBzdGF0ZSBjaGFuZ2UgJHttc2d9YCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbXNpZyc6XG4gICAgICAvLyBuZXR3b3JrIHNpZ25hbCB0byByYWlzZVxuICAgICAgaWYgKGRiZ291dCkgY291dF9SZWNlaXZlZFN0YXR1cyhwa3QpO1xuICAgICAgbV91cmxpbmsuTG9jYWxTaWduYWwobXNnLCBkYXRhLCB7IGZyb21OZXQ6IHRydWUgfSk7XG4gICAgICBwa3QuUmV0dXJuVHJhbnNhY3Rpb24oKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21zZW5kJzpcbiAgICAgIC8vIG5ldHdvcmsgbWVzc2FnZSByZWNlaXZlZFxuICAgICAgaWYgKGRiZ291dCkgY291dF9SZWNlaXZlZFN0YXR1cyhwa3QpO1xuICAgICAgbV91cmxpbmsuTG9jYWxQdWJsaXNoKG1zZywgZGF0YSwgeyBmcm9tTmV0OiB0cnVlIH0pO1xuICAgICAgcGt0LlJldHVyblRyYW5zYWN0aW9uKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtY2FsbCc6XG4gICAgICAvLyBuZXR3b3JrIGNhbGwgcmVjZWl2ZWRcbiAgICAgIGlmIChkYmdvdXQpIGNvdXRfUmVjZWl2ZWRTdGF0dXMocGt0KTtcbiAgICAgIG1fdXJsaW5rLkxvY2FsQ2FsbChtc2csIGRhdGEsIHsgZnJvbU5ldDogdHJ1ZSB9KS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgIGlmIChkYmdvdXQpIGNvdXRfRm9yd2FyZGVkU3RhdHVzKHBrdCwgcmVzdWx0KTtcbiAgICAgICAgLy8gbm93IHJldHVybiB0aGUgcGFja2V0XG4gICAgICAgIHBrdC5TZXREYXRhKHJlc3VsdCk7XG4gICAgICAgIHBrdC5SZXR1cm5UcmFuc2FjdGlvbigpO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgRXJyb3IoJ3Vua25vd24gcGFja2V0IHR5cGUnLCB0eXBlKTtcbiAgfVxuICAvLyBERUJVRyBPVVQgVVRJTElUWVxuICBmdW5jdGlvbiBjb3V0X1JlY2VpdmVkU3RhdHVzKHBrdCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIC4uLlBSKFxuICAgICAgICBgTUVfJHtOZXRQYWNrZXQuU29ja2V0VUFERFIoKX0gcmVjZWl2ZWQgJyR7cGt0LlR5cGUoKX0nICcke3BrdC5NZXNzYWdlKCl9JyBmcm9tICR7cGt0LlNvdXJjZUFkZHJlc3MoKX1gXG4gICAgICApLFxuICAgICAgcGt0LkRhdGEoKVxuICAgICk7XG4gIH1cbiAgLy8gREVCVUcgT1VUIFVUSUxJVFlcbiAgZnVuY3Rpb24gY291dF9Gb3J3YXJkZWRTdGF0dXMocGt0LCByZXN1bHQpIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIC4uLlBSKFxuICAgICAgICBgTUVfJHtOZXRQYWNrZXQuU29ja2V0VUFERFIoKX0gZm9yd2FyZGVkICcke3BrdC5NZXNzYWdlKCl9JywgcmV0dXJuaW5nICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgcmVzdWx0XG4gICAgICAgICl9YFxuICAgICAgKVxuICAgICk7XG4gIH1cbn1cblxuLy8vIEFQSSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuY29uc3QgTkVUV09SSyA9IHt9O1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIEVzdGFibGlzaCBjb25uZWN0aW9uIHRvIFVSU1lTIHNlcnZlci4gVGhpcyBpcyBjYWxsZWQgYnkgY2xpZW50LmpzIGR1cmluZ1xuICogIE5ldHdvcmtJbml0aWFsaXplKCksIHdoaWNoIGl0c2VsZiBmaXJlcyBhZnRlciB0aGUgYXBwbGljYXRpb24gaGFzIHJlbmRlcmVkXG4gKiAgY29tcGxldGVseS5cbiAqICBAcGFyYW0gZGF0YWxpbmsgLSBhbiB1cmNoYW5uZWwgZW5kcG9pbnRcbiAqICBAcGFyYW0gb3B0IC0geyBzdWNjZXNzLCBmYWlsdXJlIH0gZnVuY3Rpb25zXG4gKi9cbk5FVFdPUksuQ29ubmVjdCA9IChkYXRhbGluaywgb3B0KSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBpZiAobV9zdGF0dXMgPiAwKSB7XG4gICAgICBsZXQgZXJyID1cbiAgICAgICAgJ2NhbGxlZCB0d2ljZS4uLm90aGVyIHZpZXdzIG1heSBiZSBjYWxsaW5nIFVSU1lTIG91dHNpZGUgb2YgbGlmZWN5Y2xlJztcbiAgICAgIGNvbnNvbGUuZXJyb3IoLi4uUFIoZXJyKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1fc3RhdHVzID0gTTFfQ09OTkVDVElORztcblxuICAgIC8vIGNoZWNrIGFuZCBzYXZlIHBhcm1zXG4gICAgaWYgKGRhdGFsaW5rLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdVUkNoYW4nKSB7XG4gICAgICB0aHJvdyBFcnJvcihFUlJfQkFEX1VSQ0hBTik7XG4gICAgfVxuICAgIGlmICghbV91cmxpbmspIG1fdXJsaW5rID0gZGF0YWxpbms7XG4gICAgbV9vcHRpb25zID0gb3B0IHx8IHt9O1xuXG4gICAgLy8gY3JlYXRlIHdlYnNvY2tldFxuICAgIC8vIHVzZXMgdmFsdWVzIHRoYXQgYXJlIHNldCBieSBVUi1FWEVDIFN5c3RlbUJvb3QoKVxuICAgIGNvbnN0IHsgaG9zdDogVVNSVl9Ib3N0LCBwb3J0OiBVU1JWX01zZ1BvcnQgfSA9IFVSU2Vzc2lvbi5HZXROZXRCcm9rZXIoKTtcbiAgICBsZXQgd3NVUkkgPSBgd3M6Ly8ke1VTUlZfSG9zdH06JHtVU1JWX01zZ1BvcnR9YDtcbiAgICBtX3NvY2tldCA9IG5ldyBXZWJTb2NrZXQod3NVUkkpO1xuICAgIGlmIChEQkcuY29ubmVjdCkgY29uc29sZS5sb2coLi4uUFIoYE9QRU4gU09DS0VUIFRPICR7d3NVUkl9YCkpO1xuXG4gICAgLy8gY3JlYXRlIGxpc3RlbmVyc1xuICAgIG1fQWRkTGlzdGVuZXIoJ29wZW4nLCBldmVudCA9PiB7XG4gICAgICBpZiAoREJHLmNvbm5lY3QpIGNvbnNvbGUubG9nKC4uLlBSKGAuLi5PUEVOICR7ZXZlbnQudGFyZ2V0LnVybH1gKSk7XG4gICAgICBtX3N0YXR1cyA9IE0yX0NPTk5FQ1RFRDtcbiAgICAgIC8vIG1lc3NhZ2UgaGFuZGxpbmcgY29udGludWVzIGluICdtZXNzYWdlJyBoYW5kbGVyXG4gICAgICAvLyB0aGUgZmlyc3QgbWVzc2FnZSBpcyBhc3N1bWVkIHRvIGJlIHJlZ2lzdHJhdGlvbiBkYXRhXG4gICAgICBpZiAoREJHLmNvbm5lY3QpIGNvbnNvbGUubG9nKC4uLlBSKCdDT05ORUNURUQnKSk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgbV9BZGRMaXN0ZW5lcignY2xvc2UnLCBldmVudCA9PiB7XG4gICAgICBpZiAoREJHLmNvbm5lY3QpIGNvbnNvbGUubG9nKC4uLlBSKGAuLkNMT1NFICR7ZXZlbnQudGFyZ2V0LnVybH1gKSk7XG4gICAgICBOZXRQYWNrZXQuR2xvYmFsT2ZmbGluZU1vZGUoKTtcbiAgICAgIG1fc3RhdHVzID0gTV9TVEFOREFMT05FO1xuICAgIH0pO1xuICAgIC8vIGhhbmRsZSBpbmNvbWluZyBtZXNzYWdlc1xuICAgIG1fQWRkTGlzdGVuZXIoJ21lc3NhZ2UnLCBtX0hhbmRsZVJlZ2lzdHJhdGlvbk1lc3NhZ2UpO1xuICB9KTtcbn07IC8vIENvbm5lY3QoKVxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIEZvcmNlIGNsb3NlIG9mIGNvbm5lY3Rpb24sIGZvciBleGFtcGxlIGlmIFVSU1lTLkFwcFJlYWR5KCkgZmFpbHNcbiAqL1xuTkVUV09SSy5DbG9zZSA9IChjb2RlLCByZWFzb24pID0+IHtcbiAgY29kZSA9IGNvZGUgfHwgMTAwMDtcbiAgcmVhc29uID0gcmVhc29uIHx8ICdVUlNZUyBmb3JjZWQgY2xvc2UnO1xuICBtX3NvY2tldC5jbG9zZShjb2RlLCByZWFzb24pO1xufTtcbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBSZXR1cm4gdGhlIGN1cnJlbnQgdWFkZHIgb2YgdGhpcyBjbGllbnQsIHdoaWNoIGlzIHN0b3JlZCBpbiBOZXRQYWNrZXRcbiAqICB3aGVuIHRoZSBjbGllbnQgaW5pdGlhbGl6ZXMuXG4gKi9cbk5FVFdPUksuU29ja2V0VUFERFIgPSAoKSA9PiB7XG4gIHJldHVybiBOZXRQYWNrZXQuU29ja2V0VUFERFIoKTtcbn07XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogUmV0dXJuIFRSVUUgaWYgY2xpZW50IGlzIGluIFwic3RhbmRhbG9uZVwiIG1vZGUuIFRoaXMgd2FzIGEgTmV0Q3JlYXRlXG4gKiAgdGhhdCB3YXMgdXNlZCB0byBkaXNhYmxlIG5ldHdvcmsgY29tbXVuaWNhdGlvbiBmb3IgSFRNTC1vbmx5IHNuYXBzaG90cy5cbiAqL1xuTkVUV09SSy5Jc1N0YW5kYWxvbmVNb2RlID0gKCkgPT4ge1xuICByZXR1cm4gbV9zdGF0dXMgPT09IE1fU1RBTkRBTE9ORTtcbn07XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogUmV0dXJuIFRSVUUgaWYgY2xpZW50IGlzIHJ1bm5pbmcgd2l0aCB0aGUgbG9jYWxob3N0IGFzIHNlcnZlci5cbiAqICBUaGlzIGNhbiBiZSB1c2VkIGFzIHF1aWNrIHdheSB0byBlbmFibGUgYWRtaW4tb25seSBmZWF0dXJlcy5cbiAqL1xuTkVUV09SSy5Jc0xvY2FsaG9zdCA9ICgpID0+IE5ldFBhY2tldC5Jc0xvY2FsaG9zdCgpO1xuXG4vLy8gRVhQT1JUIE1PRFVMRSBERUZJTklUSU9OIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5tb2R1bGUuZXhwb3J0cyA9IE5FVFdPUks7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/client-network.js\n");

/***/ }),

/***/ "./src/client-session.ts":
/*!*******************************!*\
  !*** ./src/client-session.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*///////////////////////////////// ABOUT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\n\n  CLIENT-SESSION centralizes shared data structures about the session.\n  This is a pure data module that can be referenced by any URSYS client.\n\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ * /////////////////////////////////////*/\n/**\n *  @module ClientSession\n */\n/// DEBUG  ////////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nconst DBG = false;\nconst PR = __webpack_require__(/*! ./util/prompts */ \"./src/util/prompts.js\").makeStyleFormatter('UR.SES');\n/// DECLARATIONS //////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nlet NET_BROKER;\n/// API METHODS ///////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nfunction InitializeNetProps(props) {\n    if (DBG)\n        console.log(...PR('info - setting netprops'), props);\n    const { broker } = props;\n    NET_BROKER = broker;\n    if (DBG)\n        console.log(...PR('session broker'), broker);\n}\nfunction GetNetBroker() {\n    return NET_BROKER;\n}\n/// EXPORTS ///////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nmodule.exports = { InitializeNetProps, GetNetBroker };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50LXNlc3Npb24udHM/NDc2ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7K0VBSytFO0FBRS9FOztHQUVHO0FBRUgsK0VBQStFO0FBQy9FLCtFQUErRTtBQUMvRSxNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUM7QUFDbEIsTUFBTSxFQUFFLEdBQUcsbUJBQU8sQ0FBQyw2Q0FBZ0IsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBY2xFLCtFQUErRTtBQUMvRSwrRUFBK0U7QUFDL0UsSUFBSSxVQUF5QixDQUFDO0FBRTlCLCtFQUErRTtBQUMvRSwrRUFBK0U7QUFDL0UsU0FBUyxrQkFBa0IsQ0FBQyxLQUFlO0lBQ3pDLElBQUksR0FBRztRQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMseUJBQXlCLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUM5RCxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDO0lBQ3pCLFVBQVUsR0FBRyxNQUFNLENBQUM7SUFDcEIsSUFBSSxHQUFHO1FBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ3hELENBQUM7QUFDRCxTQUFTLFlBQVk7SUFDbkIsT0FBTyxVQUFVLENBQUM7QUFDcEIsQ0FBQztBQUVELCtFQUErRTtBQUMvRSwrRUFBK0U7QUFDL0UsTUFBTSxDQUFDLE9BQU8sR0FBRyxFQUFFLGtCQUFrQixFQUFFLFlBQVksRUFBRSxDQUFDIiwiZmlsZSI6Ii4vc3JjL2NsaWVudC1zZXNzaW9uLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyovLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gQUJPVVQgXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCpcXFxuXG4gIENMSUVOVC1TRVNTSU9OIGNlbnRyYWxpemVzIHNoYXJlZCBkYXRhIHN0cnVjdHVyZXMgYWJvdXQgdGhlIHNlc3Npb24uXG4gIFRoaXMgaXMgYSBwdXJlIGRhdGEgbW9kdWxlIHRoYXQgY2FuIGJlIHJlZmVyZW5jZWQgYnkgYW55IFVSU1lTIGNsaWVudC5cblxuXFwqXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCAqIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8qL1xuXG4vKipcbiAqICBAbW9kdWxlIENsaWVudFNlc3Npb25cbiAqL1xuXG4vLy8gREVCVUcgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5jb25zdCBEQkcgPSBmYWxzZTtcbmNvbnN0IFBSID0gcmVxdWlyZSgnLi91dGlsL3Byb21wdHMnKS5tYWtlU3R5bGVGb3JtYXR0ZXIoJ1VSLlNFUycpO1xuXG4vLy8gVFlQRSBERUNMQVJBVElPTlMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5pbnRlcmZhY2UgTmV0UHJvcHMge1xuICBicm9rZXI6IE1lc3NhZ2VCcm9rZXI7XG59XG5pbnRlcmZhY2UgTWVzc2FnZUJyb2tlciB7XG4gIGhvc3Q6IHN0cmluZztcbiAgcG9ydDogbnVtYmVyO1xuICB1YWRkcjogc3RyaW5nO1xuICB1cm5ldF92ZXJzaW9uOiBudW1iZXI7XG59XG5cbi8vLyBERUNMQVJBVElPTlMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbmxldCBORVRfQlJPS0VSOiBNZXNzYWdlQnJva2VyO1xuXG4vLy8gQVBJIE1FVEhPRFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5mdW5jdGlvbiBJbml0aWFsaXplTmV0UHJvcHMocHJvcHM6IE5ldFByb3BzKSB7XG4gIGlmIChEQkcpIGNvbnNvbGUubG9nKC4uLlBSKCdpbmZvIC0gc2V0dGluZyBuZXRwcm9wcycpLCBwcm9wcyk7XG4gIGNvbnN0IHsgYnJva2VyIH0gPSBwcm9wcztcbiAgTkVUX0JST0tFUiA9IGJyb2tlcjtcbiAgaWYgKERCRykgY29uc29sZS5sb2coLi4uUFIoJ3Nlc3Npb24gYnJva2VyJyksIGJyb2tlcik7XG59XG5mdW5jdGlvbiBHZXROZXRCcm9rZXIoKSB7XG4gIHJldHVybiBORVRfQlJPS0VSO1xufVxuXG4vLy8gRVhQT1JUUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5tb2R1bGUuZXhwb3J0cyA9IHsgSW5pdGlhbGl6ZU5ldFByb3BzLCBHZXROZXRCcm9rZXIgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/client-session.ts\n");

/***/ }),

/***/ "./src/index-client.js":
/*!*****************************!*\
  !*** ./src/index-client.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__filename) {/*///////////////////////////////// ABOUT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\n\n  URSYS CLIENT MAIN ENTRY\n\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ * /////////////////////////////////////*/\n/// LIBRARIES /////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nconst URChannel = __webpack_require__(/*! ./client-channel */ \"./src/client-channel.js\");\n\nconst URNet = __webpack_require__(/*! ./client-network */ \"./src/client-network.js\");\n\nconst URExec = __webpack_require__(/*! ./client-exec */ \"./src/client-exec.js\");\n\nconst PROMPTS = __webpack_require__(/*! ./util/prompts */ \"./src/util/prompts.js\");\n\nconst PR = PROMPTS.makeStyleFormatter('UR'); /// CLASSES ///////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst PhaseMachine = __webpack_require__(/*! ./class-phase-machine */ \"./src/class-phase-machine.js\"); /// META DATA /////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** these properties are exported from the library so you can tell if the\n *  ur instance you're using is serverside or clientside, if that needs\n *  to be checked\n */\n\n\nconst META = {\n  _CLIENT: true,\n  _SCRIPT: __filename,\n  _VERSION: '0.0.1'\n}; /// CLIENT-SIDE ///////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n/// to be implemented\n\nconst Events = {};\nconst Extensions = {};\nconst PubSub = {}; /// DECLARATIONS //////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst nc_sub = new URChannel('ursys-sub');\nconst nc_pub = new URChannel('ursys-pub');\nlet URSYS_RUNNING = false; /// MAIN API //////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** initialize modules that participate in UR EXEC PhaseMachine before running\n *  SystemBoot, which starts the URSYS lifecycle.\n */\n\nasync function SystemStart() {\n  if (URSYS_RUNNING) {\n    console.log(...PR('SystemStart: URSYS already running!!!'));\n    return Promise.reject();\n  } // autoconnect to URSYS network during NET_CONNECT\n\n\n  PhaseMachine.QueueHookFor('UR', 'NET_CONNECT', () => new Promise((resolvbe, reject) => URNet.Connect(nc_sub, {\n    success: resolvbe,\n    failure: reject\n  })));\n  URSYS_RUNNING = true;\n  return Promise.resolve();\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** deallocate any system resources assigned during Initialize\n */\n\n\nasync function SystemStop() {\n  if (!URSYS_RUNNING) {\n    console.log(...PR('SystemModulesStop: URSYS is not running!!!'));\n    return Promise.resolve();\n  } // close the network\n\n\n  await URNet.Close();\n  URSYS_RUNNING = false;\n  return Promise.resolve();\n} /// EXPORTS ///////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nmodule.exports = { ...META,\n  // FORWARDED PUB/SUB\n  Subscribe: nc_sub.Subscribe,\n  Unsubscribe: nc_sub.Unsubscribe,\n  Publish: nc_pub.LocalPublish,\n  Signal: nc_pub.LocalSignal,\n  Call: nc_pub.LocalCall,\n  // FORWARDED GENERIC PHASE MACHINE\n  SystemHook: PhaseMachine.QueueHookFor,\n  // SYSTEM STARTUP\n  SystemStart,\n  SystemStop,\n  // FORWARDED SYSTEM CONTROL VIA UREXEC\n  SystemBoot: URExec.SystemBoot,\n  SystemRun: URExec.SystemRun,\n  SystemRestage: URExec.SystemRestage,\n  SystemReboot: URExec.SystemReboot,\n  SystemUnload: URExec.SystemUnload,\n  // FORWARDED PROMPT UTILITY\n  PrefixUtil: PROMPTS.makeStyleFormatter,\n  SetPromptColor: PROMPTS.setPromptColor,\n  // FORWARDED CLASSES\n  class: {\n    PhaseMachine\n  }\n};\n/* WEBPACK VAR INJECTION */}.call(this, \"src/index-client.js\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgtY2xpZW50LmpzPzAwODgiXSwibmFtZXMiOlsiVVJDaGFubmVsIiwicmVxdWlyZSIsIlVSTmV0IiwiVVJFeGVjIiwiUFJPTVBUUyIsIlBSIiwibWFrZVN0eWxlRm9ybWF0dGVyIiwiUGhhc2VNYWNoaW5lIiwiTUVUQSIsIl9DTElFTlQiLCJfU0NSSVBUIiwiX19maWxlbmFtZSIsIl9WRVJTSU9OIiwiRXZlbnRzIiwiRXh0ZW5zaW9ucyIsIlB1YlN1YiIsIm5jX3N1YiIsIm5jX3B1YiIsIlVSU1lTX1JVTk5JTkciLCJTeXN0ZW1TdGFydCIsImNvbnNvbGUiLCJsb2ciLCJQcm9taXNlIiwicmVqZWN0IiwiUXVldWVIb29rRm9yIiwicmVzb2x2YmUiLCJDb25uZWN0Iiwic3VjY2VzcyIsImZhaWx1cmUiLCJyZXNvbHZlIiwiU3lzdGVtU3RvcCIsIkNsb3NlIiwibW9kdWxlIiwiZXhwb3J0cyIsIlN1YnNjcmliZSIsIlVuc3Vic2NyaWJlIiwiUHVibGlzaCIsIkxvY2FsUHVibGlzaCIsIlNpZ25hbCIsIkxvY2FsU2lnbmFsIiwiQ2FsbCIsIkxvY2FsQ2FsbCIsIlN5c3RlbUhvb2siLCJTeXN0ZW1Cb290IiwiU3lzdGVtUnVuIiwiU3lzdGVtUmVzdGFnZSIsIlN5c3RlbVJlYm9vdCIsIlN5c3RlbVVubG9hZCIsIlByZWZpeFV0aWwiLCJTZXRQcm9tcHRDb2xvciIsInNldFByb21wdENvbG9yIiwiY2xhc3MiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztBQU1BO0FBQ0E7QUFDQSxNQUFNQSxTQUFTLEdBQUdDLG1CQUFPLENBQUMsaURBQUQsQ0FBekI7O0FBQ0EsTUFBTUMsS0FBSyxHQUFHRCxtQkFBTyxDQUFDLGlEQUFELENBQXJCOztBQUNBLE1BQU1FLE1BQU0sR0FBR0YsbUJBQU8sQ0FBQywyQ0FBRCxDQUF0Qjs7QUFDQSxNQUFNRyxPQUFPLEdBQUdILG1CQUFPLENBQUMsNkNBQUQsQ0FBdkI7O0FBRUEsTUFBTUksRUFBRSxH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c291cmNlc0NvbnRlbnQiOlsiLyovLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gQUJPVVQgXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCpcXFxuXG4gIFVSU1lTIENMSUVOVCBNQUlOIEVOVFJZXG5cblxcKlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwgKiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vKi9cblxuLy8vIExJQlJBUklFUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuY29uc3QgVVJDaGFubmVsID0gcmVxdWlyZSgnLi9jbGllbnQtY2hhbm5lbCcpO1xuY29uc3QgVVJOZXQgPSByZXF1aXJlKCcuL2NsaWVudC1uZXR3b3JrJyk7XG5jb25zdCBVUkV4ZWMgPSByZXF1aXJlKCcuL2NsaWVudC1leGVjJyk7XG5jb25zdCBQUk9NUFRTID0gcmVxdWlyZSgnLi91dGlsL3Byb21wdHMnKTtcblxuY29uc3QgUFIgPSBQUk9NUFRTLm1ha2VTdHlsZUZvcm1hdHRlcignVVInKTtcblxuLy8vIENMQVNTRVMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuY29uc3QgUGhhc2VNYWNoaW5lID0gcmVxdWlyZSgnLi9jbGFzcy1waGFzZS1tYWNoaW5lJyk7XG5cbi8vLyBNRVRBIERBVEEgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiB0aGVzZSBwcm9wZXJ0aWVzIGFyZSBleHBvcnRlZCBmcm9tIHRoZSBsaWJyYXJ5IHNvIHlvdSBjYW4gdGVsbCBpZiB0aGVcbiAqICB1ciBpbnN0YW5jZSB5b3UncmUgdXNpbmcgaXMgc2VydmVyc2lkZSBvciBjbGllbnRzaWRlLCBpZiB0aGF0IG5lZWRzXG4gKiAgdG8gYmUgY2hlY2tlZFxuICovXG5jb25zdCBNRVRBID0ge1xuICBfQ0xJRU5UOiB0cnVlLFxuICBfU0NSSVBUOiBfX2ZpbGVuYW1lLFxuICBfVkVSU0lPTjogJzAuMC4xJ1xufTtcblxuLy8vIENMSUVOVC1TSURFIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLy8vIHRvIGJlIGltcGxlbWVudGVkXG5jb25zdCBFdmVudHMgPSB7fTtcbmNvbnN0IEV4dGVuc2lvbnMgPSB7fTtcbmNvbnN0IFB1YlN1YiA9IHt9O1xuXG4vLy8gREVDTEFSQVRJT05TIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5jb25zdCBuY19zdWIgPSBuZXcgVVJDaGFubmVsKCd1cnN5cy1zdWInKTtcbmNvbnN0IG5jX3B1YiA9IG5ldyBVUkNoYW5uZWwoJ3Vyc3lzLXB1YicpO1xubGV0IFVSU1lTX1JVTk5JTkcgPSBmYWxzZTtcblxuLy8vIE1BSU4gQVBJIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIGluaXRpYWxpemUgbW9kdWxlcyB0aGF0IHBhcnRpY2lwYXRlIGluIFVSIEVYRUMgUGhhc2VNYWNoaW5lIGJlZm9yZSBydW5uaW5nXG4gKiAgU3lzdGVtQm9vdCwgd2hpY2ggc3RhcnRzIHRoZSBVUlNZUyBsaWZlY3ljbGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIFN5c3RlbVN0YXJ0KCkge1xuICBpZiAoVVJTWVNfUlVOTklORykge1xuICAgIGNvbnNvbGUubG9nKC4uLlBSKCdTeXN0ZW1TdGFydDogVVJTWVMgYWxyZWFkeSBydW5uaW5nISEhJykpO1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICB9XG4gIC8vIGF1dG9jb25uZWN0IHRvIFVSU1lTIG5ldHdvcmsgZHVyaW5nIE5FVF9DT05ORUNUXG4gIFBoYXNlTWFjaGluZS5RdWV1ZUhvb2tGb3IoXG4gICAgJ1VSJyxcbiAgICAnTkVUX0NPTk5FQ1QnLFxuICAgICgpID0+XG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2YmUsIHJlamVjdCkgPT5cbiAgICAgICAgVVJOZXQuQ29ubmVjdChuY19zdWIsIHsgc3VjY2VzczogcmVzb2x2YmUsIGZhaWx1cmU6IHJlamVjdCB9KVxuICAgICAgKVxuICApO1xuICBVUlNZU19SVU5OSU5HID0gdHJ1ZTtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufVxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIGRlYWxsb2NhdGUgYW55IHN5c3RlbSByZXNvdXJjZXMgYXNzaWduZWQgZHVyaW5nIEluaXRpYWxpemVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gU3lzdGVtU3RvcCgpIHtcbiAgaWYgKCFVUlNZU19SVU5OSU5HKSB7XG4gICAgY29uc29sZS5sb2coLi4uUFIoJ1N5c3RlbU1vZHVsZXNTdG9wOiBVUlNZUyBpcyBub3QgcnVubmluZyEhIScpKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgLy8gY2xvc2UgdGhlIG5ldHdvcmtcbiAgYXdhaXQgVVJOZXQuQ2xvc2UoKTtcbiAgVVJTWVNfUlVOTklORyA9IGZhbHNlO1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59XG5cbi8vLyBFWFBPUlRTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbm1vZHVsZS5leHBvcnRzID0ge1xuICAuLi5NRVRBLFxuICAvLyBGT1JXQVJERUQgUFVCL1NVQlxuICBTdWJzY3JpYmU6IG5jX3N1Yi5TdWJzY3JpYmUsXG4gIFVuc3Vic2NyaWJlOiBuY19zdWIuVW5zdWJzY3JpYmUsXG4gIFB1Ymxpc2g6IG5jX3B1Yi5Mb2NhbFB1Ymxpc2gsXG4gIFNpZ25hbDogbmNfcHViLkxvY2FsU2lnbmFsLFxuICBDYWxsOiBuY19wdWIuTG9jYWxDYWxsLFxuICAvLyBGT1JXQVJERUQgR0VORVJJQyBQSEFTRSBNQUNISU5FXG4gIFN5c3RlbUhvb2s6IFBoYXNlTWFjaGluZS5RdWV1ZUhvb2tGb3IsXG4gIC8vIFNZU1RFTSBTVEFSVFVQXG4gIFN5c3RlbVN0YXJ0LFxuICBTeXN0ZW1TdG9wLFxuICAvLyBGT1JXQVJERUQgU1lTVEVNIENPTlRST0wgVklBIFVSRVhFQ1xuICBTeXN0ZW1Cb290OiBVUkV4ZWMuU3lzdGVtQm9vdCxcbiAgU3lzdGVtUnVuOiBVUkV4ZWMuU3lzdGVtUnVuLFxuICBTeXN0ZW1SZXN0YWdlOiBVUkV4ZWMuU3lzdGVtUmVzdGFnZSxcbiAgU3lzdGVtUmVib290OiBVUkV4ZWMuU3lzdGVtUmVib290LFxuICBTeXN0ZW1VbmxvYWQ6IFVSRXhlYy5TeXN0ZW1VbmxvYWQsXG4gIC8vIEZPUldBUkRFRCBQUk9NUFQgVVRJTElUWVxuICBQcmVmaXhVdGlsOiBQUk9NUFRTLm1ha2VTdHlsZUZvcm1hdHRlcixcbiAgU2V0UHJvbXB0Q29sb3I6IFBST01QVFMuc2V0UHJvbXB0Q29sb3IsXG4gIC8vIEZPUldBUkRFRCBDTEFTU0VTXG4gIGNsYXNzOiB7IFBoYXNlTWFjaGluZSB9XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index-client.js\n");

/***/ }),

/***/ "./src/util/prompts.js":
/*!*****************************!*\
  !*** ./src/util/prompts.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*///////////////////////////////// ABOUT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\n\n  ANSI TERMINAL color codes and utilities\n\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ * /////////////////////////////////////*/\nconst IS_NODE = typeof window === 'undefined';\nconst DEFAULT_PADDING = IS_NODE ? 10 // nodejs\n: 0; // not nodejs\n\nconst DEFAULT_COLOR = 'TagGray';\nconst CSS_PAD = 'padding:3px 5px;border-radius:2px';\nconst CSS_TAB = '4px';\nconst TERM_COLORS = {\n  // TOUT = makeTerminalOut(str); TOUT('hi')\n  Reset: '\\x1b[0m',\n  Bright: '\\x1b[1m',\n  Dim: '\\x1b[2m',\n  Underscore: '\\x1b[4m',\n  Blink: '\\x1b[5m',\n  Reverse: '\\x1b[7m',\n  Hidden: '\\x1b[8m',\n  //\n  Black: '\\x1b[30m',\n  White: '\\x1b[37m',\n  Red: '\\x1b[31m',\n  Yellow: '\\x1b[33m',\n  Green: '\\x1b[32m',\n  Cyan: '\\x1b[36m',\n  Blue: '\\x1b[34m',\n  Magenta: '\\x1b[35m',\n  //\n  BgBlack: '\\x1b[40m',\n  BgRed: '\\x1b[41m',\n  BgYellow: '\\x1b[43m',\n  BgCyan: '\\x1b[46m',\n  BgGreen: '\\x1b[42m',\n  BgBlue: '\\x1b[44m',\n  BgPurple: '\\x1b[45m',\n  BgWhite: '\\x1b[47m',\n  //\n  TagYellow: '\\x1b[43;30m',\n  TagRed: '\\x1b[41;37m',\n  TagGreen: '\\x1b[42;37m',\n  TagCyan: '\\x1b[46;37m',\n  TagBlue: '\\x1b[43;37m',\n  TagPurple: '\\x1b[45;37m',\n  TagPink: '\\x1b[95;30m',\n  TagGray: '\\x1b[2;37m',\n  TagNull: 'color:#999'\n}; // NAME LIST MUST MATCH TERM_COLORS!\n\nconst CSS_COLORS = {\n  Reset: 'color:auto;background-color:auto',\n  // COLOR FOREGROUND\n  Black: 'color:black',\n  White: 'color:white',\n  Red: 'color:red',\n  Yellow: 'color:orange',\n  Green: 'color:green',\n  Cyan: 'color:cyan',\n  Blue: 'color:blue',\n  Magenta: 'color:magenta',\n  // COLOR BACKGROUND\n  TagRed: `color:#000;background-color:#f66;${CSS_PAD}`,\n  TagYellow: `color:#000;background-color:#fd4;${CSS_PAD}`,\n  TagGreen: `color:#000;background-color:#5c8;${CSS_PAD}`,\n  TagCyan: `color:#000;background-color:#2dd;${CSS_PAD}`,\n  TagBlue: `color:#000;background-color:#2bf;${CSS_PAD}`,\n  TagPurple: `color:#000;background-color:#b6f;${CSS_PAD}`,\n  TagPink: `color:#000;background-color:#f9f;${CSS_PAD}`,\n  TagGray: `color:#999;border:1px solid #ddd;${CSS_PAD}`,\n  TagNull: 'color:#999',\n  // COLOR BACKGROUND DARK\n  TagDkRed: `color:white;background-color:red;${CSS_PAD}`,\n  TagDkGreen: `color:white;background-color:green;${CSS_PAD}`,\n  TagDkBlue: `color:white;background-color:blue;${CSS_PAD}`\n}; /// OUTPUT CONTROL ////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** define\n */\n\nconst SHOW = true;\nconst HIDE = false; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst PROMPT_DICT = {\n  // URSYS-RELATED MODULES\n  'UR': [SHOW, 'TagRed'],\n  // SERVERS\n  'APPSRV': [SHOW, 'Yellow'],\n  'GEMSRV': [SHOW, 'Yellow'],\n  // SPECIAL\n  '-': [SHOW, 'TagNull']\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** add a color to the PROMPT_DICT for a particular PREFIX */\n\nfunction m_SetPromptColors(match, color = DEFAULT_COLOR) {\n  if (typeof match !== 'string') throw Error('match prompt must be string');\n  match = match.trim();\n  if (match === '') throw Error('match prompt cannot be empty');\n  let colorTable = IS_NODE ? TERM_COLORS : CSS_COLORS;\n  let validColor = false;\n  validColor = colorTable[color] !== undefined;\n  if (!validColor) throw Error(`prompt color ${color} is not defined`); // turn on color prompt\n\n  PROMPT_DICT[match] = [true, color];\n  return colorTable;\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Based on current detected enviroment, return either ANSI terminal or\n *  css based color markers for use in debugging messages. If tagColor is\n *  defined and corresponds to color definition, it is used to set the color.\n *  This is so users can set their own color prompts without editing\n *  PROMPTS_DICT structure.\n */\n\n\nfunction m_GetEnvColor(prompt, tagColor) {\n  const colorTable = m_SetPromptColors(prompt, tagColor);\n  const [dbg_mode, defcol] = PROMPT_DICT[prompt.trim()] || [SHOW, DEFAULT_COLOR];\n  const ucolor = colorTable[tagColor];\n  const dcolor = colorTable[defcol];\n  const color = ucolor || dcolor;\n  const reset = colorTable.Reset;\n  return [dbg_mode, color, reset];\n} /// API METHODS ///////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Pad string to fixed length, with default padding depending on\n *  whether the environment is node or browser\n */\n\n\nfunction padString(str, padding = DEFAULT_PADDING) {\n  let len = str.length;\n  if (IS_NODE) return `${str.padEnd(padding, ' ')}`; // must be non-node environment, so do dynamic string adjust\n\n  if (padding === 0) return `${str}`; // if this far, then we're truncating\n\n  if (len >= padding) str = str.substr(0, padding - 1);else str.padEnd(padding, ' ');\n  return `${str}`;\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Return a function that will prompt strings for you. The function will\n *  returns an array to destructure into console.log().\n *\n *  To create the function, provide a short PROMPT. This will be color coded\n *  according to the PROMPTS_DICT table, or gray otherwise. You can turn off the\n *  debug output for all PROMPTS in a category also for centralized debug\n *  statement control.\n *\n *  The prompt function accepts a string followed by any number of parameters.\n *  It returns an array of values that are destructured inside of console.log()\n *    const promptFunction = makeLoginHelper('APP');\n *    console.log(...promptFunction('huzzah'));\n *\n *  NOTE: This doesn't work as expected on NodeJS, because empty arrays\n *  render as linefeeds so we just output it regardless. If you want to\n *  disable output, use the makeTerminalOut() function instead.\n */\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** allow modification of the PROMPT_DICT\n */\n\n\nfunction makeStyleFormatter(prompt, tagColor) {\n  const [dbg, color, reset] = m_GetEnvColor(prompt, tagColor); // return empty array if debugging disabled in browser\n  // or debugging is enabled but it's node (de morgan's law)\n\n  if (!(dbg || IS_NODE)) return () => []; // return the appropriate array to deconstructr\n\n  const wrap = IS_NODE ? (str, ...args) => {\n    return [`${color}${padString(prompt)}${reset}   ${str}`, ...args]; // server\n  } : (str, ...args) => {\n    return [`%c${padString(prompt)}%c ${str}`, color, reset, ...args]; // browser\n  };\n  return wrap;\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Function to directly print to console instead of returning an array. This\n *  works better for NodeJS since the empty [] still results in output unlike\n *  the browser. Use makeStyleFormatter for browsers\n */\n\n\nfunction makeTerminalOut(prompt, tagColor) {\n  const [dbg, color, reset] = m_GetEnvColor(prompt, tagColor);\n  if (!dbg) return () => {};\n  const wrap = IS_NODE ? (str, ...args) => {\n    console.log(`${color}${padString(prompt)}${reset} - ${str}`, ...args);\n  } : (str, ...args) => {\n    console.log(`%c${padString(prompt)}%c ${str}`, color, reset, ...args);\n  };\n  return wrap;\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Print all Tag Colors\n */\n\n\nfunction printTagColors() {\n  const colortable = IS_NODE ? TERM_COLORS : CSS_COLORS;\n  const colors = Object.keys(colortable).filter(element => element.includes('Tag'));\n  const reset = colortable.Reset;\n  const out = 'dbg_colors';\n  if (!IS_NODE) console.groupCollapsed(out);\n  colors.forEach(key => {\n    const color = colortable[key];\n    const items = IS_NODE ? [`${padString(out)} - (node) ${color}${key}${reset}`] : [`(browser) %c${key}%c`, color, reset];\n    console.log(...items);\n  });\n  if (!IS_NODE) console.groupEnd();\n} /// MODULE EXPORTS ////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nmodule.exports = {\n  TERM: TERM_COLORS,\n  CSS: CSS_COLORS,\n  padString,\n  makeStyleFormatter,\n  makeTerminalOut,\n  printTagColors,\n  m_SetPromptColors\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9wcm9tcHRzLmpzPzkxNTAiXSwibmFtZXMiOlsiSVNfTk9ERSIsIndpbmRvdyIsIkRFRkFVTFRfUEFERElORyIsIkRFRkFVTFRfQ09MT1IiLCJDU1NfUEFEIiwiQ1NTX1RBQiIsIlRFUk1fQ09MT1JTIiwiUmVzZXQiLCJCcmlnaHQiLCJEaW0iLCJVbmRlcnNjb3JlIiwiQmxpbmsiLCJSZXZlcnNlIiwiSGlkZGVuIiwiQmxhY2siLCJXaGl0ZSIsIlJlZCIsIlllbGxvdyIsIkdyZWVuIiwiQ3lhbiIsIkJsdWUiLCJNYWdlbnRhIiwiQmdCbGFjayIsIkJnUmVkIiwiQmdZZWxsb3ciLCJCZ0N5YW4iLCJCZ0dyZWVuIiwiQmdCbHVlIiwiQmdQdXJwbGUiLCJCZ1doaXRlIiwiVGFnWWVsbG93IiwiVGFnUmVkIiwiVGFnR3JlZW4iLCJUYWdDeWFuIiwiVGFnQmx1ZSIsIlRhZ1B1cnBsZSIsIlRhZ1BpbmsiLCJUYWdHcmF5IiwiVGFnTnVsbCIsIkNTU19DT0xPUlMiLCJUYWdEa1JlZCIsIlRhZ0RrR3JlZW4iLCJUYWdEa0JsdWUiLCJTSE9XIiwiSElERSIsIlBST01QVF9ESUNUIiwibV9TZXRQcm9tcHRDb2xvcnMiLCJtYXRjaCIsImNvbG9yIiwiRXJyb3IiLCJ0cmltIiwiY29sb3JUYWJsZSIsInZhbGlkQ29sb3IiLCJ1bmRlZmluZWQiLCJtX0dldEVudkNvbG9yIiwicHJvbXB0IiwidGFnQ29sb3IiLCJkYmdfbW9kZSIsImRlZmNvbCIsInVjb2xvciIsImRjb2xvciIsInJlc2V0IiwicGFkU3RyaW5nIiwic3RyIiwicGFkZGluZyIsImxlbiIsImxlbmd0aCIsInBhZEVuZCIsInN1YnN0ciIsIm1ha2VTdHlsZUZvcm1hdHRlciIsImRiZyIsIndyYXAiLCJhcmdzIiwibWFrZVRlcm1pbmFsT3V0IiwiY29uc29sZSIsImxvZyIsInByaW50VGFnQ29sb3JzIiwiY29sb3J0YWJsZSIsImNvbG9ycyIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJlbGVtZW50IiwiaW5jbHVkZXMiLCJvdXQiLCJncm91cENvbGxhcHNlZCIsImZvckVhY2giLCJrZXkiLCJpdGVtcyIsImdyb3VwRW5kIiwibW9kdWxlIiwiZXhwb3J0cyIsIlRFUk0iLCJDU1MiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztBQU1BLE1BQU1BLE9BQU8sR0FBRyxPQUFPQyxNQUFQLEtBQWtCLFdBQWxDO0FBQ0EsTUFBTUMsZUFBZSxHQUFHRixPQUFPLEdBQzNCLEVBRDJCLENBQ3hCO0FBRHdCLEVBRTNCLENBRkosQyxDQUVPOztBQUNQLE1BQU1HLGFBQWEsR0FBRyxTQUF0QjtBQUNBLE1BQU1DLE9BQU8sR0FBRyxtQ0FBaEI7QUFDQSxNQUFNQyxPQUFPLEdBQUcsS0FBaEI7QUFFQSxNQUFNQyxXQUFXLEdBQUc7QUFDbEI7QUFDQUMsT0FBSyxFQUFFLFNBRlc7QUFHbEJDLFFBQU0sRUFBRSxTQUhVO0FBSWxCQyxLQUFHLEVBQUUsU0FKYTtBQUtsQkMsWUFBVSxFQUFFLFNBTE07QUFNbEJDLE9BQUssRUFBRSxTQU5XO0FBT2xCQyxTQUFPLEVBQUUsU0FQUztBQVFsQkMsUUFBTSxFQUFFLFNBUlU7QUFTbEI7QUFDQUMsT0FBSyxFQUFFLFVBVlc7QUFXbEJDLE9BQUssRUFBRSxVQVhXO0FBWWxCQyxLQUFHLEVBQUUsVUFaYTtBQWFsQkMsUUFBTSxFQUFFLFVBYlU7QUFjbEJDLE9BQUssRUFBRSxVQWRXO0FBZWxCQyxNQUFJLEVBQUUsVUFmWTtBQWdCbEJDLE1BQUksRUFBRSxVQWhCWTtBQWlCbEJDLFNBQU8sRUFBRSxVQWpCUztBQWtCbEI7QUFDQUMsU0FBTyxFQUFFLFVBbkJTO0FBb0JsQkMsT0FBSyxFQUFFLFVBcEJXO0FBcUJsQkMsVUFBUSxFQUFFLFVBckJRO0FBc0JsQkMsUUFBTSxFQUFFLFVBdEJVO0FBdUJsQkMsU0FBTyxFQUFFLFVBdkJTO0FBd0JsQkMsUUFBTSxFQUFFLFVBeEJVO0FBeUJsQkMsVUFBUSxFQUFFLFVBekJRO0FBMEJsQkMsU0FBTyxFQUFFLFVBMUJTO0FB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QUdBYSxXQUFPLENBQUNDLEdBQVIsQ0FBWSxHQUFHYSxLQUFmO0FBQ0QsR0FORDtBQU9BLE1BQUksQ0FBQ3hGLE9BQUwsRUFBYzBFLE9BQU8sQ0FBQ2UsUUFBUjtBQUNmLEMsQ0FFRDtBQUNBOzs7QUFDQUMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBQ2ZDLE1BQUksRUFBRXRGLFdBRFM7QUFFZnVGLEtBQUcsRUFBRXRELFVBRlU7QUFHZnVCLFdBSGU7QUFJZk8sb0JBSmU7QUFLZkksaUJBTGU7QUFNZkcsZ0JBTmU7QUFPZjlCO0FBUGUsQ0FBakIiLCJmaWxlIjoiLi9zcmMvdXRpbC9wcm9tcHRzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyovLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gQUJPVVQgXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCpcXFxuXG4gIEFOU0kgVEVSTUlOQUwgY29sb3IgY29kZXMgYW5kIHV0aWxpdGllc1xuXG5cXCpcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcICogLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyovXG5cbmNvbnN0IElTX05PREUgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbmNvbnN0IERFRkFVTFRfUEFERElORyA9IElTX05PREVcbiAgPyAxMCAvLyBub2RlanNcbiAgOiAwOyAvLyBub3Qgbm9kZWpzXG5jb25zdCBERUZBVUxUX0NPTE9SID0gJ1RhZ0dyYXknO1xuY29uc3QgQ1NTX1BBRCA9ICdwYWRkaW5nOjNweCA1cHg7Ym9yZGVyLXJhZGl1czoycHgnO1xuY29uc3QgQ1NTX1RBQiA9ICc0cHgnO1xuXG5jb25zdCBURVJNX0NPTE9SUyA9IHtcbiAgLy8gVE9VVCA9IG1ha2VUZXJtaW5hbE91dChzdHIpOyBUT1VUKCdoaScpXG4gIFJlc2V0OiAnXFx4MWJbMG0nLFxuICBCcmlnaHQ6ICdcXHgxYlsxbScsXG4gIERpbTogJ1xceDFiWzJtJyxcbiAgVW5kZXJzY29yZTogJ1xceDFiWzRtJyxcbiAgQmxpbms6ICdcXHgxYls1bScsXG4gIFJldmVyc2U6ICdcXHgxYls3bScsXG4gIEhpZGRlbjogJ1xceDFiWzhtJyxcbiAgLy9cbiAgQmxhY2s6ICdcXHgxYlszMG0nLFxuICBXaGl0ZTogJ1xceDFiWzM3bScsXG4gIFJlZDogJ1xceDFiWzMxbScsXG4gIFllbGxvdzogJ1xceDFiWzMzbScsXG4gIEdyZWVuOiAnXFx4MWJbMzJtJyxcbiAgQ3lhbjogJ1xceDFiWzM2bScsXG4gIEJsdWU6ICdcXHgxYlszNG0nLFxuICBNYWdlbnRhOiAnXFx4MWJbMzVtJyxcbiAgLy9cbiAgQmdCbGFjazogJ1xceDFiWzQwbScsXG4gIEJnUmVkOiAnXFx4MWJbNDFtJyxcbiAgQmdZZWxsb3c6ICdcXHgxYls0M20nLFxuICBCZ0N5YW46ICdcXHgxYls0Nm0nLFxuICBCZ0dyZWVuOiAnXFx4MWJbNDJtJyxcbiAgQmdCbHVlOiAnXFx4MWJbNDRtJyxcbiAgQmdQdXJwbGU6ICdcXHgxYls0NW0nLFxuICBCZ1doaXRlOiAnXFx4MWJbNDdtJyxcbiAgLy9cbiAgVGFnWWVsbG93OiAnXFx4MWJbNDM7MzBtJyxcbiAgVGFnUmVkOiAnXFx4MWJbNDE7MzdtJyxcbiAgVGFnR3JlZW46ICdcXHgxYls0MjszN20nLFxuICBUYWdDeWFuOiAnXFx4MWJbNDY7MzdtJyxcbiAgVGFnQmx1ZTogJ1xceDFiWzQzOzM3bScsXG4gIFRhZ1B1cnBsZTogJ1xceDFiWzQ1OzM3bScsXG4gIFRhZ1Bpbms6ICdcXHgxYls5NTszMG0nLFxuICBUYWdHcmF5OiAnXFx4MWJbMjszN20nLFxuICBUYWdOdWxsOiAnY29sb3I6Izk5OSdcbn07XG5cbi8vIE5BTUUgTElTVCBNVVNUIE1BVENIIFRFUk1fQ09MT1JTIVxuY29uc3QgQ1NTX0NPTE9SUyA9IHtcbiAgUmVzZXQ6ICdjb2xvcjphdXRvO2JhY2tncm91bmQtY29sb3I6YXV0bycsXG4gIC8vIENPTE9SIEZPUkVHUk9VTkRcbiAgQmxhY2s6ICdjb2xvcjpibGFjaycsXG4gIFdoaXRlOiAnY29sb3I6d2hpdGUnLFxuICBSZWQ6ICdjb2xvcjpyZWQnLFxuICBZZWxsb3c6ICdjb2xvcjpvcmFuZ2UnLFxuICBHcmVlbjogJ2NvbG9yOmdyZWVuJyxcbiAgQ3lhbjogJ2NvbG9yOmN5YW4nLFxuICBCbHVlOiAnY29sb3I6Ymx1ZScsXG4gIE1hZ2VudGE6ICdjb2xvcjptYWdlbnRhJyxcbiAgLy8gQ09MT1IgQkFDS0dST1VORFxuICBUYWdSZWQ6IGBjb2xvcjojMDAwO2JhY2tncm91bmQtY29sb3I6I2Y2Njske0NTU19QQUR9YCxcbiAgVGFnWWVsbG93OiBgY29sb3I6IzAwMDtiYWNrZ3JvdW5kLWNvbG9yOiNmZDQ7JHtDU1NfUEFEfWAsXG4gIFRhZ0dyZWVuOiBgY29sb3I6IzAwMDtiYWNrZ3JvdW5kLWNvbG9yOiM1Yzg7JHtDU1NfUEFEfWAsXG4gIFRhZ0N5YW46IGBjb2xvcjojMDAwO2JhY2tncm91bmQtY29sb3I6IzJkZDske0NTU19QQUR9YCxcbiAgVGFnQmx1ZTogYGNvbG9yOiMwMDA7YmFja2dyb3VuZC1jb2xvcjojMmJmOyR7Q1NTX1BBRH1gLFxuICBUYWdQdXJwbGU6IGBjb2xvcjojMDAwO2JhY2tncm91bmQtY29sb3I6I2I2Zjske0NTU19QQUR9YCxcbiAgVGFnUGluazogYGNvbG9yOiMwMDA7YmFja2dyb3VuZC1jb2xvcjojZjlmOyR7Q1NTX1BBRH1gLFxuICBUYWdHcmF5OiBgY29sb3I6Izk5OTtib3JkZXI6MXB4IHNvbGlkICNkZGQ7JHtDU1NfUEFEfWAsXG4gIFRhZ051bGw6ICdjb2xvcjojOTk5JyxcbiAgLy8gQ09MT1IgQkFDS0dST1VORCBEQVJLXG4gIFRhZ0RrUmVkOiBgY29sb3I6d2hpdGU7YmFja2dyb3VuZC1jb2xvcjpyZWQ7JHtDU1NfUEFEfWAsXG4gIFRhZ0RrR3JlZW46IGBjb2xvcjp3aGl0ZTtiYWNrZ3JvdW5kLWNvbG9yOmdyZWVuOyR7Q1NTX1BBRH1gLFxuICBUYWdEa0JsdWU6IGBjb2xvcjp3aGl0ZTtiYWNrZ3JvdW5kLWNvbG9yOmJsdWU7JHtDU1NfUEFEfWBcbn07XG5cbi8vLyBPVVRQVVQgQ09OVFJPTCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBkZWZpbmVcbiAqL1xuY29uc3QgU0hPVyA9IHRydWU7XG5jb25zdCBISURFID0gZmFsc2U7XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5jb25zdCBQUk9NUFRfRElDVCA9IHtcbiAgLy8gVVJTWVMtUkVMQVRFRCBNT0RVTEVTXG4gICdVUic6IFtTSE9XLCAnVGFnUmVkJ10sXG4gIC8vIFNFUlZFUlNcbiAgJ0FQUFNSVic6IFtTSE9XLCAnWWVsbG93J10sXG4gICdHRU1TUlYnOiBbU0hPVywgJ1llbGxvdyddLFxuICAvLyBTUEVDSUFMXG4gICctJzogW1NIT1csICdUYWdOdWxsJ11cbn07XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogYWRkIGEgY29sb3IgdG8gdGhlIFBST01QVF9ESUNUIGZvciBhIHBhcnRpY3VsYXIgUFJFRklYICovXG5mdW5jdGlvbiBtX1NldFByb21wdENvbG9ycyhtYXRjaCwgY29sb3IgPSBERUZBVUxUX0NPTE9SKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggIT09ICdzdHJpbmcnKSB0aHJvdyBFcnJvcignbWF0Y2ggcHJvbXB0IG11c3QgYmUgc3RyaW5nJyk7XG4gIG1hdGNoID0gbWF0Y2gudHJpbSgpO1xuICBpZiAobWF0Y2ggPT09ICcnKSB0aHJvdyBFcnJvcignbWF0Y2ggcHJvbXB0IGNhbm5vdCBiZSBlbXB0eScpO1xuICBsZXQgY29sb3JUYWJsZSA9IElTX05PREUgPyBURVJNX0NPTE9SUyA6IENTU19DT0xPUlM7XG4gIGxldCB2YWxpZENvbG9yID0gZmFsc2U7XG4gIHZhbGlkQ29sb3IgPSBjb2xvclRhYmxlW2NvbG9yXSAhPT0gdW5kZWZpbmVkO1xuICBpZiAoIXZhbGlkQ29sb3IpIHRocm93IEVycm9yKGBwcm9tcHQgY29sb3IgJHtjb2xvcn0gaXMgbm90IGRlZmluZWRgKTtcbiAgLy8gdHVybiBvbiBjb2xvciBwcm9tcHRcbiAgUFJPTVBUX0RJQ1RbbWF0Y2hdID0gW3RydWUsIGNvbG9yXTtcbiAgcmV0dXJuIGNvbG9yVGFibGU7XG59XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogQmFzZWQgb24gY3VycmVudCBkZXRlY3RlZCBlbnZpcm9tZW50LCByZXR1cm4gZWl0aGVyIEFOU0kgdGVybWluYWwgb3JcbiAqICBjc3MgYmFzZWQgY29sb3IgbWFya2VycyBmb3IgdXNlIGluIGRlYnVnZ2luZyBtZXNzYWdlcy4gSWYgdGFnQ29sb3IgaXNcbiAqICBkZWZpbmVkIGFuZCBjb3JyZXNwb25kcyB0byBjb2xvciBkZWZpbml0aW9uLCBpdCBpcyB1c2VkIHRvIHNldCB0aGUgY29sb3IuXG4gKiAgVGhpcyBpcyBzbyB1c2VycyBjYW4gc2V0IHRoZWlyIG93biBjb2xvciBwcm9tcHRzIHdpdGhvdXQgZWRpdGluZ1xuICogIFBST01QVFNfRElDVCBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG1fR2V0RW52Q29sb3IocHJvbXB0LCB0YWdDb2xvcikge1xuICBjb25zdCBjb2xvclRhYmxlID0gbV9TZXRQcm9tcHRDb2xvcnMocHJvbXB0LCB0YWdDb2xvcik7XG4gIGNvbnN0IFtkYmdfbW9kZSwgZGVmY29sXSA9IFBST01QVF9ESUNUW3Byb21wdC50cmltKCldIHx8IFtTSE9XLCBERUZBVUxUX0NPTE9SXTtcbiAgY29uc3QgdWNvbG9yID0gY29sb3JUYWJsZVt0YWdDb2xvcl07XG4gIGNvbnN0IGRjb2xvciA9IGNvbG9yVGFibGVbZGVmY29sXTtcbiAgY29uc3QgY29sb3IgPSB1Y29sb3IgfHwgZGNvbG9yO1xuICBjb25zdCByZXNldCA9IGNvbG9yVGFibGUuUmVzZXQ7XG4gIHJldHVybiBbZGJnX21vZGUsIGNvbG9yLCByZXNldF07XG59XG5cbi8vLyBBUEkgTUVUSE9EUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBQYWQgc3RyaW5nIHRvIGZpeGVkIGxlbmd0aCwgd2l0aCBkZWZhdWx0IHBhZGRpbmcgZGVwZW5kaW5nIG9uXG4gKiAgd2hldGhlciB0aGUgZW52aXJvbm1lbnQgaXMgbm9kZSBvciBicm93c2VyXG4gKi9cbmZ1bmN0aW9uIHBhZFN0cmluZyhzdHIsIHBhZGRpbmcgPSBERUZBVUxUX1BBRERJTkcpIHtcbiAgbGV0IGxlbiA9IHN0ci5sZW5ndGg7XG4gIGlmIChJU19OT0RFKSByZXR1cm4gYCR7c3RyLnBhZEVuZChwYWRkaW5nLCAnICcpfWA7XG4gIC8vIG11c3QgYmUgbm9uLW5vZGUgZW52aXJvbm1lbnQsIHNvIGRvIGR5bmFtaWMgc3RyaW5nIGFkanVzdFxuICBpZiAocGFkZGluZyA9PT0gMCkgcmV0dXJuIGAke3N0cn1gO1xuICAvLyBpZiB0aGlzIGZhciwgdGhlbiB3ZSdyZSB0cnVuY2F0aW5nXG4gIGlmIChsZW4gPj0gcGFkZGluZykgc3RyID0gc3RyLnN1YnN0cigwLCBwYWRkaW5nIC0gMSk7XG4gIGVsc2Ugc3RyLnBhZEVuZChwYWRkaW5nLCAnICcpO1xuICByZXR1cm4gYCR7c3RyfWA7XG59XG5cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJvbXB0IHN0cmluZ3MgZm9yIHlvdS4gVGhlIGZ1bmN0aW9uIHdpbGxcbiAqICByZXR1cm5zIGFuIGFycmF5IHRvIGRlc3RydWN0dXJlIGludG8gY29uc29sZS5sb2coKS5cbiAqXG4gKiAgVG8gY3JlYXRlIHRoZSBmdW5jdGlvbiwgcHJvdmlkZSBhIHNob3J0IFBST01QVC4gVGhpcyB3aWxsIGJlIGNvbG9yIGNvZGVkXG4gKiAgYWNjb3JkaW5nIHRvIHRoZSBQUk9NUFRTX0RJQ1QgdGFibGUsIG9yIGdyYXkgb3RoZXJ3aXNlLiBZb3UgY2FuIHR1cm4gb2ZmIHRoZVxuICogIGRlYnVnIG91dHB1dCBmb3IgYWxsIFBST01QVFMgaW4gYSBjYXRlZ29yeSBhbHNvIGZvciBjZW50cmFsaXplZCBkZWJ1Z1xuICogIHN0YXRlbWVudCBjb250cm9sLlxuICpcbiAqICBUaGUgcHJvbXB0IGZ1bmN0aW9uIGFjY2VwdHMgYSBzdHJpbmcgZm9sbG93ZWQgYnkgYW55IG51bWJlciBvZiBwYXJhbWV0ZXJzLlxuICogIEl0IHJldHVybnMgYW4gYXJyYXkgb2YgdmFsdWVzIHRoYXQgYXJlIGRlc3RydWN0dXJlZCBpbnNpZGUgb2YgY29uc29sZS5sb2coKVxuICogICAgY29uc3QgcHJvbXB0RnVuY3Rpb24gPSBtYWtlTG9naW5IZWxwZXIoJ0FQUCcpO1xuICogICAgY29uc29sZS5sb2coLi4ucHJvbXB0RnVuY3Rpb24oJ2h1enphaCcpKTtcbiAqXG4gKiAgTk9URTogVGhpcyBkb2Vzbid0IHdvcmsgYXMgZXhwZWN0ZWQgb24gTm9kZUpTLCBiZWNhdXNlIGVtcHR5IGFycmF5c1xuICogIHJlbmRlciBhcyBsaW5lZmVlZHMgc28gd2UganVzdCBvdXRwdXQgaXQgcmVnYXJkbGVzcy4gSWYgeW91IHdhbnQgdG9cbiAqICBkaXNhYmxlIG91dHB1dCwgdXNlIHRoZSBtYWtlVGVybWluYWxPdXQoKSBmdW5jdGlvbiBpbnN0ZWFkLlxuICovXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogYWxsb3cgbW9kaWZpY2F0aW9uIG9mIHRoZSBQUk9NUFRfRElDVFxuICovXG5mdW5jdGlvbiBtYWtlU3R5bGVGb3JtYXR0ZXIocHJvbXB0LCB0YWdDb2xvcikge1xuICBjb25zdCBbZGJnLCBjb2xvciwgcmVzZXRdID0gbV9HZXRFbnZDb2xvcihwcm9tcHQsIHRhZ0NvbG9yKTtcbiAgLy8gcmV0dXJuIGVtcHR5IGFycmF5IGlmIGRlYnVnZ2luZyBkaXNhYmxlZCBpbiBicm93c2VyXG4gIC8vIG9yIGRlYnVnZ2luZyBpcyBlbmFibGVkIGJ1dCBpdCdzIG5vZGUgKGRlIG1vcmdhbidzIGxhdylcbiAgaWYgKCEoZGJnIHx8IElTX05PREUpKSByZXR1cm4gKCkgPT4gW107XG4gIC8vIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgYXJyYXkgdG8gZGVjb25zdHJ1Y3RyXG4gIGNvbnN0IHdyYXAgPSBJU19OT0RFXG4gICAgPyAoc3RyLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIHJldHVybiBbYCR7Y29sb3J9JHtwYWRTdHJpbmcocHJvbXB0KX0ke3Jlc2V0fSAgICR7c3RyfWAsIC4uLmFyZ3NdOyAvLyBzZXJ2ZXJcbiAgICAgIH1cbiAgICA6IChzdHIsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgcmV0dXJuIFtgJWMke3BhZFN0cmluZyhwcm9tcHQpfSVjICR7c3RyfWAsIGNvbG9yLCByZXNldCwgLi4uYXJnc107IC8vIGJyb3dzZXJcbiAgICAgIH07XG4gIHJldHVybiB3cmFwO1xufVxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIEZ1bmN0aW9uIHRvIGRpcmVjdGx5IHByaW50IHRvIGNvbnNvbGUgaW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gYXJyYXkuIFRoaXNcbiAqICB3b3JrcyBiZXR0ZXIgZm9yIE5vZGVKUyBzaW5jZSB0aGUgZW1wdHkgW10gc3RpbGwgcmVzdWx0cyBpbiBvdXRwdXQgdW5saWtlXG4gKiAgdGhlIGJyb3dzZXIuIFVzZSBtYWtlU3R5bGVGb3JtYXR0ZXIgZm9yIGJyb3dzZXJzXG4gKi9cbmZ1bmN0aW9uIG1ha2VUZXJtaW5hbE91dChwcm9tcHQsIHRhZ0NvbG9yKSB7XG4gIGNvbnN0IFtkYmcsIGNvbG9yLCByZXNldF0gPSBtX0dldEVudkNvbG9yKHByb21wdCwgdGFnQ29sb3IpO1xuICBpZiAoIWRiZykgcmV0dXJuICgpID0+IHt9O1xuICBjb25zdCB3cmFwID0gSVNfTk9ERVxuICAgID8gKHN0ciwgLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhgJHtjb2xvcn0ke3BhZFN0cmluZyhwcm9tcHQpfSR7cmVzZXR9IC0gJHtzdHJ9YCwgLi4uYXJncyk7XG4gICAgICB9XG4gICAgOiAoc3RyLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAlYyR7cGFkU3RyaW5nKHByb21wdCl9JWMgJHtzdHJ9YCwgY29sb3IsIHJlc2V0LCAuLi5hcmdzKTtcbiAgICAgIH07XG4gIHJldHVybiB3cmFwO1xufVxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIFByaW50IGFsbCBUYWcgQ29sb3JzXG4gKi9cbmZ1bmN0aW9uIHByaW50VGFnQ29sb3JzKCkge1xuICBjb25zdCBjb2xvcnRhYmxlID0gSVNfTk9ERSA/IFRFUk1fQ09MT1JTIDogQ1NTX0NPTE9SUztcbiAgY29uc3QgY29sb3JzID0gT2JqZWN0LmtleXMoY29sb3J0YWJsZSkuZmlsdGVyKGVsZW1lbnQgPT5cbiAgICBlbGVtZW50LmluY2x1ZGVzKCdUYWcnKVxuICApO1xuICBjb25zdCByZXNldCA9IGNvbG9ydGFibGUuUmVzZXQ7XG4gIGNvbnN0IG91dCA9ICdkYmdfY29sb3JzJztcbiAgaWYgKCFJU19OT0RFKSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKG91dCk7XG4gIGNvbG9ycy5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3QgY29sb3IgPSBjb2xvcnRhYmxlW2tleV07XG4gICAgY29uc3QgaXRlbXMgPSBJU19OT0RFXG4gICAgICA/IFtgJHtwYWRTdHJpbmcob3V0KX0gLSAobm9kZSkgJHtjb2xvcn0ke2tleX0ke3Jlc2V0fWBdXG4gICAgICA6IFtgKGJyb3dzZXIpICVjJHtrZXl9JWNgLCBjb2xvciwgcmVzZXRdO1xuICAgIGNvbnNvbGUubG9nKC4uLml0ZW1zKTtcbiAgfSk7XG4gIGlmICghSVNfTk9ERSkgY29uc29sZS5ncm91cEVuZCgpO1xufVxuXG4vLy8gTU9EVUxFIEVYUE9SVFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVEVSTTogVEVSTV9DT0xPUlMsXG4gIENTUzogQ1NTX0NPTE9SUyxcbiAgcGFkU3RyaW5nLFxuICBtYWtlU3R5bGVGb3JtYXR0ZXIsXG4gIG1ha2VUZXJtaW5hbE91dCxcbiAgcHJpbnRUYWdDb2xvcnMsXG4gIG1fU2V0UHJvbXB0Q29sb3JzXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/util/prompts.js\n");

/***/ })

/******/ });
});