/*//////////////////////////////// ABOUT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\

  Manifest Read/Write Routines

\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ * //////////////////////////////////////*/

const Path = require('path');
const fetch = require('node-fetch').default;
const FILE = require('./files');
const HTTP = require('./http');
const DCODE = require('./decoders');

const {
  GS_MANIFEST_FILENAME,
  GS_ASSETS_PATH,
  GS_ASSETS_ROUTE
} = require('../../../../gsgo-settings');

const PROMPTS = require('./prompts');

/// CONSTANTS & DECLARATIONS //////////////////////////////////////////////////
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const TERM = PROMPTS.makeTerminalOut('U-MFEST', 'TagGreen');
const ASSET_ID_START = 100;
const DBG = false;
let m_assetPath = GS_ASSETS_PATH;
let m_remoteAssetUrl;

/// MODULE HELPERS ////////////////////////////////////////////////////////////
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/** return true if the url returns OK or exists
 *  call using async/await syntax
 */
async function m_ResourceExists(url) {
  try {
    const { ok } = await fetch(url, { method: 'HEAD' });
    return ok;
  } catch (e) {
    return false;
  }
}
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function m_ScanAssets(dirpath) {
  const subdir = dirpath.substring(dirpath.lastIndexOf('/') + 1);
  // get valid media files
  const mediafiles = FILE.GetFiles(dirpath).filter(f =>
    FILE.HasValidAssetExtension({ type: subdir, filename: f })
  );
  if (DBG) TERM(`... ${subdir} has ${mediafiles.length} valid files`);

  const jsonfiles = mediafiles.filter(
    f => Path.extname(f).toLowerCase() === '.json'
  );
  if (DBG)
    TERM(`... ${subdir} has ${jsonfiles.length} json files to scan for images`);

  const spriteFiles = [];
  jsonfiles.forEach(f => {
    const file = FILE.ReadJSON(`${dirpath}/${f}`);
    const { meta, frames } = file;
    if (meta && meta.image) spriteFiles.push(meta.image);
    if (frames && Array.isArray(frames))
      for (let frame of frames)
        if (frame.filename) spriteFiles.push(frame.filenam);
  });
  if (DBG) TERM(`... jsonfiles contained ${spriteFiles.length} image references`);
  return { mediafiles, jsonfiles, spriteFiles };
}
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function m_PromiseHashes(dirpath, files) {
  const promises = [];
  for (const f of files) {
    const p = Path.join(dirpath, f);
    promises.push(FILE.PromiseFileHash(p));
  }
  return promises;
}
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function m_GetManifestDataArray(dirpath) {
  const allfiles = FILE.GetFiles(dirpath);
  const manifests = allfiles
    .filter(f => f.startsWith(GS_MANIFEST_FILENAME) && f.endsWith('.json'))
    .sort();

  // CASE 1: 1 OR MORE MANIFEST FILES
  if (manifests.length > 0) {
    if (DBG) TERM('... manifest files:', manifests);
    const m = [];
    for (let f of manifests) {
      const json = FILE.ReadJSON(`${dirpath}/${f}`);
      m.push(json);
    }
    return m;
  }
  return [];
}

/// PUBLIC METHODS ////////////////////////////////////////////////////////////
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function SetAssetPath(path = GS_ASSETS_PATH) {
  m_assetPath = path;
}
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function SetRemoteAssetUrl(url) {
  m_remoteAssetUrl = url;
}
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/** Attempt to read manifest at given URL. Return a single JSON object
 *  if autogenerated, or an array of JSON objects otherwise
 */
async function ReadManifest(url) {
  const i = url.indexOf('?manifest');
  // if (i === url.length - 9) {/* manifest string found */}
  if (i < 0) url = `${url}?manifest`;
  try {
    const manifestExists = await m_ResourceExists(url);
    if (!manifestExists) return undefined;
    let json = await fetch(url).then(res => res.json());
    // could be array of objs (manifest files) or obj (autogenerated manifest)
    return json;
  } catch (e) {
    return undefined;
  }
}
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/** extract list of urls to download from a manifest, return as array of
 *  url strings
 */
function ExtractResourceUrls(manifest) {
  // just run over all entries and pull the assetUrl
  const assets = [];
  const fields = Object.entries(manifest);
  for (const [asType, asList] of fields) {
    for (const { assetUrl } of asList) {
      if (assetUrl) assets.push(assetUrl);
    }
  }
  // these paths are relative to the containing directory
  return assets;
}
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
async function DeliverManifest(req, res, next) {
  // (0) define output object to capture data
  const manifest = {};
  const { fullURL, baseURL, pathname, searchParams } = DCODE.DecodeRequest(req);
  // (2) if has ?manifest query, do special processing
  const path = Path.join(m_assetPath, pathname); // doesn't include /assets
  const pathInfo = DCODE.DecodePath(path);

  // SKIP FOR: no manifest request
  if (!searchParams.has('manifest')) {
    // TERM('SKIP: no manifest param');
    next();
    return;
  }
  // SKIP FOR: manifest request for a file, not dir
  if (pathInfo.isFile) {
    const err = `${fullURL} appears to be a file request, not a directory`;
    TERM(err);
    res.status(400).send(err);
    return;
  }
  // if we got here, then our synthesized path is a directory
  // manifest request and directory exists
  if (FILE.DirectoryExists(path)) {
    if (DBG) TERM('return manifest for', path, 'from local');
    // CASE 1: are there manifest files?
    const mdata = m_GetManifestDataArray(path);
    if (mdata.length > 0) {
      res.json(mdata);
      return;
    }
    // case 2: autogenerate
    let assetcounter = ASSET_ID_START;
    const assetdirs = FILE.GetAssetDirs(path);
    if (assetdirs.length === 0) {
      const base = Path.basename(m_assetPath);
      const refpath = `${base}/${GS_ASSETS_ROUTE}${pathname}`;
      TERM(`WARN: ${refpath} does not seem to be an asset directory`);
    }
    // step through every found asset type in directory
    for (const subdir of assetdirs) {
      if (DBG) TERM('... scanning', subdir);
      const subdirpath = Path.join(path, subdir);
      // get valid media files & jsonfiles subsets
      const { mediafiles, jsonfiles, spriteFiles } = m_ScanAssets(subdirpath);
      // only load hard png assets
      const files = mediafiles.filter(f => !spriteFiles.includes(f));
      const promises = m_PromiseHashes(subdirpath, files);
      // - - - - - - - -
      //
      // eslint-disable-next-line no-await-in-loop
      const filesInfo = await Promise.all(promises);
      //
      // - - - - - - - -
      const entries = [];
      for (let info of filesInfo) {
        const assetId = assetcounter++;
        const { filename, ext: assetType, hash } = info;
        const asset = {
          assetId,
          assetName: filename,
          assetUrl: `${subdir}/${filename}`,
          assetType,
          hash
        };
        entries.push(asset);
      }
      manifest[subdir] = entries;
    } // end subdir processing
    // send result of automanifest
    res.json(manifest);
    return;
  }
  // CASE 3: manifest request & directory DOES NOT exist
  // premature abort
  if (!m_remoteAssetUrl) {
    TERM('SKIP PROXY: no remote asset URL defined');
    next();
    return;
  }
  const url = `${m_remoteAssetUrl}/${GS_ASSETS_ROUTE}${pathname}`;
  const remoteDirExists = await HTTP.HTTPResourceExists(url);
  if (!remoteDirExists) {
    TERM(`SKIP PROXY: ${url} does not exist on host`);
    next();
    return;
  }
  if (pathInfo.isDir) {
    let json = await ReadManifest(url);
    if (!json) {
      TERM('manifest', url, 'could not be read');
      next();
      return;
    }
    // was the manifest a file? then also write it to dir

    if (Array.isArray(json)) {
      // only read the first loaded manifest
      json = json.shift();
      const mpath = Path.join(path, `${GS_MANIFEST_FILENAME}.json`);
      FILE.EnsureDirectory(path);
      FILE.WriteJSON(mpath, json, err => {
        if (err) TERM('error:', err);
      });
    }
    TERM('cached remote manifest from', pathname);

    // if we got this far, then we have a good manifest json
    const assets = ExtractResourceUrls(json);
    const promises = [];
    const f_err = err => {
      if (err) TERM('err proxy dl', err);
    };
    for (const asset of assets) {
      const remoteUrl = `${url}/${asset}`; // note that when dir?manifest, there is a missing slash so we have to insert it
      const newPath = `${path}/${asset}`;
      promises.push(HTTP.DownloadUrlToPath(remoteUrl, newPath, f_err));
    }
    //
    //
    await Promise.all(promises);
    //
    //
    next();
  }
}

/// EXPORT MODULE /////////////////////////////////////////////////////////////
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
module.exports = {
  ReadManifest,
  ExtractResourceUrls,
  DeliverManifest,
  SetRemoteAssetUrl,
  SetAssetPath
};
