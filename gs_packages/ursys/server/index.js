(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index-server.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/bufferutil/fallback.js":
/*!*******************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/bufferutil/fallback.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nconst mask = (source, mask, output, offset, length) => {\n  for (var i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n};\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nconst unmask = (buffer, mask) => {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n  for (var i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n};\n\nmodule.exports = { mask, unmask };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2J1ZmZlcnV0aWwvZmFsbGJhY2suanM/ODIwZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9idWZmZXJ1dGlsL2ZhbGxiYWNrLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBzb3VyY2UgVGhlIGJ1ZmZlciB0byBtYXNrXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBvdXRwdXQgVGhlIGJ1ZmZlciB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgd3JpdGluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIG1hc2suXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IG1hc2sgPSAoc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSA9PiB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBzb3VyY2VbaV0gXiBtYXNrW2kgJiAzXTtcbiAgfVxufTtcblxuLyoqXG4gKiBVbm1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byB1bm1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHB1YmxpY1xuICovXG5jb25zdCB1bm1hc2sgPSAoYnVmZmVyLCBtYXNrKSA9PiB7XG4gIC8vIFJlcXVpcmVkIHVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvOTAwNiBpcyByZXNvbHZlZC5cbiAgY29uc3QgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGJ1ZmZlcltpXSBePSBtYXNrW2kgJiAzXTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IG1hc2ssIHVubWFzayB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/bufferutil/fallback.js\n");

/***/ }),

/***/ "../../node_modules/bufferutil/index.js":
/*!****************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/bufferutil/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__dirname) {\n\ntry {\n  module.exports = __webpack_require__(/*! node-gyp-build */ \"../../node_modules/node-gyp-build/index.js\")(__dirname);\n} catch (e) {\n  module.exports = __webpack_require__(/*! ./fallback */ \"../../node_modules/bufferutil/fallback.js\");\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, \"../../node_modules/bufferutil\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2J1ZmZlcnV0aWwvaW5kZXguanM/MjU1ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpREFBYTs7QUFFYjtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLGtFQUFnQjtBQUMzQyxDQUFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsNkRBQVk7QUFDdkMiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2J1ZmZlcnV0aWwvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbm9kZS1neXAtYnVpbGQnKShfX2Rpcm5hbWUpO1xufSBjYXRjaCAoZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFsbGJhY2snKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/bufferutil/index.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/copy-sync/copy-sync.js":
/*!********************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/copy-sync/copy-sync.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdirpSync = __webpack_require__(/*! ../mkdirs */ \"../../node_modules/fs-extra/lib/mkdirs/index.js\").mkdirsSync\nconst utimesSync = __webpack_require__(/*! ../util/utimes.js */ \"../../node_modules/fs-extra/lib/util/utimes.js\").utimesMillisSync\nconst stat = __webpack_require__(/*! ../util/stat */ \"../../node_modules/fs-extra/lib/util/stat.js\")\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy')\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\n  return handleFilterAndCopy(destStat, src, dest, opts)\n}\n\nfunction handleFilterAndCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirpSync(destParent)\n  return startCopy(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  if (typeof fs.copyFileSync === 'function') {\n    fs.copyFileSync(src, dest)\n    fs.chmodSync(dest, srcStat.mode)\n    if (opts.preserveTimestamps) {\n      return utimesSync(dest, srcStat.atime, srcStat.mtime)\n    }\n    return\n  }\n  return copyFileFallback(srcStat, src, dest, opts)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts) {\n  const BUF_LENGTH = 64 * 1024\n  const _buff = __webpack_require__(/*! ../util/buffer */ \"../../node_modules/fs-extra/lib/util/buffer.js\")(BUF_LENGTH)\n\n  const fdr = fs.openSync(src, 'r')\n  const fdw = fs.openSync(dest, 'w', srcStat.mode)\n  let pos = 0\n\n  while (pos < srcStat.size) {\n    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts)\n  if (destStat && !destStat.isDirectory()) {\n    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n  }\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return fs.chmodSync(dest, srcStat.mode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy')\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\nmodule.exports = copySync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5LXN5bmMvY29weS1zeW5jLmpzP2NmMjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLGtFQUFhO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixtQkFBbUIsbUJBQU8sQ0FBQyxrRUFBVztBQUN0QyxtQkFBbUIsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDOUMsYUFBYSxtQkFBTyxDQUFDLGtFQUFjOztBQUVuQztBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7O0FBRUEsU0FBUyxvQkFBb0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQWdCOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdURBQXVELEtBQUssb0JBQW9CLElBQUk7QUFDcEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWSxrQ0FBa0MsYUFBYTtBQUNqRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhLFVBQVUsWUFBWTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHktc3luYy9jb3B5LXN5bmMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpcnBTeW5jID0gcmVxdWlyZSgnLi4vbWtkaXJzJykubWtkaXJzU3luY1xuY29uc3QgdXRpbWVzU3luYyA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbWVzLmpzJykudXRpbWVzTWlsbGlzU3luY1xuY29uc3Qgc3RhdCA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmZ1bmN0aW9uIGNvcHlTeW5jIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0cyA9IHsgZmlsdGVyOiBvcHRzIH1cbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9XG4gIG9wdHMuY2xvYmJlciA9ICdjbG9iYmVyJyBpbiBvcHRzID8gISFvcHRzLmNsb2JiZXIgOiB0cnVlIC8vIGRlZmF1bHQgdG8gdHJ1ZSBmb3Igbm93XG4gIG9wdHMub3ZlcndyaXRlID0gJ292ZXJ3cml0ZScgaW4gb3B0cyA/ICEhb3B0cy5vdmVyd3JpdGUgOiBvcHRzLmNsb2JiZXIgLy8gb3ZlcndyaXRlIGZhbGxzIGJhY2sgdG8gY2xvYmJlclxuXG4gIC8vIFdhcm4gYWJvdXQgdXNpbmcgcHJlc2VydmVUaW1lc3RhbXBzIG9uIDMyLWJpdCBub2RlXG4gIGlmIChvcHRzLnByZXNlcnZlVGltZXN0YW1wcyAmJiBwcm9jZXNzLmFyY2ggPT09ICdpYTMyJykge1xuICAgIGNvbnNvbGUud2FybihgZnMtZXh0cmE6IFVzaW5nIHRoZSBwcmVzZXJ2ZVRpbWVzdGFtcHMgb3B0aW9uIGluIDMyLWJpdCBub2RlIGlzIG5vdCByZWNvbW1lbmRlZDtcXG5cbiAgICBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pwcmljaGFyZHNvbi9ub2RlLWZzLWV4dHJhL2lzc3Vlcy8yNjlgKVxuICB9XG5cbiAgY29uc3QgeyBzcmNTdGF0LCBkZXN0U3RhdCB9ID0gc3RhdC5jaGVja1BhdGhzU3luYyhzcmMsIGRlc3QsICdjb3B5JylcbiAgc3RhdC5jaGVja1BhcmVudFBhdGhzU3luYyhzcmMsIHNyY1N0YXQsIGRlc3QsICdjb3B5JylcbiAgcmV0dXJuIGhhbmRsZUZpbHRlckFuZENvcHkoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gaGFuZGxlRmlsdGVyQW5kQ29weSAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAob3B0cy5maWx0ZXIgJiYgIW9wdHMuZmlsdGVyKHNyYywgZGVzdCkpIHJldHVyblxuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5kaXJuYW1lKGRlc3QpXG4gIGlmICghZnMuZXhpc3RzU3luYyhkZXN0UGFyZW50KSkgbWtkaXJwU3luYyhkZXN0UGFyZW50KVxuICByZXR1cm4gc3RhcnRDb3B5KGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29weSAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAob3B0cy5maWx0ZXIgJiYgIW9wdHMuZmlsdGVyKHNyYywgZGVzdCkpIHJldHVyblxuICByZXR1cm4gZ2V0U3RhdHMoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdHMgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3Qgc3RhdFN5bmMgPSBvcHRzLmRlcmVmZXJlbmNlID8gZnMuc3RhdFN5bmMgOiBmcy5sc3RhdFN5bmNcbiAgY29uc3Qgc3JjU3RhdCA9IHN0YXRTeW5jKHNyYylcblxuICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gb25EaXIoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgZWxzZSBpZiAoc3JjU3RhdC5pc0ZpbGUoKSB8fFxuICAgICAgICAgICBzcmNTdGF0LmlzQ2hhcmFjdGVyRGV2aWNlKCkgfHxcbiAgICAgICAgICAgc3JjU3RhdC5pc0Jsb2NrRGV2aWNlKCkpIHJldHVybiBvbkZpbGUoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgZWxzZSBpZiAoc3JjU3RhdC5pc1N5bWJvbGljTGluaygpKSByZXR1cm4gb25MaW5rKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIG9uRmlsZSAoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAoIWRlc3RTdGF0KSByZXR1cm4gY29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICByZXR1cm4gbWF5Q29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBtYXlDb3B5RmlsZSAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmIChvcHRzLm92ZXJ3cml0ZSkge1xuICAgIGZzLnVubGlua1N5bmMoZGVzdClcbiAgICByZXR1cm4gY29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICB9IGVsc2UgaWYgKG9wdHMuZXJyb3JPbkV4aXN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHtkZXN0fScgYWxyZWFkeSBleGlzdHNgKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBmcy5jb3B5RmlsZVN5bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmcy5jb3B5RmlsZVN5bmMoc3JjLCBkZXN0KVxuICAgIGZzLmNobW9kU3luYyhkZXN0LCBzcmNTdGF0Lm1vZGUpXG4gICAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzKSB7XG4gICAgICByZXR1cm4gdXRpbWVzU3luYyhkZXN0LCBzcmNTdGF0LmF0aW1lLCBzcmNTdGF0Lm10aW1lKVxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICByZXR1cm4gY29weUZpbGVGYWxsYmFjayhzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIGNvcHlGaWxlRmFsbGJhY2sgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBjb25zdCBCVUZfTEVOR1RIID0gNjQgKiAxMDI0XG4gIGNvbnN0IF9idWZmID0gcmVxdWlyZSgnLi4vdXRpbC9idWZmZXInKShCVUZfTEVOR1RIKVxuXG4gIGNvbnN0IGZkciA9IGZzLm9wZW5TeW5jKHNyYywgJ3InKVxuICBjb25zdCBmZHcgPSBmcy5vcGVuU3luYyhkZXN0LCAndycsIHNyY1N0YXQubW9kZSlcbiAgbGV0IHBvcyA9IDBcblxuICB3aGlsZSAocG9zIDwgc3JjU3RhdC5zaXplKSB7XG4gICAgY29uc3QgYnl0ZXNSZWFkID0gZnMucmVhZFN5bmMoZmRyLCBfYnVmZiwgMCwgQlVGX0xFTkdUSCwgcG9zKVxuICAgIGZzLndyaXRlU3luYyhmZHcsIF9idWZmLCAwLCBieXRlc1JlYWQpXG4gICAgcG9zICs9IGJ5dGVzUmVhZFxuICB9XG5cbiAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzKSBmcy5mdXRpbWVzU3luYyhmZHcsIHNyY1N0YXQuYXRpbWUsIHNyY1N0YXQubXRpbWUpXG5cbiAgZnMuY2xvc2VTeW5jKGZkcilcbiAgZnMuY2xvc2VTeW5jKGZkdylcbn1cblxuZnVuY3Rpb24gb25EaXIgKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKCFkZXN0U3RhdCkgcmV0dXJuIG1rRGlyQW5kQ29weShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIGlmIChkZXN0U3RhdCAmJiAhZGVzdFN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSBub24tZGlyZWN0b3J5ICcke2Rlc3R9JyB3aXRoIGRpcmVjdG9yeSAnJHtzcmN9Jy5gKVxuICB9XG4gIHJldHVybiBjb3B5RGlyKHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gbWtEaXJBbmRDb3B5IChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgZnMubWtkaXJTeW5jKGRlc3QpXG4gIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzKVxuICByZXR1cm4gZnMuY2htb2RTeW5jKGRlc3QsIHNyY1N0YXQubW9kZSlcbn1cblxuZnVuY3Rpb24gY29weURpciAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGZzLnJlYWRkaXJTeW5jKHNyYykuZm9yRWFjaChpdGVtID0+IGNvcHlEaXJJdGVtKGl0ZW0sIHNyYywgZGVzdCwgb3B0cykpXG59XG5cbmZ1bmN0aW9uIGNvcHlEaXJJdGVtIChpdGVtLCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3Qgc3JjSXRlbSA9IHBhdGguam9pbihzcmMsIGl0ZW0pXG4gIGNvbnN0IGRlc3RJdGVtID0gcGF0aC5qb2luKGRlc3QsIGl0ZW0pXG4gIGNvbnN0IHsgZGVzdFN0YXQgfSA9IHN0YXQuY2hlY2tQYXRoc1N5bmMoc3JjSXRlbSwgZGVzdEl0ZW0sICdjb3B5JylcbiAgcmV0dXJuIHN0YXJ0Q29weShkZXN0U3RhdCwgc3JjSXRlbSwgZGVzdEl0ZW0sIG9wdHMpXG59XG5cbmZ1bmN0aW9uIG9uTGluayAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBsZXQgcmVzb2x2ZWRTcmMgPSBmcy5yZWFkbGlua1N5bmMoc3JjKVxuICBpZiAob3B0cy5kZXJlZmVyZW5jZSkge1xuICAgIHJlc29sdmVkU3JjID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlc29sdmVkU3JjKVxuICB9XG5cbiAgaWYgKCFkZXN0U3RhdCkge1xuICAgIHJldHVybiBmcy5zeW1saW5rU3luYyhyZXNvbHZlZFNyYywgZGVzdClcbiAgfSBlbHNlIHtcbiAgICBsZXQgcmVzb2x2ZWREZXN0XG4gICAgdHJ5IHtcbiAgICAgIHJlc29sdmVkRGVzdCA9IGZzLnJlYWRsaW5rU3luYyhkZXN0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZGVzdCBleGlzdHMgYW5kIGlzIGEgcmVndWxhciBmaWxlIG9yIGRpcmVjdG9yeSxcbiAgICAgIC8vIFdpbmRvd3MgbWF5IHRocm93IFVOS05PV04gZXJyb3IuIElmIGRlc3QgYWxyZWFkeSBleGlzdHMsXG4gICAgICAvLyBmcyB0aHJvd3MgZXJyb3IgYW55d2F5LCBzbyBubyBuZWVkIHRvIGd1YXJkIGFnYWluc3QgaXQgaGVyZS5cbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VJTlZBTCcgfHwgZXJyLmNvZGUgPT09ICdVTktOT1dOJykgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHJlc29sdmVkU3JjLCBkZXN0KVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGlmIChvcHRzLmRlcmVmZXJlbmNlKSB7XG4gICAgICByZXNvbHZlZERlc3QgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVzb2x2ZWREZXN0KVxuICAgIH1cbiAgICBpZiAoc3RhdC5pc1NyY1N1YmRpcihyZXNvbHZlZFNyYywgcmVzb2x2ZWREZXN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29weSAnJHtyZXNvbHZlZFNyY30nIHRvIGEgc3ViZGlyZWN0b3J5IG9mIGl0c2VsZiwgJyR7cmVzb2x2ZWREZXN0fScuYClcbiAgICB9XG5cbiAgICAvLyBwcmV2ZW50IGNvcHkgaWYgc3JjIGlzIGEgc3ViZGlyIG9mIGRlc3Qgc2luY2UgdW5saW5raW5nXG4gICAgLy8gZGVzdCBpbiB0aGlzIGNhc2Ugd291bGQgcmVzdWx0IGluIHJlbW92aW5nIHNyYyBjb250ZW50c1xuICAgIC8vIGFuZCB0aGVyZWZvcmUgYSBicm9rZW4gc3ltbGluayB3b3VsZCBiZSBjcmVhdGVkLlxuICAgIGlmIChmcy5zdGF0U3luYyhkZXN0KS5pc0RpcmVjdG9yeSgpICYmIHN0YXQuaXNTcmNTdWJkaXIocmVzb2x2ZWREZXN0LCByZXNvbHZlZFNyYykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSAnJHtyZXNvbHZlZERlc3R9JyB3aXRoICcke3Jlc29sdmVkU3JjfScuYClcbiAgICB9XG4gICAgcmV0dXJuIGNvcHlMaW5rKHJlc29sdmVkU3JjLCBkZXN0KVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHlMaW5rIChyZXNvbHZlZFNyYywgZGVzdCkge1xuICBmcy51bmxpbmtTeW5jKGRlc3QpXG4gIHJldHVybiBmcy5zeW1saW5rU3luYyhyZXNvbHZlZFNyYywgZGVzdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3luY1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/copy-sync/copy-sync.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/copy-sync/index.js":
/*!****************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/copy-sync/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  copySync: __webpack_require__(/*! ./copy-sync */ \"../../node_modules/fs-extra/lib/copy-sync/copy-sync.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5LXN5bmMvaW5kZXguanM/OGRiYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBLFlBQVksbUJBQU8sQ0FBQywyRUFBYTtBQUNqQyIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHktc3luYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29weVN5bmM6IHJlcXVpcmUoJy4vY29weS1zeW5jJylcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/copy-sync/index.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/copy/copy.js":
/*!**********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/copy/copy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdirp = __webpack_require__(/*! ../mkdirs */ \"../../node_modules/fs-extra/lib/mkdirs/index.js\").mkdirs\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"../../node_modules/fs-extra/lib/path-exists/index.js\").pathExists\nconst utimes = __webpack_require__(/*! ../util/utimes */ \"../../node_modules/fs-extra/lib/util/utimes.js\").utimesMillis\nconst stat = __webpack_require__(/*! ../util/stat */ \"../../node_modules/fs-extra/lib/util/stat.js\")\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  stat.checkPaths(src, dest, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {\n      if (err) return cb(err)\n      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)\n      return checkParentDir(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction checkParentDir (destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return startCopy(destStat, src, dest, opts, cb)\n    mkdirp(destParent, err => {\n      if (err) return cb(err)\n      return startCopy(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) return onInclude(destStat, src, dest, opts, cb)\n    return cb()\n  }, error => cb(error))\n}\n\nfunction startCopy (destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)\n  return getStats(destStat, src, dest, opts, cb)\n}\n\nfunction getStats (destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isFile() ||\n             srcStat.isCharacterDevice() ||\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)\n  return mayCopyFile(srcStat, src, dest, opts, cb)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  if (typeof fs.copyFile === 'function') {\n    return fs.copyFile(src, dest, err => {\n      if (err) return cb(err)\n      return setDestModeAndTimestamps(srcStat, dest, opts, cb)\n    })\n  }\n  return copyFileFallback(srcStat, src, dest, opts, cb)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts, cb) {\n  const rs = fs.createReadStream(src)\n  rs.on('error', err => cb(err)).once('open', () => {\n    const ws = fs.createWriteStream(dest, { mode: srcStat.mode })\n    ws.on('error', err => cb(err))\n      .on('open', () => rs.pipe(ws))\n      .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb))\n  })\n}\n\nfunction setDestModeAndTimestamps (srcStat, dest, opts, cb) {\n  fs.chmod(dest, srcStat.mode, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) {\n      return utimes(dest, srcStat.atime, srcStat.mtime, cb)\n    }\n    return cb()\n  })\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts, cb)\n  if (destStat && !destStat.isDirectory()) {\n    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n  }\n  return copyDir(src, dest, opts, cb)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err)\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err)\n      return fs.chmod(dest, srcStat.mode, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  return copyDirItem(items, item, src, dest, opts, cb)\n}\n\nfunction copyDirItem (items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  stat.checkPaths(srcItem, destItem, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { destStat } = stats\n    startCopy(destStat, srcItem, destItem, opts, err => {\n      if (err) return cb(err)\n      return copyDirItems(items, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction onLink (destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err)\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n    }\n\n    if (!destStat) {\n      return fs.symlink(resolvedSrc, dest, cb)\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\n          return cb(err)\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\n        }\n        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\n        }\n        return copyLink(resolvedSrc, dest, cb)\n      })\n    }\n  })\n}\n\nfunction copyLink (resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrc, dest, cb)\n  })\n}\n\nmodule.exports = copy\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5L2NvcHkuanM/OThjMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsa0VBQWE7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxrRUFBVztBQUNsQyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsa0VBQWM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCw0QkFBNEIsS0FBSztBQUNqQyxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHFCQUFxQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUssb0JBQW9CLElBQUk7QUFDeEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFlBQVksa0NBQWtDLGFBQWE7QUFDekc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsYUFBYSxVQUFVLFlBQVk7QUFDdEY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHkvY29weS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlycCA9IHJlcXVpcmUoJy4uL21rZGlycycpLm1rZGlyc1xuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuY29uc3QgdXRpbWVzID0gcmVxdWlyZSgnLi4vdXRpbC91dGltZXMnKS51dGltZXNNaWxsaXNcbmNvbnN0IHN0YXQgPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5mdW5jdGlvbiBjb3B5IChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJyAmJiAhY2IpIHtcbiAgICBjYiA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdHMgPSB7IGZpbHRlcjogb3B0cyB9XG4gIH1cblxuICBjYiA9IGNiIHx8IGZ1bmN0aW9uICgpIHt9XG4gIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgb3B0cy5jbG9iYmVyID0gJ2Nsb2JiZXInIGluIG9wdHMgPyAhIW9wdHMuY2xvYmJlciA6IHRydWUgLy8gZGVmYXVsdCB0byB0cnVlIGZvciBub3dcbiAgb3B0cy5vdmVyd3JpdGUgPSAnb3ZlcndyaXRlJyBpbiBvcHRzID8gISFvcHRzLm92ZXJ3cml0ZSA6IG9wdHMuY2xvYmJlciAvLyBvdmVyd3JpdGUgZmFsbHMgYmFjayB0byBjbG9iYmVyXG5cbiAgLy8gV2FybiBhYm91dCB1c2luZyBwcmVzZXJ2ZVRpbWVzdGFtcHMgb24gMzItYml0IG5vZGVcbiAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzICYmIHByb2Nlc3MuYXJjaCA9PT0gJ2lhMzInKSB7XG4gICAgY29uc29sZS53YXJuKGBmcy1leHRyYTogVXNpbmcgdGhlIHByZXNlcnZlVGltZXN0YW1wcyBvcHRpb24gaW4gMzItYml0IG5vZGUgaXMgbm90IHJlY29tbWVuZGVkO1xcblxuICAgIHNlZSBodHRwczovL2dpdGh1Yi5jb20vanByaWNoYXJkc29uL25vZGUtZnMtZXh0cmEvaXNzdWVzLzI2OWApXG4gIH1cblxuICBzdGF0LmNoZWNrUGF0aHMoc3JjLCBkZXN0LCAnY29weScsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb25zdCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0gPSBzdGF0c1xuICAgIHN0YXQuY2hlY2tQYXJlbnRQYXRocyhzcmMsIHNyY1N0YXQsIGRlc3QsICdjb3B5JywgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICBpZiAob3B0cy5maWx0ZXIpIHJldHVybiBoYW5kbGVGaWx0ZXIoY2hlY2tQYXJlbnREaXIsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgICAgcmV0dXJuIGNoZWNrUGFyZW50RGlyKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNoZWNrUGFyZW50RGlyIChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5kaXJuYW1lKGRlc3QpXG4gIHBhdGhFeGlzdHMoZGVzdFBhcmVudCwgKGVyciwgZGlyRXhpc3RzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoZGlyRXhpc3RzKSByZXR1cm4gc3RhcnRDb3B5KGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIG1rZGlycChkZXN0UGFyZW50LCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiBzdGFydENvcHkoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gaGFuZGxlRmlsdGVyIChvbkluY2x1ZGUsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIFByb21pc2UucmVzb2x2ZShvcHRzLmZpbHRlcihzcmMsIGRlc3QpKS50aGVuKGluY2x1ZGUgPT4ge1xuICAgIGlmIChpbmNsdWRlKSByZXR1cm4gb25JbmNsdWRlKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIHJldHVybiBjYigpXG4gIH0sIGVycm9yID0+IGNiKGVycm9yKSlcbn1cblxuZnVuY3Rpb24gc3RhcnRDb3B5IChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAob3B0cy5maWx0ZXIpIHJldHVybiBoYW5kbGVGaWx0ZXIoZ2V0U3RhdHMsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICByZXR1cm4gZ2V0U3RhdHMoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRzIChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBzdGF0ID0gb3B0cy5kZXJlZmVyZW5jZSA/IGZzLnN0YXQgOiBmcy5sc3RhdFxuICBzdGF0KHNyYywgKGVyciwgc3JjU3RhdCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gb25EaXIoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgZWxzZSBpZiAoc3JjU3RhdC5pc0ZpbGUoKSB8fFxuICAgICAgICAgICAgIHNyY1N0YXQuaXNDaGFyYWN0ZXJEZXZpY2UoKSB8fFxuICAgICAgICAgICAgIHNyY1N0YXQuaXNCbG9ja0RldmljZSgpKSByZXR1cm4gb25GaWxlKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIGVsc2UgaWYgKHNyY1N0YXQuaXNTeW1ib2xpY0xpbmsoKSkgcmV0dXJuIG9uTGluayhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gb25GaWxlIChzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAoIWRlc3RTdGF0KSByZXR1cm4gY29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgcmV0dXJuIG1heUNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIG1heUNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmIChvcHRzLm92ZXJ3cml0ZSkge1xuICAgIGZzLnVubGluayhkZXN0LCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAob3B0cy5lcnJvck9uRXhpc3QpIHtcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKGAnJHtkZXN0fScgYWxyZWFkeSBleGlzdHNgKSlcbiAgfSBlbHNlIHJldHVybiBjYigpXG59XG5cbmZ1bmN0aW9uIGNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2YgZnMuY29weUZpbGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnMuY29weUZpbGUoc3JjLCBkZXN0LCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiBzZXREZXN0TW9kZUFuZFRpbWVzdGFtcHMoc3JjU3RhdCwgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfVxuICByZXR1cm4gY29weUZpbGVGYWxsYmFjayhzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxufVxuXG5mdW5jdGlvbiBjb3B5RmlsZUZhbGxiYWNrIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGNvbnN0IHJzID0gZnMuY3JlYXRlUmVhZFN0cmVhbShzcmMpXG4gIHJzLm9uKCdlcnJvcicsIGVyciA9PiBjYihlcnIpKS5vbmNlKCdvcGVuJywgKCkgPT4ge1xuICAgIGNvbnN0IHdzID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZGVzdCwgeyBtb2RlOiBzcmNTdGF0Lm1vZGUgfSlcbiAgICB3cy5vbignZXJyb3InLCBlcnIgPT4gY2IoZXJyKSlcbiAgICAgIC5vbignb3BlbicsICgpID0+IHJzLnBpcGUod3MpKVxuICAgICAgLm9uY2UoJ2Nsb3NlJywgKCkgPT4gc2V0RGVzdE1vZGVBbmRUaW1lc3RhbXBzKHNyY1N0YXQsIGRlc3QsIG9wdHMsIGNiKSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gc2V0RGVzdE1vZGVBbmRUaW1lc3RhbXBzIChzcmNTdGF0LCBkZXN0LCBvcHRzLCBjYikge1xuICBmcy5jaG1vZChkZXN0LCBzcmNTdGF0Lm1vZGUsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMpIHtcbiAgICAgIHJldHVybiB1dGltZXMoZGVzdCwgc3JjU3RhdC5hdGltZSwgc3JjU3RhdC5tdGltZSwgY2IpXG4gICAgfVxuICAgIHJldHVybiBjYigpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG9uRGlyIChzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAoIWRlc3RTdGF0KSByZXR1cm4gbWtEaXJBbmRDb3B5KHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gIGlmIChkZXN0U3RhdCAmJiAhZGVzdFN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgIHJldHVybiBjYihuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgbm9uLWRpcmVjdG9yeSAnJHtkZXN0fScgd2l0aCBkaXJlY3RvcnkgJyR7c3JjfScuYCkpXG4gIH1cbiAgcmV0dXJuIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzLCBjYilcbn1cblxuZnVuY3Rpb24gbWtEaXJBbmRDb3B5IChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGZzLm1rZGlyKGRlc3QsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb3B5RGlyKHNyYywgZGVzdCwgb3B0cywgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gZnMuY2htb2QoZGVzdCwgc3JjU3RhdC5tb2RlLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjb3B5RGlyIChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGZzLnJlYWRkaXIoc3JjLCAoZXJyLCBpdGVtcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgcmV0dXJuIGNvcHlEaXJJdGVtcyhpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gY29weURpckl0ZW1zIChpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBpdGVtID0gaXRlbXMucG9wKClcbiAgaWYgKCFpdGVtKSByZXR1cm4gY2IoKVxuICByZXR1cm4gY29weURpckl0ZW0oaXRlbXMsIGl0ZW0sIHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIGNvcHlEaXJJdGVtIChpdGVtcywgaXRlbSwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBzcmNJdGVtID0gcGF0aC5qb2luKHNyYywgaXRlbSlcbiAgY29uc3QgZGVzdEl0ZW0gPSBwYXRoLmpvaW4oZGVzdCwgaXRlbSlcbiAgc3RhdC5jaGVja1BhdGhzKHNyY0l0ZW0sIGRlc3RJdGVtLCAnY29weScsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb25zdCB7IGRlc3RTdGF0IH0gPSBzdGF0c1xuICAgIHN0YXJ0Q29weShkZXN0U3RhdCwgc3JjSXRlbSwgZGVzdEl0ZW0sIG9wdHMsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIGNvcHlEaXJJdGVtcyhpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBvbkxpbmsgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGZzLnJlYWRsaW5rKHNyYywgKGVyciwgcmVzb2x2ZWRTcmMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChvcHRzLmRlcmVmZXJlbmNlKSB7XG4gICAgICByZXNvbHZlZFNyYyA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZFNyYylcbiAgICB9XG5cbiAgICBpZiAoIWRlc3RTdGF0KSB7XG4gICAgICByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyYywgZGVzdCwgY2IpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZzLnJlYWRsaW5rKGRlc3QsIChlcnIsIHJlc29sdmVkRGVzdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gZGVzdCBleGlzdHMgYW5kIGlzIGEgcmVndWxhciBmaWxlIG9yIGRpcmVjdG9yeSxcbiAgICAgICAgICAvLyBXaW5kb3dzIG1heSB0aHJvdyBVTktOT1dOIGVycm9yLiBJZiBkZXN0IGFscmVhZHkgZXhpc3RzLFxuICAgICAgICAgIC8vIGZzIHRocm93cyBlcnJvciBhbnl3YXksIHNvIG5vIG5lZWQgdG8gZ3VhcmQgYWdhaW5zdCBpdCBoZXJlLlxuICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VJTlZBTCcgfHwgZXJyLmNvZGUgPT09ICdVTktOT1dOJykgcmV0dXJuIGZzLnN5bWxpbmsocmVzb2x2ZWRTcmMsIGRlc3QsIGNiKVxuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICAgICAgICByZXNvbHZlZERlc3QgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVzb2x2ZWREZXN0KVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0LmlzU3JjU3ViZGlyKHJlc29sdmVkU3JjLCByZXNvbHZlZERlc3QpKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgJyR7cmVzb2x2ZWRTcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke3Jlc29sdmVkRGVzdH0nLmApKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG8gbm90IGNvcHkgaWYgc3JjIGlzIGEgc3ViZGlyIG9mIGRlc3Qgc2luY2UgdW5saW5raW5nXG4gICAgICAgIC8vIGRlc3QgaW4gdGhpcyBjYXNlIHdvdWxkIHJlc3VsdCBpbiByZW1vdmluZyBzcmMgY29udGVudHNcbiAgICAgICAgLy8gYW5kIHRoZXJlZm9yZSBhIGJyb2tlbiBzeW1saW5rIHdvdWxkIGJlIGNyZWF0ZWQuXG4gICAgICAgIGlmIChkZXN0U3RhdC5pc0RpcmVjdG9yeSgpICYmIHN0YXQuaXNTcmNTdWJkaXIocmVzb2x2ZWREZXN0LCByZXNvbHZlZFNyYykpIHtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlICcke3Jlc29sdmVkRGVzdH0nIHdpdGggJyR7cmVzb2x2ZWRTcmN9Jy5gKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weUxpbmsocmVzb2x2ZWRTcmMsIGRlc3QsIGNiKVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNvcHlMaW5rIChyZXNvbHZlZFNyYywgZGVzdCwgY2IpIHtcbiAgZnMudW5saW5rKGRlc3QsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyYywgZGVzdCwgY2IpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/copy/copy.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/copy/index.js":
/*!***********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/copy/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../../node_modules/universalify/index.js\").fromCallback\nmodule.exports = {\n  copy: u(__webpack_require__(/*! ./copy */ \"../../node_modules/fs-extra/lib/copy/copy.js\"))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5L2luZGV4LmpzPzkxNzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosVUFBVSxtQkFBTyxDQUFDLDhEQUFjO0FBQ2hDO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLDREQUFRO0FBQzFCIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29weTogdShyZXF1aXJlKCcuL2NvcHknKSlcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/copy/index.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/empty/index.js":
/*!************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/empty/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../../node_modules/universalify/index.js\").fromCallback\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"../../node_modules/fs-extra/lib/mkdirs/index.js\")\nconst remove = __webpack_require__(/*! ../remove */ \"../../node_modules/fs-extra/lib/remove/index.js\")\n\nconst emptyDir = u(function emptyDir (dir, callback) {\n  callback = callback || function () {}\n  fs.readdir(dir, (err, items) => {\n    if (err) return mkdir.mkdirs(dir, callback)\n\n    items = items.map(item => path.join(dir, item))\n\n    deleteItem()\n\n    function deleteItem () {\n      const item = items.pop()\n      if (!item) return callback()\n      remove.remove(item, err => {\n        if (err) return callback(err)\n        deleteItem()\n      })\n    }\n  })\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch (err) {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbXB0eS9pbmRleC5qcz9mOWMyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFVBQVUsbUJBQU8sQ0FBQyw4REFBYztBQUNoQyxXQUFXLG1CQUFPLENBQUMsa0VBQWE7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyxrRUFBVztBQUNqQyxlQUFlLG1CQUFPLENBQUMsa0VBQVc7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2VtcHR5L2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbWtkaXIgPSByZXF1aXJlKCcuLi9ta2RpcnMnKVxuY29uc3QgcmVtb3ZlID0gcmVxdWlyZSgnLi4vcmVtb3ZlJylcblxuY29uc3QgZW1wdHlEaXIgPSB1KGZ1bmN0aW9uIGVtcHR5RGlyIChkaXIsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge31cbiAgZnMucmVhZGRpcihkaXIsIChlcnIsIGl0ZW1zKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIG1rZGlyLm1rZGlycyhkaXIsIGNhbGxiYWNrKVxuXG4gICAgaXRlbXMgPSBpdGVtcy5tYXAoaXRlbSA9PiBwYXRoLmpvaW4oZGlyLCBpdGVtKSlcblxuICAgIGRlbGV0ZUl0ZW0oKVxuXG4gICAgZnVuY3Rpb24gZGVsZXRlSXRlbSAoKSB7XG4gICAgICBjb25zdCBpdGVtID0gaXRlbXMucG9wKClcbiAgICAgIGlmICghaXRlbSkgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgIHJlbW92ZS5yZW1vdmUoaXRlbSwgZXJyID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgZGVsZXRlSXRlbSgpXG4gICAgICB9KVxuICAgIH1cbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIGVtcHR5RGlyU3luYyAoZGlyKSB7XG4gIGxldCBpdGVtc1xuICB0cnkge1xuICAgIGl0ZW1zID0gZnMucmVhZGRpclN5bmMoZGlyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gbWtkaXIubWtkaXJzU3luYyhkaXIpXG4gIH1cblxuICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGl0ZW0gPSBwYXRoLmpvaW4oZGlyLCBpdGVtKVxuICAgIHJlbW92ZS5yZW1vdmVTeW5jKGl0ZW0pXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbXB0eURpclN5bmMsXG4gIGVtcHR5ZGlyU3luYzogZW1wdHlEaXJTeW5jLFxuICBlbXB0eURpcixcbiAgZW1wdHlkaXI6IGVtcHR5RGlyXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/empty/index.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/ensure/file.js":
/*!************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/ensure/file.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../../node_modules/universalify/index.js\").fromCallback\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"../../node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"../../node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction createFile (file, callback) {\n  function makeFile () {\n    fs.writeFile(file, '', err => {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err\n    if (!err && stats.isFile()) return callback()\n    const dir = path.dirname(file)\n    pathExists(dir, (err, dirExists) => {\n      if (err) return callback(err)\n      if (dirExists) return makeFile()\n      mkdir.mkdirs(dir, err => {\n        if (err) return callback(err)\n        makeFile()\n      })\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  let stats\n  try {\n    stats = fs.statSync(file)\n  } catch (e) {}\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: u(createFile),\n  createFileSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvZmlsZS5qcz9lNGI0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFVBQVUsbUJBQU8sQ0FBQyw4REFBYztBQUNoQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGtFQUFhO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxrRUFBVztBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBZ0I7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL2ZpbGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5cbmZ1bmN0aW9uIGNyZWF0ZUZpbGUgKGZpbGUsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIG1ha2VGaWxlICgpIHtcbiAgICBmcy53cml0ZUZpbGUoZmlsZSwgJycsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgY2FsbGJhY2soKVxuICAgIH0pXG4gIH1cblxuICBmcy5zdGF0KGZpbGUsIChlcnIsIHN0YXRzKSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaGFuZGxlLWNhbGxiYWNrLWVyclxuICAgIGlmICghZXJyICYmIHN0YXRzLmlzRmlsZSgpKSByZXR1cm4gY2FsbGJhY2soKVxuICAgIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuICAgIHBhdGhFeGlzdHMoZGlyLCAoZXJyLCBkaXJFeGlzdHMpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBpZiAoZGlyRXhpc3RzKSByZXR1cm4gbWFrZUZpbGUoKVxuICAgICAgbWtkaXIubWtkaXJzKGRpciwgZXJyID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgbWFrZUZpbGUoKVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWxlU3luYyAoZmlsZSkge1xuICBsZXQgc3RhdHNcbiAgdHJ5IHtcbiAgICBzdGF0cyA9IGZzLnN0YXRTeW5jKGZpbGUpXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIGlmIChzdGF0cyAmJiBzdGF0cy5pc0ZpbGUoKSkgcmV0dXJuXG5cbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG4gIGlmICghZnMuZXhpc3RzU3luYyhkaXIpKSB7XG4gICAgbWtkaXIubWtkaXJzU3luYyhkaXIpXG4gIH1cblxuICBmcy53cml0ZUZpbGVTeW5jKGZpbGUsICcnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlRmlsZTogdShjcmVhdGVGaWxlKSxcbiAgY3JlYXRlRmlsZVN5bmNcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/ensure/file.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/ensure/index.js":
/*!*************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/ensure/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst file = __webpack_require__(/*! ./file */ \"../../node_modules/fs-extra/lib/ensure/file.js\")\nconst link = __webpack_require__(/*! ./link */ \"../../node_modules/fs-extra/lib/ensure/link.js\")\nconst symlink = __webpack_require__(/*! ./symlink */ \"../../node_modules/fs-extra/lib/ensure/symlink.js\")\n\nmodule.exports = {\n  // file\n  createFile: file.createFile,\n  createFileSync: file.createFileSync,\n  ensureFile: file.createFile,\n  ensureFileSync: file.createFileSync,\n  // link\n  createLink: link.createLink,\n  createLinkSync: link.createLinkSync,\n  ensureLink: link.createLink,\n  ensureLinkSync: link.createLinkSync,\n  // symlink\n  createSymlink: symlink.createSymlink,\n  createSymlinkSync: symlink.createSymlinkSync,\n  ensureSymlink: symlink.createSymlink,\n  ensureSymlinkSync: symlink.createSymlinkSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvaW5kZXguanM/ZWJjOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixhQUFhLG1CQUFPLENBQUMsOERBQVE7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLDhEQUFRO0FBQzdCLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFXOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZpbGUgPSByZXF1aXJlKCcuL2ZpbGUnKVxuY29uc3QgbGluayA9IHJlcXVpcmUoJy4vbGluaycpXG5jb25zdCBzeW1saW5rID0gcmVxdWlyZSgnLi9zeW1saW5rJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGZpbGVcbiAgY3JlYXRlRmlsZTogZmlsZS5jcmVhdGVGaWxlLFxuICBjcmVhdGVGaWxlU3luYzogZmlsZS5jcmVhdGVGaWxlU3luYyxcbiAgZW5zdXJlRmlsZTogZmlsZS5jcmVhdGVGaWxlLFxuICBlbnN1cmVGaWxlU3luYzogZmlsZS5jcmVhdGVGaWxlU3luYyxcbiAgLy8gbGlua1xuICBjcmVhdGVMaW5rOiBsaW5rLmNyZWF0ZUxpbmssXG4gIGNyZWF0ZUxpbmtTeW5jOiBsaW5rLmNyZWF0ZUxpbmtTeW5jLFxuICBlbnN1cmVMaW5rOiBsaW5rLmNyZWF0ZUxpbmssXG4gIGVuc3VyZUxpbmtTeW5jOiBsaW5rLmNyZWF0ZUxpbmtTeW5jLFxuICAvLyBzeW1saW5rXG4gIGNyZWF0ZVN5bWxpbms6IHN5bWxpbmsuY3JlYXRlU3ltbGluayxcbiAgY3JlYXRlU3ltbGlua1N5bmM6IHN5bWxpbmsuY3JlYXRlU3ltbGlua1N5bmMsXG4gIGVuc3VyZVN5bWxpbms6IHN5bWxpbmsuY3JlYXRlU3ltbGluayxcbiAgZW5zdXJlU3ltbGlua1N5bmM6IHN5bWxpbmsuY3JlYXRlU3ltbGlua1N5bmNcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/ensure/index.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/ensure/link.js":
/*!************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/ensure/link.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../../node_modules/universalify/index.js\").fromCallback\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"../../node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"../../node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction createLink (srcpath, dstpath, callback) {\n  function makeLink (srcpath, dstpath) {\n    fs.link(srcpath, dstpath, err => {\n      if (err) return callback(err)\n      callback(null)\n    })\n  }\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureLink')\n        return callback(err)\n      }\n\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return makeLink(srcpath, dstpath)\n        mkdir.mkdirs(dir, err => {\n          if (err) return callback(err)\n          makeLink(srcpath, dstpath)\n        })\n      })\n    })\n  })\n}\n\nfunction createLinkSync (srcpath, dstpath) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  try {\n    fs.lstatSync(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: u(createLink),\n  createLinkSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvbGluay5qcz8zYTY4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFVBQVUsbUJBQU8sQ0FBQyw4REFBYztBQUNoQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGtFQUFhO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxrRUFBVztBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBZ0I7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9saW5rLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgbWtkaXIgPSByZXF1aXJlKCcuLi9ta2RpcnMnKVxuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuXG5mdW5jdGlvbiBjcmVhdGVMaW5rIChzcmNwYXRoLCBkc3RwYXRoLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBtYWtlTGluayAoc3JjcGF0aCwgZHN0cGF0aCkge1xuICAgIGZzLmxpbmsoc3JjcGF0aCwgZHN0cGF0aCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBjYWxsYmFjayhudWxsKVxuICAgIH0pXG4gIH1cblxuICBwYXRoRXhpc3RzKGRzdHBhdGgsIChlcnIsIGRlc3RpbmF0aW9uRXhpc3RzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICBpZiAoZGVzdGluYXRpb25FeGlzdHMpIHJldHVybiBjYWxsYmFjayhudWxsKVxuICAgIGZzLmxzdGF0KHNyY3BhdGgsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVMaW5rJylcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG4gICAgICBwYXRoRXhpc3RzKGRpciwgKGVyciwgZGlyRXhpc3RzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIGlmIChkaXJFeGlzdHMpIHJldHVybiBtYWtlTGluayhzcmNwYXRoLCBkc3RwYXRoKVxuICAgICAgICBta2Rpci5ta2RpcnMoZGlyLCBlcnIgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgbWFrZUxpbmsoc3JjcGF0aCwgZHN0cGF0aClcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua1N5bmMgKHNyY3BhdGgsIGRzdHBhdGgpIHtcbiAgY29uc3QgZGVzdGluYXRpb25FeGlzdHMgPSBmcy5leGlzdHNTeW5jKGRzdHBhdGgpXG4gIGlmIChkZXN0aW5hdGlvbkV4aXN0cykgcmV0dXJuIHVuZGVmaW5lZFxuXG4gIHRyeSB7XG4gICAgZnMubHN0YXRTeW5jKHNyY3BhdGgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlTGluaycpXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgY29uc3QgZGlyRXhpc3RzID0gZnMuZXhpc3RzU3luYyhkaXIpXG4gIGlmIChkaXJFeGlzdHMpIHJldHVybiBmcy5saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoKVxuICBta2Rpci5ta2RpcnNTeW5jKGRpcilcblxuICByZXR1cm4gZnMubGlua1N5bmMoc3JjcGF0aCwgZHN0cGF0aClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUxpbms6IHUoY3JlYXRlTGluayksXG4gIGNyZWF0ZUxpbmtTeW5jXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/ensure/link.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/ensure/symlink-paths.js":
/*!*********************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/ensure/symlink-paths.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"../../node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        'toCwd': srcpath,\n        'toDst': srcpath\n      })\n    })\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    return pathExists(relativeToDst, (err, exists) => {\n      if (err) return callback(err)\n      if (exists) {\n        return callback(null, {\n          'toCwd': relativeToDst,\n          'toDst': srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, (err) => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            'toCwd': srcpath,\n            'toDst': path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  let exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      'toCwd': srcpath,\n      'toDst': srcpath\n    }\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        'toCwd': relativeToDst,\n        'toDst': srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        'toCwd': srcpath,\n        'toDst': path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvc3ltbGluay1wYXRocy5qcz82ZWFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixXQUFXLG1CQUFPLENBQUMsa0VBQWE7QUFDaEMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQWdCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLXBhdGhzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0d28gdHlwZXMgb2YgcGF0aHMsIG9uZSByZWxhdGl2ZSB0byBzeW1saW5rLCBhbmQgb25lXG4gKiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS4gQ2hlY2tzIGlmIHBhdGggaXMgYWJzb2x1dGUgb3JcbiAqIHJlbGF0aXZlLiBJZiB0aGUgcGF0aCBpcyByZWxhdGl2ZSwgdGhpcyBmdW5jdGlvbiBjaGVja3MgaWYgdGhlIHBhdGggaXNcbiAqIHJlbGF0aXZlIHRvIHN5bWxpbmsgb3IgcmVsYXRpdmUgdG8gY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS4gVGhpcyBpcyBhblxuICogaW5pdGlhdGl2ZSB0byBmaW5kIGEgc21hcnRlciBgc3JjcGF0aGAgdG8gc3VwcGx5IHdoZW4gYnVpbGRpbmcgc3ltbGlua3MuXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gZGV0ZXJtaW5lIHdoaWNoIHBhdGggdG8gdXNlIG91dCBvZiBvbmUgb2YgdGhyZWUgcG9zc2libGVcbiAqIHR5cGVzIG9mIHNvdXJjZSBwYXRocy4gVGhlIGZpcnN0IGlzIGFuIGFic29sdXRlIHBhdGguIFRoaXMgaXMgZGV0ZWN0ZWQgYnlcbiAqIGBwYXRoLmlzQWJzb2x1dGUoKWAuIFdoZW4gYW4gYWJzb2x1dGUgcGF0aCBpcyBwcm92aWRlZCwgaXQgaXMgY2hlY2tlZCB0b1xuICogc2VlIGlmIGl0IGV4aXN0cy4gSWYgaXQgZG9lcyBpdCdzIHVzZWQsIGlmIG5vdCBhbiBlcnJvciBpcyByZXR1cm5lZFxuICogKGNhbGxiYWNrKS8gdGhyb3duIChzeW5jKS4gVGhlIG90aGVyIHR3byBvcHRpb25zIGZvciBgc3JjcGF0aGAgYXJlIGFcbiAqIHJlbGF0aXZlIHVybC4gQnkgZGVmYXVsdCBOb2RlJ3MgYGZzLnN5bWxpbmtgIHdvcmtzIGJ5IGNyZWF0aW5nIGEgc3ltbGlua1xuICogdXNpbmcgYGRzdHBhdGhgIGFuZCBleHBlY3RzIHRoZSBgc3JjcGF0aGAgdG8gYmUgcmVsYXRpdmUgdG8gdGhlIG5ld2x5XG4gKiBjcmVhdGVkIHN5bWxpbmsuIElmIHlvdSBwcm92aWRlIGEgYHNyY3BhdGhgIHRoYXQgZG9lcyBub3QgZXhpc3Qgb24gdGhlIGZpbGVcbiAqIHN5c3RlbSBpdCByZXN1bHRzIGluIGEgYnJva2VuIHN5bWxpbmsuIFRvIG1pbmltaXplIHRoaXMsIHRoZSBmdW5jdGlvblxuICogY2hlY2tzIHRvIHNlZSBpZiB0aGUgJ3JlbGF0aXZlIHRvIHN5bWxpbmsnIHNvdXJjZSBmaWxlIGV4aXN0cywgYW5kIGlmIGl0XG4gKiBkb2VzIGl0IHdpbGwgdXNlIGl0LiBJZiBpdCBkb2VzIG5vdCwgaXQgY2hlY2tzIGlmIHRoZXJlJ3MgYSBmaWxlIHRoYXRcbiAqIGV4aXN0cyB0aGF0IGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LCBpZiBkb2VzIGl0cyB1c2VkLlxuICogVGhpcyBwcmVzZXJ2ZXMgdGhlIGV4cGVjdGF0aW9ucyBvZiB0aGUgb3JpZ2luYWwgZnMuc3ltbGluayBzcGVjIGFuZCBhZGRzXG4gKiB0aGUgYWJpbGl0eSB0byBwYXNzIGluIGByZWxhdGl2ZSB0byBjdXJyZW50IHdvcmtpbmcgZGlyZWNvdHJ5YCBwYXRocy5cbiAqL1xuXG5mdW5jdGlvbiBzeW1saW5rUGF0aHMgKHNyY3BhdGgsIGRzdHBhdGgsIGNhbGxiYWNrKSB7XG4gIGlmIChwYXRoLmlzQWJzb2x1dGUoc3JjcGF0aCkpIHtcbiAgICByZXR1cm4gZnMubHN0YXQoc3JjcGF0aCwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlLnJlcGxhY2UoJ2xzdGF0JywgJ2Vuc3VyZVN5bWxpbmsnKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgJ3RvQ3dkJzogc3JjcGF0aCxcbiAgICAgICAgJ3RvRHN0Jzogc3JjcGF0aFxuICAgICAgfSlcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRzdGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICAgIGNvbnN0IHJlbGF0aXZlVG9Ec3QgPSBwYXRoLmpvaW4oZHN0ZGlyLCBzcmNwYXRoKVxuICAgIHJldHVybiBwYXRoRXhpc3RzKHJlbGF0aXZlVG9Ec3QsIChlcnIsIGV4aXN0cykgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGlmIChleGlzdHMpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAndG9Dd2QnOiByZWxhdGl2ZVRvRHN0LFxuICAgICAgICAgICd0b0RzdCc6IHNyY3BhdGhcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmcy5sc3RhdChzcmNwYXRoLCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVTeW1saW5rJylcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICAndG9Dd2QnOiBzcmNwYXRoLFxuICAgICAgICAgICAgJ3RvRHN0JzogcGF0aC5yZWxhdGl2ZShkc3RkaXIsIHNyY3BhdGgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHN5bWxpbmtQYXRoc1N5bmMgKHNyY3BhdGgsIGRzdHBhdGgpIHtcbiAgbGV0IGV4aXN0c1xuICBpZiAocGF0aC5pc0Fic29sdXRlKHNyY3BhdGgpKSB7XG4gICAgZXhpc3RzID0gZnMuZXhpc3RzU3luYyhzcmNwYXRoKVxuICAgIGlmICghZXhpc3RzKSB0aHJvdyBuZXcgRXJyb3IoJ2Fic29sdXRlIHNyY3BhdGggZG9lcyBub3QgZXhpc3QnKVxuICAgIHJldHVybiB7XG4gICAgICAndG9Dd2QnOiBzcmNwYXRoLFxuICAgICAgJ3RvRHN0Jzogc3JjcGF0aFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkc3RkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgICBjb25zdCByZWxhdGl2ZVRvRHN0ID0gcGF0aC5qb2luKGRzdGRpciwgc3JjcGF0aClcbiAgICBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHJlbGF0aXZlVG9Ec3QpXG4gICAgaWYgKGV4aXN0cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ3RvQ3dkJzogcmVsYXRpdmVUb0RzdCxcbiAgICAgICAgJ3RvRHN0Jzogc3JjcGF0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHNyY3BhdGgpXG4gICAgICBpZiAoIWV4aXN0cykgdGhyb3cgbmV3IEVycm9yKCdyZWxhdGl2ZSBzcmNwYXRoIGRvZXMgbm90IGV4aXN0JylcbiAgICAgIHJldHVybiB7XG4gICAgICAgICd0b0N3ZCc6IHNyY3BhdGgsXG4gICAgICAgICd0b0RzdCc6IHBhdGgucmVsYXRpdmUoZHN0ZGlyLCBzcmNwYXRoKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3ltbGlua1BhdGhzLFxuICBzeW1saW5rUGF0aHNTeW5jXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/ensure/symlink-paths.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/ensure/symlink-type.js":
/*!********************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/ensure/symlink-type.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\n\nfunction symlinkType (srcpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n  if (type) return callback(null, type)\n  fs.lstat(srcpath, (err, stats) => {\n    if (err) return callback(null, 'file')\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\n    callback(null, type)\n  })\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  let stats\n\n  if (type) return type\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch (e) {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType,\n  symlinkTypeSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvc3ltbGluay10eXBlLmpzPzlkZGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLGtFQUFhOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmstdHlwZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcblxuZnVuY3Rpb24gc3ltbGlua1R5cGUgKHNyY3BhdGgsIHR5cGUsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IHR5cGUgOiBjYWxsYmFja1xuICB0eXBlID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IGZhbHNlIDogdHlwZVxuICBpZiAodHlwZSkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHR5cGUpXG4gIGZzLmxzdGF0KHNyY3BhdGgsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKG51bGwsICdmaWxlJylcbiAgICB0eXBlID0gKHN0YXRzICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpID8gJ2RpcicgOiAnZmlsZSdcbiAgICBjYWxsYmFjayhudWxsLCB0eXBlKVxuICB9KVxufVxuXG5mdW5jdGlvbiBzeW1saW5rVHlwZVN5bmMgKHNyY3BhdGgsIHR5cGUpIHtcbiAgbGV0IHN0YXRzXG5cbiAgaWYgKHR5cGUpIHJldHVybiB0eXBlXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBmcy5sc3RhdFN5bmMoc3JjcGF0aClcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiAnZmlsZSdcbiAgfVxuICByZXR1cm4gKHN0YXRzICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpID8gJ2RpcicgOiAnZmlsZSdcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN5bWxpbmtUeXBlLFxuICBzeW1saW5rVHlwZVN5bmNcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/ensure/symlink-type.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/ensure/symlink.js":
/*!***************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/ensure/symlink.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../../node_modules/universalify/index.js\").fromCallback\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\nconst _mkdirs = __webpack_require__(/*! ../mkdirs */ \"../../node_modules/fs-extra/lib/mkdirs/index.js\")\nconst mkdirs = _mkdirs.mkdirs\nconst mkdirsSync = _mkdirs.mkdirsSync\n\nconst _symlinkPaths = __webpack_require__(/*! ./symlink-paths */ \"../../node_modules/fs-extra/lib/ensure/symlink-paths.js\")\nconst symlinkPaths = _symlinkPaths.symlinkPaths\nconst symlinkPathsSync = _symlinkPaths.symlinkPathsSync\n\nconst _symlinkType = __webpack_require__(/*! ./symlink-type */ \"../../node_modules/fs-extra/lib/ensure/symlink-type.js\")\nconst symlinkType = _symlinkType.symlinkType\nconst symlinkTypeSync = _symlinkType.symlinkTypeSync\n\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"../../node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction createSymlink (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    symlinkPaths(srcpath, dstpath, (err, relative) => {\n      if (err) return callback(err)\n      srcpath = relative.toDst\n      symlinkType(relative.toCwd, type, (err, type) => {\n        if (err) return callback(err)\n        const dir = path.dirname(dstpath)\n        pathExists(dir, (err, dirExists) => {\n          if (err) return callback(err)\n          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\n          mkdirs(dir, err => {\n            if (err) return callback(err)\n            fs.symlink(srcpath, dstpath, type, callback)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: u(createSymlink),\n  createSymlinkSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvc3ltbGluay5qcz9mNjk0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFVBQVUsbUJBQU8sQ0FBQyw4REFBYztBQUNoQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGtFQUFhO0FBQ2hDLGdCQUFnQixtQkFBTyxDQUFDLGtFQUFXO0FBQ25DO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsZ0ZBQWlCO0FBQy9DO0FBQ0E7O0FBRUEscUJBQXFCLG1CQUFPLENBQUMsOEVBQWdCO0FBQzdDO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsNEVBQWdCOztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmsuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBfbWtkaXJzID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IG1rZGlycyA9IF9ta2RpcnMubWtkaXJzXG5jb25zdCBta2RpcnNTeW5jID0gX21rZGlycy5ta2RpcnNTeW5jXG5cbmNvbnN0IF9zeW1saW5rUGF0aHMgPSByZXF1aXJlKCcuL3N5bWxpbmstcGF0aHMnKVxuY29uc3Qgc3ltbGlua1BhdGhzID0gX3N5bWxpbmtQYXRocy5zeW1saW5rUGF0aHNcbmNvbnN0IHN5bWxpbmtQYXRoc1N5bmMgPSBfc3ltbGlua1BhdGhzLnN5bWxpbmtQYXRoc1N5bmNcblxuY29uc3QgX3N5bWxpbmtUeXBlID0gcmVxdWlyZSgnLi9zeW1saW5rLXR5cGUnKVxuY29uc3Qgc3ltbGlua1R5cGUgPSBfc3ltbGlua1R5cGUuc3ltbGlua1R5cGVcbmNvbnN0IHN5bWxpbmtUeXBlU3luYyA9IF9zeW1saW5rVHlwZS5zeW1saW5rVHlwZVN5bmNcblxuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuXG5mdW5jdGlvbiBjcmVhdGVTeW1saW5rIChzcmNwYXRoLCBkc3RwYXRoLCB0eXBlLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9ICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykgPyB0eXBlIDogY2FsbGJhY2tcbiAgdHlwZSA9ICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykgPyBmYWxzZSA6IHR5cGVcblxuICBwYXRoRXhpc3RzKGRzdHBhdGgsIChlcnIsIGRlc3RpbmF0aW9uRXhpc3RzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICBpZiAoZGVzdGluYXRpb25FeGlzdHMpIHJldHVybiBjYWxsYmFjayhudWxsKVxuICAgIHN5bWxpbmtQYXRocyhzcmNwYXRoLCBkc3RwYXRoLCAoZXJyLCByZWxhdGl2ZSkgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIHNyY3BhdGggPSByZWxhdGl2ZS50b0RzdFxuICAgICAgc3ltbGlua1R5cGUocmVsYXRpdmUudG9Dd2QsIHR5cGUsIChlcnIsIHR5cGUpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG4gICAgICAgIHBhdGhFeGlzdHMoZGlyLCAoZXJyLCBkaXJFeGlzdHMpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgIGlmIChkaXJFeGlzdHMpIHJldHVybiBmcy5zeW1saW5rKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKVxuICAgICAgICAgIG1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgZnMuc3ltbGluayhzcmNwYXRoLCBkc3RwYXRoLCB0eXBlLCBjYWxsYmFjaylcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTeW1saW5rU3luYyAoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSkge1xuICBjb25zdCBkZXN0aW5hdGlvbkV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoZHN0cGF0aClcbiAgaWYgKGRlc3RpbmF0aW9uRXhpc3RzKSByZXR1cm4gdW5kZWZpbmVkXG5cbiAgY29uc3QgcmVsYXRpdmUgPSBzeW1saW5rUGF0aHNTeW5jKHNyY3BhdGgsIGRzdHBhdGgpXG4gIHNyY3BhdGggPSByZWxhdGl2ZS50b0RzdFxuICB0eXBlID0gc3ltbGlua1R5cGVTeW5jKHJlbGF0aXZlLnRvQ3dkLCB0eXBlKVxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgY29uc3QgZXhpc3RzID0gZnMuZXhpc3RzU3luYyhkaXIpXG4gIGlmIChleGlzdHMpIHJldHVybiBmcy5zeW1saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoLCB0eXBlKVxuICBta2RpcnNTeW5jKGRpcilcbiAgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVTeW1saW5rOiB1KGNyZWF0ZVN5bWxpbmspLFxuICBjcmVhdGVTeW1saW5rU3luY1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/ensure/symlink.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/fs/index.js":
/*!*********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/fs/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = __webpack_require__(/*! universalify */ \"../../node_modules/universalify/index.js\").fromCallback\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'lchown',\n  'lchmod',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'readFile',\n  'readdir',\n  'readlink',\n  'realpath',\n  'rename',\n  'rmdir',\n  'stat',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.copyFile was added in Node.js v8.5.0\n  // fs.mkdtemp was added in Node.js v5.10.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export all keys:\nObject.keys(fs).forEach(key => {\n  if (key === 'promises') {\n    // fs.promises is a getter property that triggers ExperimentalWarning\n    // Don't re-export it here, the getter is defined in \"lib/index.js\"\n    return\n  }\n  exports[key] = fs[key]\n})\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read() & fs.write need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n\n// fs.realpath.native only available in Node v9.2+\nif (typeof fs.realpath.native === 'function') {\n  exports.realpath.native = u(fs.realpath.native)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9mcy9pbmRleC5qcz9mMTEyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyw4REFBYztBQUNoQyxXQUFXLG1CQUFPLENBQUMsa0VBQWE7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2ZzL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyBUaGlzIGlzIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbm9ybWFsaXplL216XG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNiBKb25hdGhhbiBPbmcgbWVAam9uZ2xlYmVycnkuY29tIGFuZCBDb250cmlidXRvcnNcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuXG5jb25zdCBhcGkgPSBbXG4gICdhY2Nlc3MnLFxuICAnYXBwZW5kRmlsZScsXG4gICdjaG1vZCcsXG4gICdjaG93bicsXG4gICdjbG9zZScsXG4gICdjb3B5RmlsZScsXG4gICdmY2htb2QnLFxuICAnZmNob3duJyxcbiAgJ2ZkYXRhc3luYycsXG4gICdmc3RhdCcsXG4gICdmc3luYycsXG4gICdmdHJ1bmNhdGUnLFxuICAnZnV0aW1lcycsXG4gICdsY2hvd24nLFxuICAnbGNobW9kJyxcbiAgJ2xpbmsnLFxuICAnbHN0YXQnLFxuICAnbWtkaXInLFxuICAnbWtkdGVtcCcsXG4gICdvcGVuJyxcbiAgJ3JlYWRGaWxlJyxcbiAgJ3JlYWRkaXInLFxuICAncmVhZGxpbmsnLFxuICAncmVhbHBhdGgnLFxuICAncmVuYW1lJyxcbiAgJ3JtZGlyJyxcbiAgJ3N0YXQnLFxuICAnc3ltbGluaycsXG4gICd0cnVuY2F0ZScsXG4gICd1bmxpbmsnLFxuICAndXRpbWVzJyxcbiAgJ3dyaXRlRmlsZSdcbl0uZmlsdGVyKGtleSA9PiB7XG4gIC8vIFNvbWUgY29tbWFuZHMgYXJlIG5vdCBhdmFpbGFibGUgb24gc29tZSBzeXN0ZW1zLiBFeDpcbiAgLy8gZnMuY29weUZpbGUgd2FzIGFkZGVkIGluIE5vZGUuanMgdjguNS4wXG4gIC8vIGZzLm1rZHRlbXAgd2FzIGFkZGVkIGluIE5vZGUuanMgdjUuMTAuMFxuICAvLyBmcy5sY2hvd24gaXMgbm90IGF2YWlsYWJsZSBvbiBhdCBsZWFzdCBzb21lIExpbnV4XG4gIHJldHVybiB0eXBlb2YgZnNba2V5XSA9PT0gJ2Z1bmN0aW9uJ1xufSlcblxuLy8gRXhwb3J0IGFsbCBrZXlzOlxuT2JqZWN0LmtleXMoZnMpLmZvckVhY2goa2V5ID0+IHtcbiAgaWYgKGtleSA9PT0gJ3Byb21pc2VzJykge1xuICAgIC8vIGZzLnByb21pc2VzIGlzIGEgZ2V0dGVyIHByb3BlcnR5IHRoYXQgdHJpZ2dlcnMgRXhwZXJpbWVudGFsV2FybmluZ1xuICAgIC8vIERvbid0IHJlLWV4cG9ydCBpdCBoZXJlLCB0aGUgZ2V0dGVyIGlzIGRlZmluZWQgaW4gXCJsaWIvaW5kZXguanNcIlxuICAgIHJldHVyblxuICB9XG4gIGV4cG9ydHNba2V5XSA9IGZzW2tleV1cbn0pXG5cbi8vIFVuaXZlcnNhbGlmeSBhc3luYyBtZXRob2RzOlxuYXBpLmZvckVhY2gobWV0aG9kID0+IHtcbiAgZXhwb3J0c1ttZXRob2RdID0gdShmc1ttZXRob2RdKVxufSlcblxuLy8gV2UgZGlmZmVyIGZyb20gbXovZnMgaW4gdGhhdCB3ZSBzdGlsbCBzaGlwIHRoZSBvbGQsIGJyb2tlbiwgZnMuZXhpc3RzKClcbi8vIHNpbmNlIHdlIGFyZSBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIHRoZSBuYXRpdmUgbW9kdWxlXG5leHBvcnRzLmV4aXN0cyA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy5leGlzdHMoZmlsZW5hbWUsIGNhbGxiYWNrKVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICByZXR1cm4gZnMuZXhpc3RzKGZpbGVuYW1lLCByZXNvbHZlKVxuICB9KVxufVxuXG4vLyBmcy5yZWFkKCkgJiBmcy53cml0ZSBuZWVkIHNwZWNpYWwgdHJlYXRtZW50IGR1ZSB0byBtdWx0aXBsZSBjYWxsYmFjayBhcmdzXG5cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnMucmVhZChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMucmVhZChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIChlcnIsIGJ5dGVzUmVhZCwgYnVmZmVyKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgIHJlc29sdmUoeyBieXRlc1JlYWQsIGJ1ZmZlciB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIEZ1bmN0aW9uIHNpZ25hdHVyZSBjYW4gYmVcbi8vIGZzLndyaXRlKGZkLCBidWZmZXJbLCBvZmZzZXRbLCBsZW5ndGhbLCBwb3NpdGlvbl1dXSwgY2FsbGJhY2spXG4vLyBPUlxuLy8gZnMud3JpdGUoZmQsIHN0cmluZ1ssIHBvc2l0aW9uWywgZW5jb2RpbmddXSwgY2FsbGJhY2spXG4vLyBXZSBuZWVkIHRvIGhhbmRsZSBib3RoIGNhc2VzLCBzbyB3ZSB1c2UgLi4uYXJnc1xuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChmZCwgYnVmZmVyLCAuLi5hcmdzKSB7XG4gIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZzLndyaXRlKGZkLCBidWZmZXIsIC4uLmFyZ3MpXG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZzLndyaXRlKGZkLCBidWZmZXIsIC4uLmFyZ3MsIChlcnIsIGJ5dGVzV3JpdHRlbiwgYnVmZmVyKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgIHJlc29sdmUoeyBieXRlc1dyaXR0ZW4sIGJ1ZmZlciB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIGZzLnJlYWxwYXRoLm5hdGl2ZSBvbmx5IGF2YWlsYWJsZSBpbiBOb2RlIHY5LjIrXG5pZiAodHlwZW9mIGZzLnJlYWxwYXRoLm5hdGl2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICBleHBvcnRzLnJlYWxwYXRoLm5hdGl2ZSA9IHUoZnMucmVhbHBhdGgubmF0aXZlKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/fs/index.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/index.js":
/*!******************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = Object.assign(\n  {},\n  // Export promiseified graceful-fs:\n  __webpack_require__(/*! ./fs */ \"../../node_modules/fs-extra/lib/fs/index.js\"),\n  // Export extra methods:\n  __webpack_require__(/*! ./copy-sync */ \"../../node_modules/fs-extra/lib/copy-sync/index.js\"),\n  __webpack_require__(/*! ./copy */ \"../../node_modules/fs-extra/lib/copy/index.js\"),\n  __webpack_require__(/*! ./empty */ \"../../node_modules/fs-extra/lib/empty/index.js\"),\n  __webpack_require__(/*! ./ensure */ \"../../node_modules/fs-extra/lib/ensure/index.js\"),\n  __webpack_require__(/*! ./json */ \"../../node_modules/fs-extra/lib/json/index.js\"),\n  __webpack_require__(/*! ./mkdirs */ \"../../node_modules/fs-extra/lib/mkdirs/index.js\"),\n  __webpack_require__(/*! ./move-sync */ \"../../node_modules/fs-extra/lib/move-sync/index.js\"),\n  __webpack_require__(/*! ./move */ \"../../node_modules/fs-extra/lib/move/index.js\"),\n  __webpack_require__(/*! ./output */ \"../../node_modules/fs-extra/lib/output/index.js\"),\n  __webpack_require__(/*! ./path-exists */ \"../../node_modules/fs-extra/lib/path-exists/index.js\"),\n  __webpack_require__(/*! ./remove */ \"../../node_modules/fs-extra/lib/remove/index.js\")\n)\n\n// Export fs.promises as a getter property so that we don't trigger\n// ExperimentalWarning before fs.promises is actually accessed.\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nif (Object.getOwnPropertyDescriptor(fs, 'promises')) {\n  Object.defineProperty(module.exports, 'promises', {\n    get () { return fs.promises }\n  })\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9pbmRleC5qcz8zYzAwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLHlEQUFNO0FBQ2hCO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLHVFQUFhO0FBQ3ZCLEVBQUUsbUJBQU8sQ0FBQyw2REFBUTtBQUNsQixFQUFFLG1CQUFPLENBQUMsK0RBQVM7QUFDbkIsRUFBRSxtQkFBTyxDQUFDLGlFQUFVO0FBQ3BCLEVBQUUsbUJBQU8sQ0FBQyw2REFBUTtBQUNsQixFQUFFLG1CQUFPLENBQUMsaUVBQVU7QUFDcEIsRUFBRSxtQkFBTyxDQUFDLHVFQUFhO0FBQ3ZCLEVBQUUsbUJBQU8sQ0FBQyw2REFBUTtBQUNsQixFQUFFLG1CQUFPLENBQUMsaUVBQVU7QUFDcEIsRUFBRSxtQkFBTyxDQUFDLDJFQUFlO0FBQ3pCLEVBQUUsbUJBQU8sQ0FBQyxpRUFBVTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkI7QUFDQTtBQUNBLFlBQVk7QUFDWixHQUFHO0FBQ0giLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24oXG4gIHt9LFxuICAvLyBFeHBvcnQgcHJvbWlzZWlmaWVkIGdyYWNlZnVsLWZzOlxuICByZXF1aXJlKCcuL2ZzJyksXG4gIC8vIEV4cG9ydCBleHRyYSBtZXRob2RzOlxuICByZXF1aXJlKCcuL2NvcHktc3luYycpLFxuICByZXF1aXJlKCcuL2NvcHknKSxcbiAgcmVxdWlyZSgnLi9lbXB0eScpLFxuICByZXF1aXJlKCcuL2Vuc3VyZScpLFxuICByZXF1aXJlKCcuL2pzb24nKSxcbiAgcmVxdWlyZSgnLi9ta2RpcnMnKSxcbiAgcmVxdWlyZSgnLi9tb3ZlLXN5bmMnKSxcbiAgcmVxdWlyZSgnLi9tb3ZlJyksXG4gIHJlcXVpcmUoJy4vb3V0cHV0JyksXG4gIHJlcXVpcmUoJy4vcGF0aC1leGlzdHMnKSxcbiAgcmVxdWlyZSgnLi9yZW1vdmUnKVxuKVxuXG4vLyBFeHBvcnQgZnMucHJvbWlzZXMgYXMgYSBnZXR0ZXIgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCB0cmlnZ2VyXG4vLyBFeHBlcmltZW50YWxXYXJuaW5nIGJlZm9yZSBmcy5wcm9taXNlcyBpcyBhY3R1YWxseSBhY2Nlc3NlZC5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZnMsICdwcm9taXNlcycpKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ3Byb21pc2VzJywge1xuICAgIGdldCAoKSB7IHJldHVybiBmcy5wcm9taXNlcyB9XG4gIH0pXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/index.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/json/index.js":
/*!***********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/json/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../../node_modules/universalify/index.js\").fromCallback\nconst jsonFile = __webpack_require__(/*! ./jsonfile */ \"../../node_modules/fs-extra/lib/json/jsonfile.js\")\n\njsonFile.outputJson = u(__webpack_require__(/*! ./output-json */ \"../../node_modules/fs-extra/lib/json/output-json.js\"))\njsonFile.outputJsonSync = __webpack_require__(/*! ./output-json-sync */ \"../../node_modules/fs-extra/lib/json/output-json-sync.js\")\n// aliases\njsonFile.outputJSON = jsonFile.outputJson\njsonFile.outputJSONSync = jsonFile.outputJsonSync\njsonFile.writeJSON = jsonFile.writeJson\njsonFile.writeJSONSync = jsonFile.writeJsonSync\njsonFile.readJSON = jsonFile.readJson\njsonFile.readJSONSync = jsonFile.readJsonSync\n\nmodule.exports = jsonFile\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL2luZGV4LmpzP2YxOGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosVUFBVSxtQkFBTyxDQUFDLDhEQUFjO0FBQ2hDLGlCQUFpQixtQkFBTyxDQUFDLG9FQUFZOztBQUVyQyx3QkFBd0IsbUJBQU8sQ0FBQywwRUFBZTtBQUMvQywwQkFBMEIsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IGpzb25GaWxlID0gcmVxdWlyZSgnLi9qc29uZmlsZScpXG5cbmpzb25GaWxlLm91dHB1dEpzb24gPSB1KHJlcXVpcmUoJy4vb3V0cHV0LWpzb24nKSlcbmpzb25GaWxlLm91dHB1dEpzb25TeW5jID0gcmVxdWlyZSgnLi9vdXRwdXQtanNvbi1zeW5jJylcbi8vIGFsaWFzZXNcbmpzb25GaWxlLm91dHB1dEpTT04gPSBqc29uRmlsZS5vdXRwdXRKc29uXG5qc29uRmlsZS5vdXRwdXRKU09OU3luYyA9IGpzb25GaWxlLm91dHB1dEpzb25TeW5jXG5qc29uRmlsZS53cml0ZUpTT04gPSBqc29uRmlsZS53cml0ZUpzb25cbmpzb25GaWxlLndyaXRlSlNPTlN5bmMgPSBqc29uRmlsZS53cml0ZUpzb25TeW5jXG5qc29uRmlsZS5yZWFkSlNPTiA9IGpzb25GaWxlLnJlYWRKc29uXG5qc29uRmlsZS5yZWFkSlNPTlN5bmMgPSBqc29uRmlsZS5yZWFkSnNvblN5bmNcblxubW9kdWxlLmV4cG9ydHMgPSBqc29uRmlsZVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/json/index.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/json/jsonfile.js":
/*!**************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/json/jsonfile.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../../node_modules/universalify/index.js\").fromCallback\nconst jsonFile = __webpack_require__(/*! jsonfile */ \"../../node_modules/jsonfile/index.js\")\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: u(jsonFile.readFile),\n  readJsonSync: jsonFile.readFileSync,\n  writeJson: u(jsonFile.writeFile),\n  writeJsonSync: jsonFile.writeFileSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL2pzb25maWxlLmpzP2M3ZTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosVUFBVSxtQkFBTyxDQUFDLDhEQUFjO0FBQ2hDLGlCQUFpQixtQkFBTyxDQUFDLHNEQUFVOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vanNvbmZpbGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QganNvbkZpbGUgPSByZXF1aXJlKCdqc29uZmlsZScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBqc29uZmlsZSBleHBvcnRzXG4gIHJlYWRKc29uOiB1KGpzb25GaWxlLnJlYWRGaWxlKSxcbiAgcmVhZEpzb25TeW5jOiBqc29uRmlsZS5yZWFkRmlsZVN5bmMsXG4gIHdyaXRlSnNvbjogdShqc29uRmlsZS53cml0ZUZpbGUpLFxuICB3cml0ZUpzb25TeW5jOiBqc29uRmlsZS53cml0ZUZpbGVTeW5jXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/json/jsonfile.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/json/output-json-sync.js":
/*!**********************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/json/output-json-sync.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"../../node_modules/fs-extra/lib/mkdirs/index.js\")\nconst jsonFile = __webpack_require__(/*! ./jsonfile */ \"../../node_modules/fs-extra/lib/json/jsonfile.js\")\n\nfunction outputJsonSync (file, data, options) {\n  const dir = path.dirname(file)\n\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  jsonFile.writeJsonSync(file, data, options)\n}\n\nmodule.exports = outputJsonSync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL291dHB1dC1qc29uLXN5bmMuanM/OGQ1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsa0VBQWE7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyxrRUFBVztBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxvRUFBWTs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vb3V0cHV0LWpzb24tc3luYy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IGpzb25GaWxlID0gcmVxdWlyZSgnLi9qc29uZmlsZScpXG5cbmZ1bmN0aW9uIG91dHB1dEpzb25TeW5jIChmaWxlLCBkYXRhLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuXG4gIGlmICghZnMuZXhpc3RzU3luYyhkaXIpKSB7XG4gICAgbWtkaXIubWtkaXJzU3luYyhkaXIpXG4gIH1cblxuICBqc29uRmlsZS53cml0ZUpzb25TeW5jKGZpbGUsIGRhdGEsIG9wdGlvbnMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0cHV0SnNvblN5bmNcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/json/output-json-sync.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/json/output-json.js":
/*!*****************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/json/output-json.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"../../node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"../../node_modules/fs-extra/lib/path-exists/index.js\").pathExists\nconst jsonFile = __webpack_require__(/*! ./jsonfile */ \"../../node_modules/fs-extra/lib/json/jsonfile.js\")\n\nfunction outputJson (file, data, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  const dir = path.dirname(file)\n\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return jsonFile.writeJson(file, data, options, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n      jsonFile.writeJson(file, data, options, callback)\n    })\n  })\n}\n\nmodule.exports = outputJson\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL291dHB1dC1qc29uLmpzP2FmN2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyxrRUFBVztBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsb0VBQVk7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUEiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL291dHB1dC1qc29uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcbmNvbnN0IGpzb25GaWxlID0gcmVxdWlyZSgnLi9qc29uZmlsZScpXG5cbmZ1bmN0aW9uIG91dHB1dEpzb24gKGZpbGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG5cbiAgcGF0aEV4aXN0cyhkaXIsIChlcnIsIGl0RG9lcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgaWYgKGl0RG9lcykgcmV0dXJuIGpzb25GaWxlLndyaXRlSnNvbihmaWxlLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjaylcblxuICAgIG1rZGlyLm1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAganNvbkZpbGUud3JpdGVKc29uKGZpbGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIH0pXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0cHV0SnNvblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/json/output-json.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/mkdirs/index.js":
/*!*************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/mkdirs/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst u = __webpack_require__(/*! universalify */ \"../../node_modules/universalify/index.js\").fromCallback\nconst mkdirs = u(__webpack_require__(/*! ./mkdirs */ \"../../node_modules/fs-extra/lib/mkdirs/mkdirs.js\"))\nconst mkdirsSync = __webpack_require__(/*! ./mkdirs-sync */ \"../../node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js\")\n\nmodule.exports = {\n  mkdirs,\n  mkdirsSync,\n  // alias\n  mkdirp: mkdirs,\n  mkdirpSync: mkdirsSync,\n  ensureDir: mkdirs,\n  ensureDirSync: mkdirsSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvaW5kZXguanM/NGM5NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBWTtBQUNaLFVBQVUsbUJBQU8sQ0FBQyw4REFBYztBQUNoQyxpQkFBaUIsbUJBQU8sQ0FBQyxrRUFBVTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBZTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbWtkaXJzL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBta2RpcnMgPSB1KHJlcXVpcmUoJy4vbWtkaXJzJykpXG5jb25zdCBta2RpcnNTeW5jID0gcmVxdWlyZSgnLi9ta2RpcnMtc3luYycpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBta2RpcnMsXG4gIG1rZGlyc1N5bmMsXG4gIC8vIGFsaWFzXG4gIG1rZGlycDogbWtkaXJzLFxuICBta2RpcnBTeW5jOiBta2RpcnNTeW5jLFxuICBlbnN1cmVEaXI6IG1rZGlycyxcbiAgZW5zdXJlRGlyU3luYzogbWtkaXJzU3luY1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/mkdirs/index.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js":
/*!*******************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst invalidWin32Path = __webpack_require__(/*! ./win32 */ \"../../node_modules/fs-extra/lib/mkdirs/win32.js\").invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirsSync (p, opts, made) {\n  if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    throw errInval\n  }\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  p = path.resolve(p)\n\n  try {\n    xfs.mkdirSync(p, mode)\n    made = made || p\n  } catch (err0) {\n    if (err0.code === 'ENOENT') {\n      if (path.dirname(p) === p) throw err0\n      made = mkdirsSync(path.dirname(p), opts, made)\n      mkdirsSync(p, opts, made)\n    } else {\n      // In the case of any other error, just see if there's a dir there\n      // already. If so, then hooray!  If not, then something is borked.\n      let stat\n      try {\n        stat = xfs.statSync(p)\n      } catch (err1) {\n        throw err0\n      }\n      if (!stat.isDirectory()) throw err0\n    }\n  }\n\n  return made\n}\n\nmodule.exports = mkdirsSync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvbWtkaXJzLXN5bmMuanM/NWNiZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsa0VBQWE7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLHlCQUF5QixtQkFBTyxDQUFDLGdFQUFTOztBQUUxQzs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvbWtkaXJzLXN5bmMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBpbnZhbGlkV2luMzJQYXRoID0gcmVxdWlyZSgnLi93aW4zMicpLmludmFsaWRXaW4zMlBhdGhcblxuY29uc3Qgbzc3NyA9IHBhcnNlSW50KCcwNzc3JywgOClcblxuZnVuY3Rpb24gbWtkaXJzU3luYyAocCwgb3B0cywgbWFkZSkge1xuICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgb3B0cyA9IHsgbW9kZTogb3B0cyB9XG4gIH1cblxuICBsZXQgbW9kZSA9IG9wdHMubW9kZVxuICBjb25zdCB4ZnMgPSBvcHRzLmZzIHx8IGZzXG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgJiYgaW52YWxpZFdpbjMyUGF0aChwKSkge1xuICAgIGNvbnN0IGVyckludmFsID0gbmV3IEVycm9yKHAgKyAnIGNvbnRhaW5zIGludmFsaWQgV0lOMzIgcGF0aCBjaGFyYWN0ZXJzLicpXG4gICAgZXJySW52YWwuY29kZSA9ICdFSU5WQUwnXG4gICAgdGhyb3cgZXJySW52YWxcbiAgfVxuXG4gIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICBtb2RlID0gbzc3NyAmICh+cHJvY2Vzcy51bWFzaygpKVxuICB9XG4gIGlmICghbWFkZSkgbWFkZSA9IG51bGxcblxuICBwID0gcGF0aC5yZXNvbHZlKHApXG5cbiAgdHJ5IHtcbiAgICB4ZnMubWtkaXJTeW5jKHAsIG1vZGUpXG4gICAgbWFkZSA9IG1hZGUgfHwgcFxuICB9IGNhdGNoIChlcnIwKSB7XG4gICAgaWYgKGVycjAuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIGlmIChwYXRoLmRpcm5hbWUocCkgPT09IHApIHRocm93IGVycjBcbiAgICAgIG1hZGUgPSBta2RpcnNTeW5jKHBhdGguZGlybmFtZShwKSwgb3B0cywgbWFkZSlcbiAgICAgIG1rZGlyc1N5bmMocCwgb3B0cywgbWFkZSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYW55IG90aGVyIGVycm9yLCBqdXN0IHNlZSBpZiB0aGVyZSdzIGEgZGlyIHRoZXJlXG4gICAgICAvLyBhbHJlYWR5LiBJZiBzbywgdGhlbiBob29yYXkhICBJZiBub3QsIHRoZW4gc29tZXRoaW5nIGlzIGJvcmtlZC5cbiAgICAgIGxldCBzdGF0XG4gICAgICB0cnkge1xuICAgICAgICBzdGF0ID0geGZzLnN0YXRTeW5jKHApXG4gICAgICB9IGNhdGNoIChlcnIxKSB7XG4gICAgICAgIHRocm93IGVycjBcbiAgICAgIH1cbiAgICAgIGlmICghc3RhdC5pc0RpcmVjdG9yeSgpKSB0aHJvdyBlcnIwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hZGVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBta2RpcnNTeW5jXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/mkdirs/mkdirs.js":
/*!**************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/mkdirs/mkdirs.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst invalidWin32Path = __webpack_require__(/*! ./win32 */ \"../../node_modules/fs-extra/lib/mkdirs/win32.js\").invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirs (p, opts, callback, made) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  } else if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    return callback(errInval)\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  callback = callback || function () {}\n  p = path.resolve(p)\n\n  xfs.mkdir(p, mode, er => {\n    if (!er) {\n      made = made || p\n      return callback(null, made)\n    }\n    switch (er.code) {\n      case 'ENOENT':\n        if (path.dirname(p) === p) return callback(er)\n        mkdirs(path.dirname(p), opts, (er, made) => {\n          if (er) callback(er, made)\n          else mkdirs(p, opts, callback, made)\n        })\n        break\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        xfs.stat(p, (er2, stat) => {\n          // if the stat fails, then that's super weird.\n          // let the original error be the failure reason.\n          if (er2 || !stat.isDirectory()) callback(er, made)\n          else callback(null, made)\n        })\n        break\n    }\n  })\n}\n\nmodule.exports = mkdirs\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvbWtkaXJzLmpzP2M0ZGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLGtFQUFhO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQyxnRUFBUzs7QUFFMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvbWtkaXJzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgaW52YWxpZFdpbjMyUGF0aCA9IHJlcXVpcmUoJy4vd2luMzInKS5pbnZhbGlkV2luMzJQYXRoXG5cbmNvbnN0IG83NzcgPSBwYXJzZUludCgnMDc3NycsIDgpXG5cbmZ1bmN0aW9uIG1rZGlycyAocCwgb3B0cywgY2FsbGJhY2ssIG1hZGUpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH0gZWxzZSBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgb3B0cyA9IHsgbW9kZTogb3B0cyB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJiBpbnZhbGlkV2luMzJQYXRoKHApKSB7XG4gICAgY29uc3QgZXJySW52YWwgPSBuZXcgRXJyb3IocCArICcgY29udGFpbnMgaW52YWxpZCBXSU4zMiBwYXRoIGNoYXJhY3RlcnMuJylcbiAgICBlcnJJbnZhbC5jb2RlID0gJ0VJTlZBTCdcbiAgICByZXR1cm4gY2FsbGJhY2soZXJySW52YWwpXG4gIH1cblxuICBsZXQgbW9kZSA9IG9wdHMubW9kZVxuICBjb25zdCB4ZnMgPSBvcHRzLmZzIHx8IGZzXG5cbiAgaWYgKG1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIG1vZGUgPSBvNzc3ICYgKH5wcm9jZXNzLnVtYXNrKCkpXG4gIH1cbiAgaWYgKCFtYWRlKSBtYWRlID0gbnVsbFxuXG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge31cbiAgcCA9IHBhdGgucmVzb2x2ZShwKVxuXG4gIHhmcy5ta2RpcihwLCBtb2RlLCBlciA9PiB7XG4gICAgaWYgKCFlcikge1xuICAgICAgbWFkZSA9IG1hZGUgfHwgcFxuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG1hZGUpXG4gICAgfVxuICAgIHN3aXRjaCAoZXIuY29kZSkge1xuICAgICAgY2FzZSAnRU5PRU5UJzpcbiAgICAgICAgaWYgKHBhdGguZGlybmFtZShwKSA9PT0gcCkgcmV0dXJuIGNhbGxiYWNrKGVyKVxuICAgICAgICBta2RpcnMocGF0aC5kaXJuYW1lKHApLCBvcHRzLCAoZXIsIG1hZGUpID0+IHtcbiAgICAgICAgICBpZiAoZXIpIGNhbGxiYWNrKGVyLCBtYWRlKVxuICAgICAgICAgIGVsc2UgbWtkaXJzKHAsIG9wdHMsIGNhbGxiYWNrLCBtYWRlKVxuICAgICAgICB9KVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhbnkgb3RoZXIgZXJyb3IsIGp1c3Qgc2VlIGlmIHRoZXJlJ3MgYSBkaXJcbiAgICAgIC8vIHRoZXJlIGFscmVhZHkuICBJZiBzbywgdGhlbiBob29yYXkhICBJZiBub3QsIHRoZW4gc29tZXRoaW5nXG4gICAgICAvLyBpcyBib3JrZWQuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB4ZnMuc3RhdChwLCAoZXIyLCBzdGF0KSA9PiB7XG4gICAgICAgICAgLy8gaWYgdGhlIHN0YXQgZmFpbHMsIHRoZW4gdGhhdCdzIHN1cGVyIHdlaXJkLlxuICAgICAgICAgIC8vIGxldCB0aGUgb3JpZ2luYWwgZXJyb3IgYmUgdGhlIGZhaWx1cmUgcmVhc29uLlxuICAgICAgICAgIGlmIChlcjIgfHwgIXN0YXQuaXNEaXJlY3RvcnkoKSkgY2FsbGJhY2soZXIsIG1hZGUpXG4gICAgICAgICAgZWxzZSBjYWxsYmFjayhudWxsLCBtYWRlKVxuICAgICAgICB9KVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBta2RpcnNcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/mkdirs/mkdirs.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/mkdirs/win32.js":
/*!*************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/mkdirs/win32.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\")\n\n// get drive on windows\nfunction getRootPath (p) {\n  p = path.normalize(path.resolve(p)).split(path.sep)\n  if (p.length > 0) return p[0]\n  return null\n}\n\n// http://stackoverflow.com/a/62888/10333 contains more accurate\n// TODO: expand to include the rest\nconst INVALID_PATH_CHARS = /[<>:\"|?*]/\n\nfunction invalidWin32Path (p) {\n  const rp = getRootPath(p)\n  p = p.replace(rp, '')\n  return INVALID_PATH_CHARS.test(p)\n}\n\nmodule.exports = {\n  getRootPath,\n  invalidWin32Path\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvd2luMzIuanM/NThlOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy93aW4zMi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbi8vIGdldCBkcml2ZSBvbiB3aW5kb3dzXG5mdW5jdGlvbiBnZXRSb290UGF0aCAocCkge1xuICBwID0gcGF0aC5ub3JtYWxpemUocGF0aC5yZXNvbHZlKHApKS5zcGxpdChwYXRoLnNlcClcbiAgaWYgKHAubGVuZ3RoID4gMCkgcmV0dXJuIHBbMF1cbiAgcmV0dXJuIG51bGxcbn1cblxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjI4ODgvMTAzMzMgY29udGFpbnMgbW9yZSBhY2N1cmF0ZVxuLy8gVE9ETzogZXhwYW5kIHRvIGluY2x1ZGUgdGhlIHJlc3RcbmNvbnN0IElOVkFMSURfUEFUSF9DSEFSUyA9IC9bPD46XCJ8PypdL1xuXG5mdW5jdGlvbiBpbnZhbGlkV2luMzJQYXRoIChwKSB7XG4gIGNvbnN0IHJwID0gZ2V0Um9vdFBhdGgocClcbiAgcCA9IHAucmVwbGFjZShycCwgJycpXG4gIHJldHVybiBJTlZBTElEX1BBVEhfQ0hBUlMudGVzdChwKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Um9vdFBhdGgsXG4gIGludmFsaWRXaW4zMlBhdGhcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/mkdirs/win32.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/move-sync/index.js":
/*!****************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/move-sync/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  moveSync: __webpack_require__(/*! ./move-sync */ \"../../node_modules/fs-extra/lib/move-sync/move-sync.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlLXN5bmMvaW5kZXguanM/NWU1ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBLFlBQVksbUJBQU8sQ0FBQywyRUFBYTtBQUNqQyIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUtc3luYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbW92ZVN5bmM6IHJlcXVpcmUoJy4vbW92ZS1zeW5jJylcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/move-sync/index.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/move-sync/move-sync.js":
/*!********************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/move-sync/move-sync.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst copySync = __webpack_require__(/*! ../copy-sync */ \"../../node_modules/fs-extra/lib/copy-sync/index.js\").copySync\nconst removeSync = __webpack_require__(/*! ../remove */ \"../../node_modules/fs-extra/lib/remove/index.js\").removeSync\nconst mkdirpSync = __webpack_require__(/*! ../mkdirs */ \"../../node_modules/fs-extra/lib/mkdirs/index.js\").mkdirpSync\nconst stat = __webpack_require__(/*! ../util/stat */ \"../../node_modules/fs-extra/lib/util/stat.js\")\n\nfunction moveSync (src, dest, opts) {\n  opts = opts || {}\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  const { srcStat } = stat.checkPathsSync(src, dest, 'move')\n  stat.checkParentPathsSync(src, srcStat, dest, 'move')\n  mkdirpSync(path.dirname(dest))\n  return doRename(src, dest, overwrite)\n}\n\nfunction doRename (src, dest, overwrite) {\n  if (overwrite) {\n    removeSync(dest)\n    return rename(src, dest, overwrite)\n  }\n  if (fs.existsSync(dest)) throw new Error('dest already exists.')\n  return rename(src, dest, overwrite)\n}\n\nfunction rename (src, dest, overwrite) {\n  try {\n    fs.renameSync(src, dest)\n  } catch (err) {\n    if (err.code !== 'EXDEV') throw err\n    return moveAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveAcrossDevice (src, dest, overwrite) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copySync(src, dest, opts)\n  return removeSync(src)\n}\n\nmodule.exports = moveSync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlLXN5bmMvbW92ZS1zeW5jLmpzPzIzZGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLGtFQUFhO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBYztBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyxrRUFBVztBQUN0QyxtQkFBbUIsbUJBQU8sQ0FBQyxrRUFBVztBQUN0QyxhQUFhLG1CQUFPLENBQUMsa0VBQWM7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFVBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUtc3luYy9tb3ZlLXN5bmMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBjb3B5U3luYyA9IHJlcXVpcmUoJy4uL2NvcHktc3luYycpLmNvcHlTeW5jXG5jb25zdCByZW1vdmVTeW5jID0gcmVxdWlyZSgnLi4vcmVtb3ZlJykucmVtb3ZlU3luY1xuY29uc3QgbWtkaXJwU3luYyA9IHJlcXVpcmUoJy4uL21rZGlycycpLm1rZGlycFN5bmNcbmNvbnN0IHN0YXQgPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5mdW5jdGlvbiBtb3ZlU3luYyAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9XG4gIGNvbnN0IG92ZXJ3cml0ZSA9IG9wdHMub3ZlcndyaXRlIHx8IG9wdHMuY2xvYmJlciB8fCBmYWxzZVxuXG4gIGNvbnN0IHsgc3JjU3RhdCB9ID0gc3RhdC5jaGVja1BhdGhzU3luYyhzcmMsIGRlc3QsICdtb3ZlJylcbiAgc3RhdC5jaGVja1BhcmVudFBhdGhzU3luYyhzcmMsIHNyY1N0YXQsIGRlc3QsICdtb3ZlJylcbiAgbWtkaXJwU3luYyhwYXRoLmRpcm5hbWUoZGVzdCkpXG4gIHJldHVybiBkb1JlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbn1cblxuZnVuY3Rpb24gZG9SZW5hbWUgKHNyYywgZGVzdCwgb3ZlcndyaXRlKSB7XG4gIGlmIChvdmVyd3JpdGUpIHtcbiAgICByZW1vdmVTeW5jKGRlc3QpXG4gICAgcmV0dXJuIHJlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgfVxuICBpZiAoZnMuZXhpc3RzU3luYyhkZXN0KSkgdGhyb3cgbmV3IEVycm9yKCdkZXN0IGFscmVhZHkgZXhpc3RzLicpXG4gIHJldHVybiByZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUpXG59XG5cbmZ1bmN0aW9uIHJlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUpIHtcbiAgdHJ5IHtcbiAgICBmcy5yZW5hbWVTeW5jKHNyYywgZGVzdClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICE9PSAnRVhERVYnKSB0aHJvdyBlcnJcbiAgICByZXR1cm4gbW92ZUFjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3ZlQWNyb3NzRGV2aWNlIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSkge1xuICBjb25zdCBvcHRzID0ge1xuICAgIG92ZXJ3cml0ZSxcbiAgICBlcnJvck9uRXhpc3Q6IHRydWVcbiAgfVxuICBjb3B5U3luYyhzcmMsIGRlc3QsIG9wdHMpXG4gIHJldHVybiByZW1vdmVTeW5jKHNyYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtb3ZlU3luY1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/move-sync/move-sync.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/move/index.js":
/*!***********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/move/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../../node_modules/universalify/index.js\").fromCallback\nmodule.exports = {\n  move: u(__webpack_require__(/*! ./move */ \"../../node_modules/fs-extra/lib/move/move.js\"))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlL2luZGV4LmpzP2E3YTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosVUFBVSxtQkFBTyxDQUFDLDhEQUFjO0FBQ2hDO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLDREQUFRO0FBQzFCIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbW92ZS9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbW92ZTogdShyZXF1aXJlKCcuL21vdmUnKSlcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/move/index.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/move/move.js":
/*!**********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/move/move.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst copy = __webpack_require__(/*! ../copy */ \"../../node_modules/fs-extra/lib/copy/index.js\").copy\nconst remove = __webpack_require__(/*! ../remove */ \"../../node_modules/fs-extra/lib/remove/index.js\").remove\nconst mkdirp = __webpack_require__(/*! ../mkdirs */ \"../../node_modules/fs-extra/lib/mkdirs/index.js\").mkdirp\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"../../node_modules/fs-extra/lib/path-exists/index.js\").pathExists\nconst stat = __webpack_require__(/*! ../util/stat */ \"../../node_modules/fs-extra/lib/util/stat.js\")\n\nfunction move (src, dest, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  stat.checkPaths(src, dest, 'move', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'move', err => {\n      if (err) return cb(err)\n      mkdirp(path.dirname(dest), err => {\n        if (err) return cb(err)\n        return doRename(src, dest, overwrite, cb)\n      })\n    })\n  })\n}\n\nfunction doRename (src, dest, overwrite, cb) {\n  if (overwrite) {\n    return remove(dest, err => {\n      if (err) return cb(err)\n      return rename(src, dest, overwrite, cb)\n    })\n  }\n  pathExists(dest, (err, destExists) => {\n    if (err) return cb(err)\n    if (destExists) return cb(new Error('dest already exists.'))\n    return rename(src, dest, overwrite, cb)\n  })\n}\n\nfunction rename (src, dest, overwrite, cb) {\n  fs.rename(src, dest, err => {\n    if (!err) return cb()\n    if (err.code !== 'EXDEV') return cb(err)\n    return moveAcrossDevice(src, dest, overwrite, cb)\n  })\n}\n\nfunction moveAcrossDevice (src, dest, overwrite, cb) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copy(src, dest, opts, err => {\n    if (err) return cb(err)\n    return remove(src, cb)\n  })\n}\n\nmodule.exports = move\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlL21vdmUuanM/ZWQ2NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsa0VBQWE7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQyw4REFBUztBQUM5QixlQUFlLG1CQUFPLENBQUMsa0VBQVc7QUFDbEMsZUFBZSxtQkFBTyxDQUFDLGtFQUFXO0FBQ2xDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFnQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMsa0VBQWM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUvbW92ZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGNvcHkgPSByZXF1aXJlKCcuLi9jb3B5JykuY29weVxuY29uc3QgcmVtb3ZlID0gcmVxdWlyZSgnLi4vcmVtb3ZlJykucmVtb3ZlXG5jb25zdCBta2RpcnAgPSByZXF1aXJlKCcuLi9ta2RpcnMnKS5ta2RpcnBcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcbmNvbnN0IHN0YXQgPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5mdW5jdGlvbiBtb3ZlIChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9XG5cbiAgY29uc3Qgb3ZlcndyaXRlID0gb3B0cy5vdmVyd3JpdGUgfHwgb3B0cy5jbG9iYmVyIHx8IGZhbHNlXG5cbiAgc3RhdC5jaGVja1BhdGhzKHNyYywgZGVzdCwgJ21vdmUnLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgY29uc3QgeyBzcmNTdGF0IH0gPSBzdGF0c1xuICAgIHN0YXQuY2hlY2tQYXJlbnRQYXRocyhzcmMsIHNyY1N0YXQsIGRlc3QsICdtb3ZlJywgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICBta2RpcnAocGF0aC5kaXJuYW1lKGRlc3QpLCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgICByZXR1cm4gZG9SZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBkb1JlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKSB7XG4gIGlmIChvdmVyd3JpdGUpIHtcbiAgICByZXR1cm4gcmVtb3ZlKGRlc3QsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIHJlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2IpXG4gICAgfSlcbiAgfVxuICBwYXRoRXhpc3RzKGRlc3QsIChlcnIsIGRlc3RFeGlzdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChkZXN0RXhpc3RzKSByZXR1cm4gY2IobmV3IEVycm9yKCdkZXN0IGFscmVhZHkgZXhpc3RzLicpKVxuICAgIHJldHVybiByZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiByZW5hbWUgKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYikge1xuICBmcy5yZW5hbWUoc3JjLCBkZXN0LCBlcnIgPT4ge1xuICAgIGlmICghZXJyKSByZXR1cm4gY2IoKVxuICAgIGlmIChlcnIuY29kZSAhPT0gJ0VYREVWJykgcmV0dXJuIGNiKGVycilcbiAgICByZXR1cm4gbW92ZUFjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1vdmVBY3Jvc3NEZXZpY2UgKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYikge1xuICBjb25zdCBvcHRzID0ge1xuICAgIG92ZXJ3cml0ZSxcbiAgICBlcnJvck9uRXhpc3Q6IHRydWVcbiAgfVxuICBjb3B5KHNyYywgZGVzdCwgb3B0cywgZXJyID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiByZW1vdmUoc3JjLCBjYilcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtb3ZlXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/move/move.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/output/index.js":
/*!*************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/output/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../../node_modules/universalify/index.js\").fromCallback\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"../../node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"../../node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  const dir = path.dirname(file)\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, ...args) {\n  const dir = path.dirname(file)\n  if (fs.existsSync(dir)) {\n    return fs.writeFileSync(file, ...args)\n  }\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync(file, ...args)\n}\n\nmodule.exports = {\n  outputFile: u(outputFile),\n  outputFileSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9vdXRwdXQvaW5kZXguanM/MDNhMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixVQUFVLG1CQUFPLENBQUMsOERBQWM7QUFDaEMsV0FBVyxtQkFBTyxDQUFDLGtFQUFhO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixjQUFjLG1CQUFPLENBQUMsa0VBQVc7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQWdCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9vdXRwdXQvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5cbmZ1bmN0aW9uIG91dHB1dEZpbGUgKGZpbGUsIGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgcGF0aEV4aXN0cyhkaXIsIChlcnIsIGl0RG9lcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgaWYgKGl0RG9lcykgcmV0dXJuIGZzLndyaXRlRmlsZShmaWxlLCBkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spXG5cbiAgICBta2Rpci5ta2RpcnMoZGlyLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcblxuICAgICAgZnMud3JpdGVGaWxlKGZpbGUsIGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaylcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBvdXRwdXRGaWxlU3luYyAoZmlsZSwgLi4uYXJncykge1xuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgaWYgKGZzLmV4aXN0c1N5bmMoZGlyKSkge1xuICAgIHJldHVybiBmcy53cml0ZUZpbGVTeW5jKGZpbGUsIC4uLmFyZ3MpXG4gIH1cbiAgbWtkaXIubWtkaXJzU3luYyhkaXIpXG4gIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgLi4uYXJncylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG91dHB1dEZpbGU6IHUob3V0cHV0RmlsZSksXG4gIG91dHB1dEZpbGVTeW5jXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/output/index.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/path-exists/index.js":
/*!******************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/path-exists/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst u = __webpack_require__(/*! universalify */ \"../../node_modules/universalify/index.js\").fromPromise\nconst fs = __webpack_require__(/*! ../fs */ \"../../node_modules/fs-extra/lib/fs/index.js\")\n\nfunction pathExists (path) {\n  return fs.access(path).then(() => true).catch(() => false)\n}\n\nmodule.exports = {\n  pathExists: u(pathExists),\n  pathExistsSync: fs.existsSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9wYXRoLWV4aXN0cy9pbmRleC5qcz9kNjEyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFZO0FBQ1osVUFBVSxtQkFBTyxDQUFDLDhEQUFjO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQywwREFBTzs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvcGF0aC1leGlzdHMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5cbmZ1bmN0aW9uIHBhdGhFeGlzdHMgKHBhdGgpIHtcbiAgcmV0dXJuIGZzLmFjY2VzcyhwYXRoKS50aGVuKCgpID0+IHRydWUpLmNhdGNoKCgpID0+IGZhbHNlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGF0aEV4aXN0czogdShwYXRoRXhpc3RzKSxcbiAgcGF0aEV4aXN0c1N5bmM6IGZzLmV4aXN0c1N5bmNcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/path-exists/index.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/remove/index.js":
/*!*************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/remove/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../../node_modules/universalify/index.js\").fromCallback\nconst rimraf = __webpack_require__(/*! ./rimraf */ \"../../node_modules/fs-extra/lib/remove/rimraf.js\")\n\nmodule.exports = {\n  remove: u(rimraf),\n  removeSync: rimraf.sync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9yZW1vdmUvaW5kZXguanM/MjM3OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixVQUFVLG1CQUFPLENBQUMsOERBQWM7QUFDaEMsZUFBZSxtQkFBTyxDQUFDLGtFQUFVOztBQUVqQztBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3JlbW92ZS9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCByaW1yYWYgPSByZXF1aXJlKCcuL3JpbXJhZicpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZW1vdmU6IHUocmltcmFmKSxcbiAgcmVtb3ZlU3luYzogcmltcmFmLnN5bmNcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/remove/index.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/remove/rimraf.js":
/*!**************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/remove/rimraf.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\nconst isWindows = (process.platform === 'win32')\n\nfunction defaults (options) {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n}\n\nfunction rimraf (p, options, cb) {\n  let busyTries = 0\n\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  rimraf_(p, options, function CB (er) {\n    if (er) {\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\n          busyTries < options.maxBusyTries) {\n        busyTries++\n        const time = busyTries * 100\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time)\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null\n    }\n\n    cb(er)\n  })\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null)\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb)\n    }\n\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb)\n    }\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null)\n        }\n        if (er.code === 'EPERM') {\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb)\n        }\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er)\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er)\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb)\n        } else {\n          options.unlink(p, cb)\n        }\n      })\n    }\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  let stats\n\n  assert(p)\n  assert(options)\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er)\n  } else {\n    options.unlinkSync(p)\n  }\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb)\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr)\n    } else {\n      cb(er)\n    }\n  })\n}\n\nfunction rmkids (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er)\n\n    let n = files.length\n    let errState\n\n    if (n === 0) return options.rmdir(p, cb)\n\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return\n        }\n        if (er) return cb(errState = er)\n        if (--n === 0) {\n          options.rmdir(p, cb)\n        }\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  let st\n\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  try {\n    st = options.lstatSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er)\n    }\n  }\n\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null)\n    } else {\n      options.unlinkSync(p)\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n    } else if (er.code !== 'EISDIR') {\n      throw er\n    }\n    rmdirSync(p, options, er)\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === 'ENOTDIR') {\n      throw originalEr\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options)\n    } else if (er.code !== 'ENOENT') {\n      throw er\n    }\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  if (isWindows) {\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const startTime = Date.now()\n    do {\n      try {\n        const ret = options.rmdirSync(p, options)\n        return ret\n      } catch (er) { }\n    } while (Date.now() - startTime < 500) // give up after 500ms\n  } else {\n    const ret = options.rmdirSync(p, options)\n    return ret\n  }\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9yZW1vdmUvcmltcmFmLmpzPzIyMzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLGtFQUFhO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixlQUFlLG1CQUFPLENBQUMsc0JBQVE7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxhQUFhO0FBQ3BCLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3JlbW92ZS9yaW1yYWYuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuXG5jb25zdCBpc1dpbmRvd3MgPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJylcblxuZnVuY3Rpb24gZGVmYXVsdHMgKG9wdGlvbnMpIHtcbiAgY29uc3QgbWV0aG9kcyA9IFtcbiAgICAndW5saW5rJyxcbiAgICAnY2htb2QnLFxuICAgICdzdGF0JyxcbiAgICAnbHN0YXQnLFxuICAgICdybWRpcicsXG4gICAgJ3JlYWRkaXInXG4gIF1cbiAgbWV0aG9kcy5mb3JFYWNoKG0gPT4ge1xuICAgIG9wdGlvbnNbbV0gPSBvcHRpb25zW21dIHx8IGZzW21dXG4gICAgbSA9IG0gKyAnU3luYydcbiAgICBvcHRpb25zW21dID0gb3B0aW9uc1ttXSB8fCBmc1ttXVxuICB9KVxuXG4gIG9wdGlvbnMubWF4QnVzeVRyaWVzID0gb3B0aW9ucy5tYXhCdXN5VHJpZXMgfHwgM1xufVxuXG5mdW5jdGlvbiByaW1yYWYgKHAsIG9wdGlvbnMsIGNiKSB7XG4gIGxldCBidXN5VHJpZXMgPSAwXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICBhc3NlcnQocCwgJ3JpbXJhZjogbWlzc2luZyBwYXRoJylcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBwLCAnc3RyaW5nJywgJ3JpbXJhZjogcGF0aCBzaG91bGQgYmUgYSBzdHJpbmcnKVxuICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIGNiLCAnZnVuY3Rpb24nLCAncmltcmFmOiBjYWxsYmFjayBmdW5jdGlvbiByZXF1aXJlZCcpXG4gIGFzc2VydChvcHRpb25zLCAncmltcmFmOiBpbnZhbGlkIG9wdGlvbnMgYXJndW1lbnQgcHJvdmlkZWQnKVxuICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIG9wdGlvbnMsICdvYmplY3QnLCAncmltcmFmOiBvcHRpb25zIHNob3VsZCBiZSBvYmplY3QnKVxuXG4gIGRlZmF1bHRzKG9wdGlvbnMpXG5cbiAgcmltcmFmXyhwLCBvcHRpb25zLCBmdW5jdGlvbiBDQiAoZXIpIHtcbiAgICBpZiAoZXIpIHtcbiAgICAgIGlmICgoZXIuY29kZSA9PT0gJ0VCVVNZJyB8fCBlci5jb2RlID09PSAnRU5PVEVNUFRZJyB8fCBlci5jb2RlID09PSAnRVBFUk0nKSAmJlxuICAgICAgICAgIGJ1c3lUcmllcyA8IG9wdGlvbnMubWF4QnVzeVRyaWVzKSB7XG4gICAgICAgIGJ1c3lUcmllcysrXG4gICAgICAgIGNvbnN0IHRpbWUgPSBidXN5VHJpZXMgKiAxMDBcbiAgICAgICAgLy8gdHJ5IGFnYWluLCB3aXRoIHRoZSBzYW1lIGV4YWN0IGNhbGxiYWNrIGFzIHRoaXMgb25lLlxuICAgICAgICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiByaW1yYWZfKHAsIG9wdGlvbnMsIENCKSwgdGltZSlcbiAgICAgIH1cblxuICAgICAgLy8gYWxyZWFkeSBnb25lXG4gICAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIGVyID0gbnVsbFxuICAgIH1cblxuICAgIGNiKGVyKVxuICB9KVxufVxuXG4vLyBUd28gcG9zc2libGUgc3RyYXRlZ2llcy5cbi8vIDEuIEFzc3VtZSBpdCdzIGEgZmlsZS4gIHVubGluayBpdCwgdGhlbiBkbyB0aGUgZGlyIHN0dWZmIG9uIEVQRVJNIG9yIEVJU0RJUlxuLy8gMi4gQXNzdW1lIGl0J3MgYSBkaXJlY3RvcnkuICByZWFkZGlyLCB0aGVuIGRvIHRoZSBmaWxlIHN0dWZmIG9uIEVOT1RESVJcbi8vXG4vLyBCb3RoIHJlc3VsdCBpbiBhbiBleHRyYSBzeXNjYWxsIHdoZW4geW91IGd1ZXNzIHdyb25nLiAgSG93ZXZlciwgdGhlcmVcbi8vIGFyZSBsaWtlbHkgZmFyIG1vcmUgbm9ybWFsIGZpbGVzIGluIHRoZSB3b3JsZCB0aGFuIGRpcmVjdG9yaWVzLiAgVGhpc1xuLy8gaXMgYmFzZWQgb24gdGhlIGFzc3VtcHRpb24gdGhhdCBhIHRoZSBhdmVyYWdlIG51bWJlciBvZiBmaWxlcyBwZXJcbi8vIGRpcmVjdG9yeSBpcyA+PSAxLlxuLy9cbi8vIElmIGFueW9uZSBldmVyIGNvbXBsYWlucyBhYm91dCB0aGlzLCB0aGVuIEkgZ3Vlc3MgdGhlIHN0cmF0ZWd5IGNvdWxkXG4vLyBiZSBtYWRlIGNvbmZpZ3VyYWJsZSBzb21laG93LiAgQnV0IHVudGlsIHRoZW4sIFlBR05JLlxuZnVuY3Rpb24gcmltcmFmXyAocCwgb3B0aW9ucywgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIC8vIHN1bm9zIGxldHMgdGhlIHJvb3QgdXNlciB1bmxpbmsgZGlyZWN0b3JpZXMsIHdoaWNoIGlzLi4uIHdlaXJkLlxuICAvLyBzbyB3ZSBoYXZlIHRvIGxzdGF0IGhlcmUgYW5kIG1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpci5cbiAgb3B0aW9ucy5sc3RhdChwLCAoZXIsIHN0KSA9PiB7XG4gICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm4gY2IobnVsbClcbiAgICB9XG5cbiAgICAvLyBXaW5kb3dzIGNhbiBFUEVSTSBvbiBzdGF0LiAgTGlmZSBpcyBzdWZmZXJpbmcuXG4gICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFUEVSTScgJiYgaXNXaW5kb3dzKSB7XG4gICAgICByZXR1cm4gZml4V2luRVBFUk0ocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgIH1cblxuICAgIGlmIChzdCAmJiBzdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICByZXR1cm4gcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgIH1cblxuICAgIG9wdGlvbnMudW5saW5rKHAsIGVyID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbClcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgICAgIHJldHVybiAoaXNXaW5kb3dzKVxuICAgICAgICAgICAgPyBmaXhXaW5FUEVSTShwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgICAgICA6IHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VJU0RJUicpIHtcbiAgICAgICAgICByZXR1cm4gcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2IoZXIpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gZml4V2luRVBFUk0gKHAsIG9wdGlvbnMsIGVyLCBjYikge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGFzc2VydCh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gIGlmIChlcikge1xuICAgIGFzc2VydChlciBpbnN0YW5jZW9mIEVycm9yKVxuICB9XG5cbiAgb3B0aW9ucy5jaG1vZChwLCAwbzY2NiwgZXIyID0+IHtcbiAgICBpZiAoZXIyKSB7XG4gICAgICBjYihlcjIuY29kZSA9PT0gJ0VOT0VOVCcgPyBudWxsIDogZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuc3RhdChwLCAoZXIzLCBzdGF0cykgPT4ge1xuICAgICAgICBpZiAoZXIzKSB7XG4gICAgICAgICAgY2IoZXIzLmNvZGUgPT09ICdFTk9FTlQnID8gbnVsbCA6IGVyKVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICBybWRpcihwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy51bmxpbmsocCwgY2IpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBmaXhXaW5FUEVSTVN5bmMgKHAsIG9wdGlvbnMsIGVyKSB7XG4gIGxldCBzdGF0c1xuXG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgaWYgKGVyKSB7XG4gICAgYXNzZXJ0KGVyIGluc3RhbmNlb2YgRXJyb3IpXG4gIH1cblxuICB0cnkge1xuICAgIG9wdGlvbnMuY2htb2RTeW5jKHAsIDBvNjY2KVxuICB9IGNhdGNoIChlcjIpIHtcbiAgICBpZiAoZXIyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIHN0YXRzID0gb3B0aW9ucy5zdGF0U3luYyhwKVxuICB9IGNhdGNoIChlcjMpIHtcbiAgICBpZiAoZXIzLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIHJtZGlyU3luYyhwLCBvcHRpb25zLCBlcilcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLnVubGlua1N5bmMocClcbiAgfVxufVxuXG5mdW5jdGlvbiBybWRpciAocCwgb3B0aW9ucywgb3JpZ2luYWxFciwgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBpZiAob3JpZ2luYWxFcikge1xuICAgIGFzc2VydChvcmlnaW5hbEVyIGluc3RhbmNlb2YgRXJyb3IpXG4gIH1cbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICAvLyB0cnkgdG8gcm1kaXIgZmlyc3QsIGFuZCBvbmx5IHJlYWRkaXIgb24gRU5PVEVNUFRZIG9yIEVFWElTVCAoU3VuT1MpXG4gIC8vIGlmIHdlIGd1ZXNzZWQgd3JvbmcsIGFuZCBpdCdzIG5vdCBhIGRpcmVjdG9yeSwgdGhlblxuICAvLyByYWlzZSB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gIG9wdGlvbnMucm1kaXIocCwgZXIgPT4ge1xuICAgIGlmIChlciAmJiAoZXIuY29kZSA9PT0gJ0VOT1RFTVBUWScgfHwgZXIuY29kZSA9PT0gJ0VFWElTVCcgfHwgZXIuY29kZSA9PT0gJ0VQRVJNJykpIHtcbiAgICAgIHJta2lkcyhwLCBvcHRpb25zLCBjYilcbiAgICB9IGVsc2UgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFTk9URElSJykge1xuICAgICAgY2Iob3JpZ2luYWxFcilcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoZXIpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBybWtpZHMgKHAsIG9wdGlvbnMsIGNiKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICBvcHRpb25zLnJlYWRkaXIocCwgKGVyLCBmaWxlcykgPT4ge1xuICAgIGlmIChlcikgcmV0dXJuIGNiKGVyKVxuXG4gICAgbGV0IG4gPSBmaWxlcy5sZW5ndGhcbiAgICBsZXQgZXJyU3RhdGVcblxuICAgIGlmIChuID09PSAwKSByZXR1cm4gb3B0aW9ucy5ybWRpcihwLCBjYilcblxuICAgIGZpbGVzLmZvckVhY2goZiA9PiB7XG4gICAgICByaW1yYWYocGF0aC5qb2luKHAsIGYpLCBvcHRpb25zLCBlciA9PiB7XG4gICAgICAgIGlmIChlcnJTdGF0ZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChlcikgcmV0dXJuIGNiKGVyclN0YXRlID0gZXIpXG4gICAgICAgIGlmICgtLW4gPT09IDApIHtcbiAgICAgICAgICBvcHRpb25zLnJtZGlyKHAsIGNiKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIHRoaXMgbG9va3Mgc2ltcGxlciwgYW5kIGlzIHN0cmljdGx5ICpmYXN0ZXIqLCBidXQgd2lsbFxuLy8gdGllIHVwIHRoZSBKYXZhU2NyaXB0IHRocmVhZCBhbmQgZmFpbCBvbiBleGNlc3NpdmVseVxuLy8gZGVlcCBkaXJlY3RvcnkgdHJlZXMuXG5mdW5jdGlvbiByaW1yYWZTeW5jIChwLCBvcHRpb25zKSB7XG4gIGxldCBzdFxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIGRlZmF1bHRzKG9wdGlvbnMpXG5cbiAgYXNzZXJ0KHAsICdyaW1yYWY6IG1pc3NpbmcgcGF0aCcpXG4gIGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlb2YgcCwgJ3N0cmluZycsICdyaW1yYWY6IHBhdGggc2hvdWxkIGJlIGEgc3RyaW5nJylcbiAgYXNzZXJ0KG9wdGlvbnMsICdyaW1yYWY6IG1pc3Npbmcgb3B0aW9ucycpXG4gIGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlb2Ygb3B0aW9ucywgJ29iamVjdCcsICdyaW1yYWY6IG9wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCcpXG5cbiAgdHJ5IHtcbiAgICBzdCA9IG9wdGlvbnMubHN0YXRTeW5jKHApXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBXaW5kb3dzIGNhbiBFUEVSTSBvbiBzdGF0LiAgTGlmZSBpcyBzdWZmZXJpbmcuXG4gICAgaWYgKGVyLmNvZGUgPT09ICdFUEVSTScgJiYgaXNXaW5kb3dzKSB7XG4gICAgICBmaXhXaW5FUEVSTVN5bmMocCwgb3B0aW9ucywgZXIpXG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBzdW5vcyBsZXRzIHRoZSByb290IHVzZXIgdW5saW5rIGRpcmVjdG9yaWVzLCB3aGljaCBpcy4uLiB3ZWlyZC5cbiAgICBpZiAoc3QgJiYgc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgcm1kaXJTeW5jKHAsIG9wdGlvbnMsIG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMudW5saW5rU3luYyhwKVxuICAgIH1cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSBpZiAoZXIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgcmV0dXJuIGlzV2luZG93cyA/IGZpeFdpbkVQRVJNU3luYyhwLCBvcHRpb25zLCBlcikgOiBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gICAgfSBlbHNlIGlmIChlci5jb2RlICE9PSAnRUlTRElSJykge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gICAgcm1kaXJTeW5jKHAsIG9wdGlvbnMsIGVyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJtZGlyU3luYyAocCwgb3B0aW9ucywgb3JpZ2luYWxFcikge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGlmIChvcmlnaW5hbEVyKSB7XG4gICAgYXNzZXJ0KG9yaWdpbmFsRXIgaW5zdGFuY2VvZiBFcnJvcilcbiAgfVxuXG4gIHRyeSB7XG4gICAgb3B0aW9ucy5ybWRpclN5bmMocClcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT1RESVInKSB7XG4gICAgICB0aHJvdyBvcmlnaW5hbEVyXG4gICAgfSBlbHNlIGlmIChlci5jb2RlID09PSAnRU5PVEVNUFRZJyB8fCBlci5jb2RlID09PSAnRUVYSVNUJyB8fCBlci5jb2RlID09PSAnRVBFUk0nKSB7XG4gICAgICBybWtpZHNTeW5jKHAsIG9wdGlvbnMpXG4gICAgfSBlbHNlIGlmIChlci5jb2RlICE9PSAnRU5PRU5UJykge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcm1raWRzU3luYyAocCwgb3B0aW9ucykge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIG9wdGlvbnMucmVhZGRpclN5bmMocCkuZm9yRWFjaChmID0+IHJpbXJhZlN5bmMocGF0aC5qb2luKHAsIGYpLCBvcHRpb25zKSlcblxuICBpZiAoaXNXaW5kb3dzKSB7XG4gICAgLy8gV2Ugb25seSBlbmQgdXAgaGVyZSBvbmNlIHdlIGdvdCBFTk9URU1QVFkgYXQgbGVhc3Qgb25jZSwgYW5kXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgd2UgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSByZW1vdmVkIGFsbCB0aGUga2lkcy5cbiAgICAvLyBTbywgd2Uga25vdyB0aGF0IGl0IHdvbid0IGJlIEVOT0VOVCBvciBFTk9URElSIG9yIGFueXRoaW5nIGVsc2UuXG4gICAgLy8gdHJ5IHJlYWxseSBoYXJkIHRvIGRlbGV0ZSBzdHVmZiBvbiB3aW5kb3dzLCBiZWNhdXNlIGl0IGhhcyBhXG4gICAgLy8gUFJPRk9VTkRMWSBhbm5veWluZyBoYWJpdCBvZiBub3QgY2xvc2luZyBoYW5kbGVzIHByb21wdGx5IHdoZW5cbiAgICAvLyBmaWxlcyBhcmUgZGVsZXRlZCwgcmVzdWx0aW5nIGluIHNwdXJpb3VzIEVOT1RFTVBUWSBlcnJvcnMuXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKVxuICAgIGRvIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG9wdGlvbnMucm1kaXJTeW5jKHAsIG9wdGlvbnMpXG4gICAgICAgIHJldHVybiByZXRcbiAgICAgIH0gY2F0Y2ggKGVyKSB7IH1cbiAgICB9IHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgNTAwKSAvLyBnaXZlIHVwIGFmdGVyIDUwMG1zXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmV0ID0gb3B0aW9ucy5ybWRpclN5bmMocCwgb3B0aW9ucylcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByaW1yYWZcbnJpbXJhZi5zeW5jID0gcmltcmFmU3luY1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/remove/rimraf.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/util/buffer.js":
/*!************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/util/buffer.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable node/no-deprecated-api */\nmodule.exports = function (size) {\n  if (typeof Buffer.allocUnsafe === 'function') {\n    try {\n      return Buffer.allocUnsafe(size)\n    } catch (e) {\n      return new Buffer(size)\n    }\n  }\n  return new Buffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi91dGlsL2J1ZmZlci5qcz9hYzgwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvdXRpbC9idWZmZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpXG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKHNpemUpXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/util/buffer.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/util/stat.js":
/*!**********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/util/stat.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\nconst NODE_VERSION_MAJOR_WITH_BIGINT = 10\nconst NODE_VERSION_MINOR_WITH_BIGINT = 5\nconst NODE_VERSION_PATCH_WITH_BIGINT = 0\nconst nodeVersion = process.versions.node.split('.')\nconst nodeVersionMajor = Number.parseInt(nodeVersion[0], 10)\nconst nodeVersionMinor = Number.parseInt(nodeVersion[1], 10)\nconst nodeVersionPatch = Number.parseInt(nodeVersion[2], 10)\n\nfunction nodeSupportsBigInt () {\n  if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {\n    return true\n  } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {\n    if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {\n      return true\n    } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {\n      if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfunction getStats (src, dest, cb) {\n  if (nodeSupportsBigInt()) {\n    fs.stat(src, { bigint: true }, (err, srcStat) => {\n      if (err) return cb(err)\n      fs.stat(dest, { bigint: true }, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\n          return cb(err)\n        }\n        return cb(null, { srcStat, destStat })\n      })\n    })\n  } else {\n    fs.stat(src, (err, srcStat) => {\n      if (err) return cb(err)\n      fs.stat(dest, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\n          return cb(err)\n        }\n        return cb(null, { srcStat, destStat })\n      })\n    })\n  }\n}\n\nfunction getStatsSync (src, dest) {\n  let srcStat, destStat\n  if (nodeSupportsBigInt()) {\n    srcStat = fs.statSync(src, { bigint: true })\n  } else {\n    srcStat = fs.statSync(src)\n  }\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(dest, { bigint: true })\n    } else {\n      destStat = fs.statSync(dest)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, cb) {\n  getStats(src, dest, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n      return cb(new Error('Source and destination must not be the same.'))\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName) {\n  const { srcStat, destStat } = getStatsSync(src, dest)\n  if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error('Source and destination must not be the same.')\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  if (nodeSupportsBigInt()) {\n    fs.stat(destParent, { bigint: true }, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb()\n        return cb(err)\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)))\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\n    })\n  } else {\n    fs.stat(destParent, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb()\n        return cb(err)\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)))\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\n    })\n  }\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(destParent, { bigint: true })\n    } else {\n      destStat = fs.statSync(destParent)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi91dGlsL3N0YXQuanM/NDhmZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsa0VBQWE7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBLHNEQUFzRCwwQkFBMEI7QUFDaEY7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0MsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsMEJBQTBCO0FBQ2hGO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZUFBZTtBQUNuRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSCx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxlQUFlO0FBQ3pELEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsU0FBUyxJQUFJLElBQUksa0NBQWtDLEtBQUs7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi91dGlsL3N0YXQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbmNvbnN0IE5PREVfVkVSU0lPTl9NQUpPUl9XSVRIX0JJR0lOVCA9IDEwXG5jb25zdCBOT0RFX1ZFUlNJT05fTUlOT1JfV0lUSF9CSUdJTlQgPSA1XG5jb25zdCBOT0RFX1ZFUlNJT05fUEFUQ0hfV0lUSF9CSUdJTlQgPSAwXG5jb25zdCBub2RlVmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdCgnLicpXG5jb25zdCBub2RlVmVyc2lvbk1ham9yID0gTnVtYmVyLnBhcnNlSW50KG5vZGVWZXJzaW9uWzBdLCAxMClcbmNvbnN0IG5vZGVWZXJzaW9uTWlub3IgPSBOdW1iZXIucGFyc2VJbnQobm9kZVZlcnNpb25bMV0sIDEwKVxuY29uc3Qgbm9kZVZlcnNpb25QYXRjaCA9IE51bWJlci5wYXJzZUludChub2RlVmVyc2lvblsyXSwgMTApXG5cbmZ1bmN0aW9uIG5vZGVTdXBwb3J0c0JpZ0ludCAoKSB7XG4gIGlmIChub2RlVmVyc2lvbk1ham9yID4gTk9ERV9WRVJTSU9OX01BSk9SX1dJVEhfQklHSU5UKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmIChub2RlVmVyc2lvbk1ham9yID09PSBOT0RFX1ZFUlNJT05fTUFKT1JfV0lUSF9CSUdJTlQpIHtcbiAgICBpZiAobm9kZVZlcnNpb25NaW5vciA+IE5PREVfVkVSU0lPTl9NSU5PUl9XSVRIX0JJR0lOVCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKG5vZGVWZXJzaW9uTWlub3IgPT09IE5PREVfVkVSU0lPTl9NSU5PUl9XSVRIX0JJR0lOVCkge1xuICAgICAgaWYgKG5vZGVWZXJzaW9uUGF0Y2ggPj0gTk9ERV9WRVJTSU9OX1BBVENIX1dJVEhfQklHSU5UKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0cyAoc3JjLCBkZXN0LCBjYikge1xuICBpZiAobm9kZVN1cHBvcnRzQmlnSW50KCkpIHtcbiAgICBmcy5zdGF0KHNyYywgeyBiaWdpbnQ6IHRydWUgfSwgKGVyciwgc3JjU3RhdCkgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIGZzLnN0YXQoZGVzdCwgeyBiaWdpbnQ6IHRydWUgfSwgKGVyciwgZGVzdFN0YXQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVybiBjYihudWxsLCB7IHNyY1N0YXQsIGRlc3RTdGF0OiBudWxsIH0pXG4gICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2IobnVsbCwgeyBzcmNTdGF0LCBkZXN0U3RhdCB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGZzLnN0YXQoc3JjLCAoZXJyLCBzcmNTdGF0KSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgZnMuc3RhdChkZXN0LCAoZXJyLCBkZXN0U3RhdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuIGNiKG51bGwsIHsgc3JjU3RhdCwgZGVzdFN0YXQ6IG51bGwgfSlcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYihudWxsLCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U3RhdHNTeW5jIChzcmMsIGRlc3QpIHtcbiAgbGV0IHNyY1N0YXQsIGRlc3RTdGF0XG4gIGlmIChub2RlU3VwcG9ydHNCaWdJbnQoKSkge1xuICAgIHNyY1N0YXQgPSBmcy5zdGF0U3luYyhzcmMsIHsgYmlnaW50OiB0cnVlIH0pXG4gIH0gZWxzZSB7XG4gICAgc3JjU3RhdCA9IGZzLnN0YXRTeW5jKHNyYylcbiAgfVxuICB0cnkge1xuICAgIGlmIChub2RlU3VwcG9ydHNCaWdJbnQoKSkge1xuICAgICAgZGVzdFN0YXQgPSBmcy5zdGF0U3luYyhkZXN0LCB7IGJpZ2ludDogdHJ1ZSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBkZXN0U3RhdCA9IGZzLnN0YXRTeW5jKGRlc3QpXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdDogbnVsbCB9XG4gICAgdGhyb3cgZXJyXG4gIH1cbiAgcmV0dXJuIHsgc3JjU3RhdCwgZGVzdFN0YXQgfVxufVxuXG5mdW5jdGlvbiBjaGVja1BhdGhzIChzcmMsIGRlc3QsIGZ1bmNOYW1lLCBjYikge1xuICBnZXRTdGF0cyhzcmMsIGRlc3QsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb25zdCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0gPSBzdGF0c1xuICAgIGlmIChkZXN0U3RhdCAmJiBkZXN0U3RhdC5pbm8gJiYgZGVzdFN0YXQuZGV2ICYmIGRlc3RTdGF0LmlubyA9PT0gc3JjU3RhdC5pbm8gJiYgZGVzdFN0YXQuZGV2ID09PSBzcmNTdGF0LmRldikge1xuICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignU291cmNlIGFuZCBkZXN0aW5hdGlvbiBtdXN0IG5vdCBiZSB0aGUgc2FtZS4nKSlcbiAgICB9XG4gICAgaWYgKHNyY1N0YXQuaXNEaXJlY3RvcnkoKSAmJiBpc1NyY1N1YmRpcihzcmMsIGRlc3QpKSB7XG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKGVyck1zZyhzcmMsIGRlc3QsIGZ1bmNOYW1lKSkpXG4gICAgfVxuICAgIHJldHVybiBjYihudWxsLCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNoZWNrUGF0aHNTeW5jIChzcmMsIGRlc3QsIGZ1bmNOYW1lKSB7XG4gIGNvbnN0IHsgc3JjU3RhdCwgZGVzdFN0YXQgfSA9IGdldFN0YXRzU3luYyhzcmMsIGRlc3QpXG4gIGlmIChkZXN0U3RhdCAmJiBkZXN0U3RhdC5pbm8gJiYgZGVzdFN0YXQuZGV2ICYmIGRlc3RTdGF0LmlubyA9PT0gc3JjU3RhdC5pbm8gJiYgZGVzdFN0YXQuZGV2ID09PSBzcmNTdGF0LmRldikge1xuICAgIHRocm93IG5ldyBFcnJvcignU291cmNlIGFuZCBkZXN0aW5hdGlvbiBtdXN0IG5vdCBiZSB0aGUgc2FtZS4nKVxuICB9XG4gIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgaXNTcmNTdWJkaXIoc3JjLCBkZXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2coc3JjLCBkZXN0LCBmdW5jTmFtZSkpXG4gIH1cbiAgcmV0dXJuIHsgc3JjU3RhdCwgZGVzdFN0YXQgfVxufVxuXG4vLyByZWN1cnNpdmVseSBjaGVjayBpZiBkZXN0IHBhcmVudCBpcyBhIHN1YmRpcmVjdG9yeSBvZiBzcmMuXG4vLyBJdCB3b3JrcyBmb3IgYWxsIGZpbGUgdHlwZXMgaW5jbHVkaW5nIHN5bWxpbmtzIHNpbmNlIGl0XG4vLyBjaGVja3MgdGhlIHNyYyBhbmQgZGVzdCBpbm9kZXMuIEl0IHN0YXJ0cyBmcm9tIHRoZSBkZWVwZXN0XG4vLyBwYXJlbnQgYW5kIHN0b3BzIG9uY2UgaXQgcmVhY2hlcyB0aGUgc3JjIHBhcmVudCBvciB0aGUgcm9vdCBwYXRoLlxuZnVuY3Rpb24gY2hlY2tQYXJlbnRQYXRocyAoc3JjLCBzcmNTdGF0LCBkZXN0LCBmdW5jTmFtZSwgY2IpIHtcbiAgY29uc3Qgc3JjUGFyZW50ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShzcmMpKVxuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShkZXN0KSlcbiAgaWYgKGRlc3RQYXJlbnQgPT09IHNyY1BhcmVudCB8fCBkZXN0UGFyZW50ID09PSBwYXRoLnBhcnNlKGRlc3RQYXJlbnQpLnJvb3QpIHJldHVybiBjYigpXG4gIGlmIChub2RlU3VwcG9ydHNCaWdJbnQoKSkge1xuICAgIGZzLnN0YXQoZGVzdFBhcmVudCwgeyBiaWdpbnQ6IHRydWUgfSwgKGVyciwgZGVzdFN0YXQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuIGNiKClcbiAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgIH1cbiAgICAgIGlmIChkZXN0U3RhdC5pbm8gJiYgZGVzdFN0YXQuZGV2ICYmIGRlc3RTdGF0LmlubyA9PT0gc3JjU3RhdC5pbm8gJiYgZGVzdFN0YXQuZGV2ID09PSBzcmNTdGF0LmRldikge1xuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGVyck1zZyhzcmMsIGRlc3QsIGZ1bmNOYW1lKSkpXG4gICAgICB9XG4gICAgICByZXR1cm4gY2hlY2tQYXJlbnRQYXRocyhzcmMsIHNyY1N0YXQsIGRlc3RQYXJlbnQsIGZ1bmNOYW1lLCBjYilcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGZzLnN0YXQoZGVzdFBhcmVudCwgKGVyciwgZGVzdFN0YXQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuIGNiKClcbiAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgIH1cbiAgICAgIGlmIChkZXN0U3RhdC5pbm8gJiYgZGVzdFN0YXQuZGV2ICYmIGRlc3RTdGF0LmlubyA9PT0gc3JjU3RhdC5pbm8gJiYgZGVzdFN0YXQuZGV2ID09PSBzcmNTdGF0LmRldikge1xuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGVyck1zZyhzcmMsIGRlc3QsIGZ1bmNOYW1lKSkpXG4gICAgICB9XG4gICAgICByZXR1cm4gY2hlY2tQYXJlbnRQYXRocyhzcmMsIHNyY1N0YXQsIGRlc3RQYXJlbnQsIGZ1bmNOYW1lLCBjYilcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUGFyZW50UGF0aHNTeW5jIChzcmMsIHNyY1N0YXQsIGRlc3QsIGZ1bmNOYW1lKSB7XG4gIGNvbnN0IHNyY1BhcmVudCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoc3JjKSlcbiAgY29uc3QgZGVzdFBhcmVudCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoZGVzdCkpXG4gIGlmIChkZXN0UGFyZW50ID09PSBzcmNQYXJlbnQgfHwgZGVzdFBhcmVudCA9PT0gcGF0aC5wYXJzZShkZXN0UGFyZW50KS5yb290KSByZXR1cm5cbiAgbGV0IGRlc3RTdGF0XG4gIHRyeSB7XG4gICAgaWYgKG5vZGVTdXBwb3J0c0JpZ0ludCgpKSB7XG4gICAgICBkZXN0U3RhdCA9IGZzLnN0YXRTeW5jKGRlc3RQYXJlbnQsIHsgYmlnaW50OiB0cnVlIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc3RTdGF0ID0gZnMuc3RhdFN5bmMoZGVzdFBhcmVudClcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVyblxuICAgIHRocm93IGVyclxuICB9XG4gIGlmIChkZXN0U3RhdC5pbm8gJiYgZGVzdFN0YXQuZGV2ICYmIGRlc3RTdGF0LmlubyA9PT0gc3JjU3RhdC5pbm8gJiYgZGVzdFN0YXQuZGV2ID09PSBzcmNTdGF0LmRldikge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2coc3JjLCBkZXN0LCBmdW5jTmFtZSkpXG4gIH1cbiAgcmV0dXJuIGNoZWNrUGFyZW50UGF0aHNTeW5jKHNyYywgc3JjU3RhdCwgZGVzdFBhcmVudCwgZnVuY05hbWUpXG59XG5cbi8vIHJldHVybiB0cnVlIGlmIGRlc3QgaXMgYSBzdWJkaXIgb2Ygc3JjLCBvdGhlcndpc2UgZmFsc2UuXG4vLyBJdCBvbmx5IGNoZWNrcyB0aGUgcGF0aCBzdHJpbmdzLlxuZnVuY3Rpb24gaXNTcmNTdWJkaXIgKHNyYywgZGVzdCkge1xuICBjb25zdCBzcmNBcnIgPSBwYXRoLnJlc29sdmUoc3JjKS5zcGxpdChwYXRoLnNlcCkuZmlsdGVyKGkgPT4gaSlcbiAgY29uc3QgZGVzdEFyciA9IHBhdGgucmVzb2x2ZShkZXN0KS5zcGxpdChwYXRoLnNlcCkuZmlsdGVyKGkgPT4gaSlcbiAgcmV0dXJuIHNyY0Fyci5yZWR1Y2UoKGFjYywgY3VyLCBpKSA9PiBhY2MgJiYgZGVzdEFycltpXSA9PT0gY3VyLCB0cnVlKVxufVxuXG5mdW5jdGlvbiBlcnJNc2cgKHNyYywgZGVzdCwgZnVuY05hbWUpIHtcbiAgcmV0dXJuIGBDYW5ub3QgJHtmdW5jTmFtZX0gJyR7c3JjfScgdG8gYSBzdWJkaXJlY3Rvcnkgb2YgaXRzZWxmLCAnJHtkZXN0fScuYFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2hlY2tQYXRocyxcbiAgY2hlY2tQYXRoc1N5bmMsXG4gIGNoZWNrUGFyZW50UGF0aHMsXG4gIGNoZWNrUGFyZW50UGF0aHNTeW5jLFxuICBpc1NyY1N1YmRpclxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/util/stat.js\n");

/***/ }),

/***/ "../../node_modules/fs-extra/lib/util/utimes.js":
/*!************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/fs-extra/lib/util/utimes.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\nconst os = __webpack_require__(/*! os */ \"os\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\n// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not\nfunction hasMillisResSync () {\n  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141')\n  const fd = fs.openSync(tmpfile, 'r+')\n  fs.futimesSync(fd, d, d)\n  fs.closeSync(fd)\n  return fs.statSync(tmpfile).mtime > 1435410243000\n}\n\nfunction hasMillisRes (callback) {\n  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {\n    if (err) return callback(err)\n    fs.open(tmpfile, 'r+', (err, fd) => {\n      if (err) return callback(err)\n      fs.futimes(fd, d, d, err => {\n        if (err) return callback(err)\n        fs.close(fd, err => {\n          if (err) return callback(err)\n          fs.stat(tmpfile, (err, stats) => {\n            if (err) return callback(err)\n            callback(null, stats.mtime > 1435410243000)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction timeRemoveMillis (timestamp) {\n  if (typeof timestamp === 'number') {\n    return Math.floor(timestamp / 1000) * 1000\n  } else if (timestamp instanceof Date) {\n    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)\n  } else {\n    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')\n  }\n}\n\nfunction utimesMillis (path, atime, mtime, callback) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  fs.open(path, 'r+', (err, fd) => {\n    if (err) return callback(err)\n    fs.futimes(fd, atime, mtime, futimesErr => {\n      fs.close(fd, closeErr => {\n        if (callback) callback(futimesErr || closeErr)\n      })\n    })\n  })\n}\n\nfunction utimesMillisSync (path, atime, mtime) {\n  const fd = fs.openSync(path, 'r+')\n  fs.futimesSync(fd, atime, mtime)\n  return fs.closeSync(fd)\n}\n\nmodule.exports = {\n  hasMillisRes,\n  hasMillisResSync,\n  timeRemoveMillis,\n  utimesMillis,\n  utimesMillisSync\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi91dGlsL3V0aW1lcy5qcz80NzJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFdBQVcsbUJBQU8sQ0FBQyxrRUFBYTtBQUNoQyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCLFlBQVksSUFBSTtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvdXRpbC91dGltZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuLy8gSEZTLCBleHR7MiwzfSwgRkFUIGRvIG5vdCwgTm9kZS5qcyB2MC4xMCBkb2VzIG5vdFxuZnVuY3Rpb24gaGFzTWlsbGlzUmVzU3luYyAoKSB7XG4gIGxldCB0bXBmaWxlID0gcGF0aC5qb2luKCdtaWxsaXMtdGVzdC1zeW5jJyArIERhdGUubm93KCkudG9TdHJpbmcoKSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zbGljZSgyKSlcbiAgdG1wZmlsZSA9IHBhdGguam9pbihvcy50bXBkaXIoKSwgdG1wZmlsZSlcblxuICAvLyA1NTAgbWlsbGlzIHBhc3QgVU5JWCBlcG9jaFxuICBjb25zdCBkID0gbmV3IERhdGUoMTQzNTQxMDI0Mzg2MilcbiAgZnMud3JpdGVGaWxlU3luYyh0bXBmaWxlLCAnaHR0cHM6Ly9naXRodWIuY29tL2pwcmljaGFyZHNvbi9ub2RlLWZzLWV4dHJhL3B1bGwvMTQxJylcbiAgY29uc3QgZmQgPSBmcy5vcGVuU3luYyh0bXBmaWxlLCAncisnKVxuICBmcy5mdXRpbWVzU3luYyhmZCwgZCwgZClcbiAgZnMuY2xvc2VTeW5jKGZkKVxuICByZXR1cm4gZnMuc3RhdFN5bmModG1wZmlsZSkubXRpbWUgPiAxNDM1NDEwMjQzMDAwXG59XG5cbmZ1bmN0aW9uIGhhc01pbGxpc1JlcyAoY2FsbGJhY2spIHtcbiAgbGV0IHRtcGZpbGUgPSBwYXRoLmpvaW4oJ21pbGxpcy10ZXN0JyArIERhdGUubm93KCkudG9TdHJpbmcoKSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zbGljZSgyKSlcbiAgdG1wZmlsZSA9IHBhdGguam9pbihvcy50bXBkaXIoKSwgdG1wZmlsZSlcblxuICAvLyA1NTAgbWlsbGlzIHBhc3QgVU5JWCBlcG9jaFxuICBjb25zdCBkID0gbmV3IERhdGUoMTQzNTQxMDI0Mzg2MilcbiAgZnMud3JpdGVGaWxlKHRtcGZpbGUsICdodHRwczovL2dpdGh1Yi5jb20vanByaWNoYXJkc29uL25vZGUtZnMtZXh0cmEvcHVsbC8xNDEnLCBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgZnMub3Blbih0bXBmaWxlLCAncisnLCAoZXJyLCBmZCkgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGZzLmZ1dGltZXMoZmQsIGQsIGQsIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIGZzLmNsb3NlKGZkLCBlcnIgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgZnMuc3RhdCh0bXBmaWxlLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHN0YXRzLm10aW1lID4gMTQzNTQxMDI0MzAwMClcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiB0aW1lUmVtb3ZlTWlsbGlzICh0aW1lc3RhbXApIHtcbiAgaWYgKHR5cGVvZiB0aW1lc3RhbXAgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IodGltZXN0YW1wIC8gMTAwMCkgKiAxMDAwXG4gIH0gZWxzZSBpZiAodGltZXN0YW1wIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShNYXRoLmZsb29yKHRpbWVzdGFtcC5nZXRUaW1lKCkgLyAxMDAwKSAqIDEwMDApXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmcy1leHRyYTogdGltZVJlbW92ZU1pbGxpcygpIHVua25vd24gcGFyYW1ldGVyIHR5cGUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0aW1lc01pbGxpcyAocGF0aCwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaykge1xuICAvLyBpZiAoIUhBU19NSUxMSVNfUkVTKSByZXR1cm4gZnMudXRpbWVzKHBhdGgsIGF0aW1lLCBtdGltZSwgY2FsbGJhY2spXG4gIGZzLm9wZW4ocGF0aCwgJ3IrJywgKGVyciwgZmQpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIGZzLmZ1dGltZXMoZmQsIGF0aW1lLCBtdGltZSwgZnV0aW1lc0VyciA9PiB7XG4gICAgICBmcy5jbG9zZShmZCwgY2xvc2VFcnIgPT4ge1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGZ1dGltZXNFcnIgfHwgY2xvc2VFcnIpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHV0aW1lc01pbGxpc1N5bmMgKHBhdGgsIGF0aW1lLCBtdGltZSkge1xuICBjb25zdCBmZCA9IGZzLm9wZW5TeW5jKHBhdGgsICdyKycpXG4gIGZzLmZ1dGltZXNTeW5jKGZkLCBhdGltZSwgbXRpbWUpXG4gIHJldHVybiBmcy5jbG9zZVN5bmMoZmQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBoYXNNaWxsaXNSZXMsXG4gIGhhc01pbGxpc1Jlc1N5bmMsXG4gIHRpbWVSZW1vdmVNaWxsaXMsXG4gIHV0aW1lc01pbGxpcyxcbiAgdXRpbWVzTWlsbGlzU3luY1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/fs-extra/lib/util/utimes.js\n");

/***/ }),

/***/ "../../node_modules/graceful-fs/clone.js":
/*!*****************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/graceful-fs/clone.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = clone\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: obj.__proto__ }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2dyYWNlZnVsLWZzL2Nsb25lLmpzPzZjYTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvY2xvbmUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVxuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgcmV0dXJuIG9ialxuXG4gIGlmIChvYmogaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgdmFyIGNvcHkgPSB7IF9fcHJvdG9fXzogb2JqLl9fcHJvdG9fXyB9XG4gIGVsc2VcbiAgICB2YXIgY29weSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb3B5LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpKVxuICB9KVxuXG4gIHJldHVybiBjb3B5XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/graceful-fs/clone.js\n");

/***/ }),

/***/ "../../node_modules/graceful-fs/graceful-fs.js":
/*!***********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/graceful-fs/graceful-fs.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fs = __webpack_require__(/*! fs */ \"fs\")\nvar polyfills = __webpack_require__(/*! ./polyfills.js */ \"../../node_modules/graceful-fs/polyfills.js\")\nvar legacy = __webpack_require__(/*! ./legacy-streams.js */ \"../../node_modules/graceful-fs/legacy-streams.js\")\nvar clone = __webpack_require__(/*! ./clone.js */ \"../../node_modules/graceful-fs/clone.js\")\n\nvar util = __webpack_require__(/*! util */ \"util\")\n\n/* istanbul ignore next - node 0.x polyfill */\nvar gracefulQueue\nvar previousSymbol\n\n/* istanbul ignore else - node 0.x polyfill */\nif (typeof Symbol === 'function' && typeof Symbol.for === 'function') {\n  gracefulQueue = Symbol.for('graceful-fs.queue')\n  // This is used in testing by future versions\n  previousSymbol = Symbol.for('graceful-fs.previous')\n} else {\n  gracefulQueue = '___graceful-fs.queue'\n  previousSymbol = '___graceful-fs.previous'\n}\n\nfunction noop () {}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\n// Once time initialization\nif (!global[gracefulQueue]) {\n  // This queue can be shared by multiple loaded instances\n  var queue = []\n  Object.defineProperty(global, gracefulQueue, {\n    get: function() {\n      return queue\n    }\n  })\n\n  // Patch fs.close/closeSync to shared queue version, because we need\n  // to retry() whenever a close happens *anywhere* in the program.\n  // This is essential when multiple graceful-fs instances are\n  // in play at the same time.\n  fs.close = (function (fs$close) {\n    function close (fd, cb) {\n      return fs$close.call(fs, fd, function (err) {\n        // This function uses the graceful-fs shared queue\n        if (!err) {\n          retry()\n        }\n\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n      })\n    }\n\n    Object.defineProperty(close, previousSymbol, {\n      value: fs$close\n    })\n    return close\n  })(fs.close)\n\n  fs.closeSync = (function (fs$closeSync) {\n    function closeSync (fd) {\n      // This function uses the graceful-fs shared queue\n      fs$closeSync.apply(fs, arguments)\n      retry()\n    }\n\n    Object.defineProperty(closeSync, previousSymbol, {\n      value: fs$closeSync\n    })\n    return closeSync\n  })(fs.closeSync)\n\n  if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n    process.on('exit', function() {\n      debug(global[gracefulQueue])\n      __webpack_require__(/*! assert */ \"assert\").equal(global[gracefulQueue].length, 0)\n    })\n  }\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    var args = [path]\n    if (typeof options !== 'function') {\n      args.push(options)\n    } else {\n      cb = options\n    }\n    args.push(go$readdir$cb)\n\n    return go$readdir(args)\n\n    function go$readdir$cb (err, files) {\n      if (files && files.sort)\n        files.sort()\n\n      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n        enqueue([go$readdir, [args]])\n\n      else {\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n        retry()\n      }\n    }\n  }\n\n  function go$readdir (args) {\n    return fs$readdir.apply(fs, args)\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  Object.defineProperty(fs, 'ReadStream', {\n    get: function () {\n      return ReadStream\n    },\n    set: function (val) {\n      ReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  Object.defineProperty(fs, 'WriteStream', {\n    get: function () {\n      return WriteStream\n    },\n    set: function (val) {\n      WriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  // legacy names\n  var FileReadStream = ReadStream\n  Object.defineProperty(fs, 'FileReadStream', {\n    get: function () {\n      return FileReadStream\n    },\n    set: function (val) {\n      FileReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  var FileWriteStream = WriteStream\n  Object.defineProperty(fs, 'FileWriteStream', {\n    get: function () {\n      return FileWriteStream\n    },\n    set: function (val) {\n      FileWriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new fs.ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new fs.WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  global[gracefulQueue].push(elem)\n}\n\nfunction retry () {\n  var elem = global[gracefulQueue].shift()\n  if (elem) {\n    debug('RETRY', elem[0].name, elem[1])\n    elem[0].apply(null, elem[1])\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2dyYWNlZnVsLWZzL2dyYWNlZnVsLWZzLmpzP2UwNTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxtQkFBTyxDQUFDLGNBQUk7QUFDckIsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQWdCO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyw2RUFBcUI7QUFDMUMsWUFBWSxtQkFBTyxDQUFDLDJEQUFZOztBQUVoQyxXQUFXLG1CQUFPLENBQUMsa0JBQU07O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1CQUFPLENBQUMsc0JBQVE7QUFDdEIsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvZ3JhY2VmdWwtZnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgcG9seWZpbGxzID0gcmVxdWlyZSgnLi9wb2x5ZmlsbHMuanMnKVxudmFyIGxlZ2FjeSA9IHJlcXVpcmUoJy4vbGVnYWN5LXN0cmVhbXMuanMnKVxudmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZS5qcycpXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gbm9kZSAwLnggcG9seWZpbGwgKi9cbnZhciBncmFjZWZ1bFF1ZXVlXG52YXIgcHJldmlvdXNTeW1ib2xcblxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBub2RlIDAueCBwb2x5ZmlsbCAqL1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgZ3JhY2VmdWxRdWV1ZSA9IFN5bWJvbC5mb3IoJ2dyYWNlZnVsLWZzLnF1ZXVlJylcbiAgLy8gVGhpcyBpcyB1c2VkIGluIHRlc3RpbmcgYnkgZnV0dXJlIHZlcnNpb25zXG4gIHByZXZpb3VzU3ltYm9sID0gU3ltYm9sLmZvcignZ3JhY2VmdWwtZnMucHJldmlvdXMnKVxufSBlbHNlIHtcbiAgZ3JhY2VmdWxRdWV1ZSA9ICdfX19ncmFjZWZ1bC1mcy5xdWV1ZSdcbiAgcHJldmlvdXNTeW1ib2wgPSAnX19fZ3JhY2VmdWwtZnMucHJldmlvdXMnXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxudmFyIGRlYnVnID0gbm9vcFxuaWYgKHV0aWwuZGVidWdsb2cpXG4gIGRlYnVnID0gdXRpbC5kZWJ1Z2xvZygnZ2ZzNCcpXG5lbHNlIGlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpXG4gIGRlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG0gPSB1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBhcmd1bWVudHMpXG4gICAgbSA9ICdHRlM0OiAnICsgbS5zcGxpdCgvXFxuLykuam9pbignXFxuR0ZTNDogJylcbiAgICBjb25zb2xlLmVycm9yKG0pXG4gIH1cblxuLy8gT25jZSB0aW1lIGluaXRpYWxpemF0aW9uXG5pZiAoIWdsb2JhbFtncmFjZWZ1bFF1ZXVlXSkge1xuICAvLyBUaGlzIHF1ZXVlIGNhbiBiZSBzaGFyZWQgYnkgbXVsdGlwbGUgbG9hZGVkIGluc3RhbmNlc1xuICB2YXIgcXVldWUgPSBbXVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCBncmFjZWZ1bFF1ZXVlLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBxdWV1ZVxuICAgIH1cbiAgfSlcblxuICAvLyBQYXRjaCBmcy5jbG9zZS9jbG9zZVN5bmMgdG8gc2hhcmVkIHF1ZXVlIHZlcnNpb24sIGJlY2F1c2Ugd2UgbmVlZFxuICAvLyB0byByZXRyeSgpIHdoZW5ldmVyIGEgY2xvc2UgaGFwcGVucyAqYW55d2hlcmUqIGluIHRoZSBwcm9ncmFtLlxuICAvLyBUaGlzIGlzIGVzc2VudGlhbCB3aGVuIG11bHRpcGxlIGdyYWNlZnVsLWZzIGluc3RhbmNlcyBhcmVcbiAgLy8gaW4gcGxheSBhdCB0aGUgc2FtZSB0aW1lLlxuICBmcy5jbG9zZSA9IChmdW5jdGlvbiAoZnMkY2xvc2UpIHtcbiAgICBmdW5jdGlvbiBjbG9zZSAoZmQsIGNiKSB7XG4gICAgICByZXR1cm4gZnMkY2xvc2UuY2FsbChmcywgZmQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiB1c2VzIHRoZSBncmFjZWZ1bC1mcyBzaGFyZWQgcXVldWVcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICByZXRyeSgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb3NlLCBwcmV2aW91c1N5bWJvbCwge1xuICAgICAgdmFsdWU6IGZzJGNsb3NlXG4gICAgfSlcbiAgICByZXR1cm4gY2xvc2VcbiAgfSkoZnMuY2xvc2UpXG5cbiAgZnMuY2xvc2VTeW5jID0gKGZ1bmN0aW9uIChmcyRjbG9zZVN5bmMpIHtcbiAgICBmdW5jdGlvbiBjbG9zZVN5bmMgKGZkKSB7XG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGdyYWNlZnVsLWZzIHNoYXJlZCBxdWV1ZVxuICAgICAgZnMkY2xvc2VTeW5jLmFwcGx5KGZzLCBhcmd1bWVudHMpXG4gICAgICByZXRyeSgpXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb3NlU3luYywgcHJldmlvdXNTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmcyRjbG9zZVN5bmNcbiAgICB9KVxuICAgIHJldHVybiBjbG9zZVN5bmNcbiAgfSkoZnMuY2xvc2VTeW5jKVxuXG4gIGlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpIHtcbiAgICBwcm9jZXNzLm9uKCdleGl0JywgZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZyhnbG9iYWxbZ3JhY2VmdWxRdWV1ZV0pXG4gICAgICByZXF1aXJlKCdhc3NlcnQnKS5lcXVhbChnbG9iYWxbZ3JhY2VmdWxRdWV1ZV0ubGVuZ3RoLCAwKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaChjbG9uZShmcykpXG5pZiAocHJvY2Vzcy5lbnYuVEVTVF9HUkFDRUZVTF9GU19HTE9CQUxfUEFUQ0ggJiYgIWZzLl9fcGF0Y2hlZCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcGF0Y2goZnMpXG4gICAgZnMuX19wYXRjaGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGF0Y2ggKGZzKSB7XG4gIC8vIEV2ZXJ5dGhpbmcgdGhhdCByZWZlcmVuY2VzIHRoZSBvcGVuKCkgZnVuY3Rpb24gbmVlZHMgdG8gYmUgaW4gaGVyZVxuICBwb2x5ZmlsbHMoZnMpXG4gIGZzLmdyYWNlZnVsaWZ5ID0gcGF0Y2hcblxuICBmcy5jcmVhdGVSZWFkU3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbVxuICBmcy5jcmVhdGVXcml0ZVN0cmVhbSA9IGNyZWF0ZVdyaXRlU3RyZWFtXG4gIHZhciBmcyRyZWFkRmlsZSA9IGZzLnJlYWRGaWxlXG4gIGZzLnJlYWRGaWxlID0gcmVhZEZpbGVcbiAgZnVuY3Rpb24gcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHJlYWRGaWxlKHBhdGgsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gZnMkcmVhZEZpbGUocGF0aCwgb3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRyZWFkRmlsZSwgW3BhdGgsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyR3cml0ZUZpbGUgPSBmcy53cml0ZUZpbGVcbiAgZnMud3JpdGVGaWxlID0gd3JpdGVGaWxlXG4gIGZ1bmN0aW9uIHdyaXRlRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kd3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kd3JpdGVGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIGZzJHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJHdyaXRlRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRhcHBlbmRGaWxlID0gZnMuYXBwZW5kRmlsZVxuICBpZiAoZnMkYXBwZW5kRmlsZSlcbiAgICBmcy5hcHBlbmRGaWxlID0gYXBwZW5kRmlsZVxuICBmdW5jdGlvbiBhcHBlbmRGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gb3B0aW9ucywgb3B0aW9ucyA9IG51bGxcblxuICAgIHJldHVybiBnbyRhcHBlbmRGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kYXBwZW5kRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiBmcyRhcHBlbmRGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kYXBwZW5kRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRyZWFkZGlyID0gZnMucmVhZGRpclxuICBmcy5yZWFkZGlyID0gcmVhZGRpclxuICBmdW5jdGlvbiByZWFkZGlyIChwYXRoLCBvcHRpb25zLCBjYikge1xuICAgIHZhciBhcmdzID0gW3BhdGhdXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhcmdzLnB1c2gob3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgY2IgPSBvcHRpb25zXG4gICAgfVxuICAgIGFyZ3MucHVzaChnbyRyZWFkZGlyJGNiKVxuXG4gICAgcmV0dXJuIGdvJHJlYWRkaXIoYXJncylcblxuICAgIGZ1bmN0aW9uIGdvJHJlYWRkaXIkY2IgKGVyciwgZmlsZXMpIHtcbiAgICAgIGlmIChmaWxlcyAmJiBmaWxlcy5zb3J0KVxuICAgICAgICBmaWxlcy5zb3J0KClcblxuICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgIGVucXVldWUoW2dvJHJlYWRkaXIsIFthcmdzXV0pXG5cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgcmV0cnkoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdvJHJlYWRkaXIgKGFyZ3MpIHtcbiAgICByZXR1cm4gZnMkcmVhZGRpci5hcHBseShmcywgYXJncylcbiAgfVxuXG4gIGlmIChwcm9jZXNzLnZlcnNpb24uc3Vic3RyKDAsIDQpID09PSAndjAuOCcpIHtcbiAgICB2YXIgbGVnU3RyZWFtcyA9IGxlZ2FjeShmcylcbiAgICBSZWFkU3RyZWFtID0gbGVnU3RyZWFtcy5SZWFkU3RyZWFtXG4gICAgV3JpdGVTdHJlYW0gPSBsZWdTdHJlYW1zLldyaXRlU3RyZWFtXG4gIH1cblxuICB2YXIgZnMkUmVhZFN0cmVhbSA9IGZzLlJlYWRTdHJlYW1cbiAgaWYgKGZzJFJlYWRTdHJlYW0pIHtcbiAgICBSZWFkU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZnMkUmVhZFN0cmVhbS5wcm90b3R5cGUpXG4gICAgUmVhZFN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFJlYWRTdHJlYW0kb3BlblxuICB9XG5cbiAgdmFyIGZzJFdyaXRlU3RyZWFtID0gZnMuV3JpdGVTdHJlYW1cbiAgaWYgKGZzJFdyaXRlU3RyZWFtKSB7XG4gICAgV3JpdGVTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmcyRXcml0ZVN0cmVhbS5wcm90b3R5cGUpXG4gICAgV3JpdGVTdHJlYW0ucHJvdG90eXBlLm9wZW4gPSBXcml0ZVN0cmVhbSRvcGVuXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdSZWFkU3RyZWFtJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFJlYWRTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgUmVhZFN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZzLCAnV3JpdGVTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gV3JpdGVTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgV3JpdGVTdHJlYW0gPSB2YWxcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG5cbiAgLy8gbGVnYWN5IG5hbWVzXG4gIHZhciBGaWxlUmVhZFN0cmVhbSA9IFJlYWRTdHJlYW1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZzLCAnRmlsZVJlYWRTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gRmlsZVJlYWRTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgRmlsZVJlYWRTdHJlYW0gPSB2YWxcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG4gIHZhciBGaWxlV3JpdGVTdHJlYW0gPSBXcml0ZVN0cmVhbVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdGaWxlV3JpdGVTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gRmlsZVdyaXRlU3RyZWFtXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIEZpbGVXcml0ZVN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBSZWFkU3RyZWFtKVxuICAgICAgcmV0dXJuIGZzJFJlYWRTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpc1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBSZWFkU3RyZWFtLmFwcGx5KE9iamVjdC5jcmVhdGUoUmVhZFN0cmVhbS5wcm90b3R5cGUpLCBhcmd1bWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtJG9wZW4gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIG9wZW4odGhhdC5wYXRoLCB0aGF0LmZsYWdzLCB0aGF0Lm1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGF0LmF1dG9DbG9zZSlcbiAgICAgICAgICB0aGF0LmRlc3Ryb3koKVxuXG4gICAgICAgIHRoYXQuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGF0LmZkID0gZmRcbiAgICAgICAgdGhhdC5lbWl0KCdvcGVuJywgZmQpXG4gICAgICAgIHRoYXQucmVhZCgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIFdyaXRlU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBXcml0ZVN0cmVhbSlcbiAgICAgIHJldHVybiBmcyRXcml0ZVN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFdyaXRlU3RyZWFtLmFwcGx5KE9iamVjdC5jcmVhdGUoV3JpdGVTdHJlYW0ucHJvdG90eXBlKSwgYXJndW1lbnRzKVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0kb3BlbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgb3Blbih0aGF0LnBhdGgsIHRoYXQuZmxhZ3MsIHRoYXQubW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhhdC5kZXN0cm95KClcbiAgICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoYXQuZmQgPSBmZFxuICAgICAgICB0aGF0LmVtaXQoJ29wZW4nLCBmZClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmVhZFN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgZnMuUmVhZFN0cmVhbShwYXRoLCBvcHRpb25zKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IGZzLldyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG4gIH1cblxuICB2YXIgZnMkb3BlbiA9IGZzLm9wZW5cbiAgZnMub3BlbiA9IG9wZW5cbiAgZnVuY3Rpb24gb3BlbiAocGF0aCwgZmxhZ3MsIG1vZGUsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBtb2RlLCBtb2RlID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJG9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kb3BlbiAocGF0aCwgZmxhZ3MsIG1vZGUsIGNiKSB7XG4gICAgICByZXR1cm4gZnMkb3BlbihwYXRoLCBmbGFncywgbW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kb3BlbiwgW3BhdGgsIGZsYWdzLCBtb2RlLCBjYl1dKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgIHJldHJ5KClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnNcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZSAoZWxlbSkge1xuICBkZWJ1ZygnRU5RVUVVRScsIGVsZW1bMF0ubmFtZSwgZWxlbVsxXSlcbiAgZ2xvYmFsW2dyYWNlZnVsUXVldWVdLnB1c2goZWxlbSlcbn1cblxuZnVuY3Rpb24gcmV0cnkgKCkge1xuICB2YXIgZWxlbSA9IGdsb2JhbFtncmFjZWZ1bFF1ZXVlXS5zaGlmdCgpXG4gIGlmIChlbGVtKSB7XG4gICAgZGVidWcoJ1JFVFJZJywgZWxlbVswXS5uYW1lLCBlbGVtWzFdKVxuICAgIGVsZW1bMF0uYXBwbHkobnVsbCwgZWxlbVsxXSlcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/graceful-fs/graceful-fs.js\n");

/***/ }),

/***/ "../../node_modules/graceful-fs/legacy-streams.js":
/*!**************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/graceful-fs/legacy-streams.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Stream = __webpack_require__(/*! stream */ \"stream\").Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2dyYWNlZnVsLWZzL2xlZ2FjeS1zdHJlYW1zLmpzP2VmMGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLHNCQUFROztBQUU3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0I7QUFDN0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9sZWdhY3ktc3RyZWFtcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW1cblxubW9kdWxlLmV4cG9ydHMgPSBsZWdhY3lcblxuZnVuY3Rpb24gbGVnYWN5IChmcykge1xuICByZXR1cm4ge1xuICAgIFJlYWRTdHJlYW06IFJlYWRTdHJlYW0sXG4gICAgV3JpdGVTdHJlYW06IFdyaXRlU3RyZWFtXG4gIH1cblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRTdHJlYW0pKSByZXR1cm4gbmV3IFJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG5cbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5mZCA9IG51bGw7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuZmxhZ3MgPSAncic7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ1ZmZlclNpemUgPSA2NCAqIDEwMjQ7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVuY29kaW5nKSB0aGlzLnNldEVuY29kaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgaWYgKHRoaXMuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5zdGFydCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ3N0YXJ0IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZW5kID0gSW5maW5pdHk7XG4gICAgICB9IGVsc2UgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5lbmQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdlbmQgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFydCA+IHRoaXMuZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgbXVzdCBiZSA8PSBlbmQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZkICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9yZWFkKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmcy5vcGVuKHRoaXMucGF0aCwgdGhpcy5mbGFncywgdGhpcy5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgc2VsZi5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZmQgPSBmZDtcbiAgICAgIHNlbGYuZW1pdCgnb3BlbicsIGZkKTtcbiAgICAgIHNlbGYuX3JlYWQoKTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGVTdHJlYW0pKSByZXR1cm4gbmV3IFdyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuZmQgPSBudWxsO1xuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gICAgdGhpcy5mbGFncyA9ICd3JztcbiAgICB0aGlzLmVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDA7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRoaXMuc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdzdGFydCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGFydCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBtdXN0IGJlID49IHplcm8nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIHRoaXMuYnVzeSA9IGZhbHNlO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG5cbiAgICBpZiAodGhpcy5mZCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3BlbiA9IGZzLm9wZW47XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKFt0aGlzLl9vcGVuLCB0aGlzLnBhdGgsIHRoaXMuZmxhZ3MsIHRoaXMubW9kZSwgdW5kZWZpbmVkXSk7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/graceful-fs/legacy-streams.js\n");

/***/ }),

/***/ "../../node_modules/graceful-fs/polyfills.js":
/*!*********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/graceful-fs/polyfills.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var constants = __webpack_require__(/*! constants */ \"constants\")\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) {\n    function read (fd, buffer, offset, length, position, callback_) {\n      var callback\n      if (callback_ && typeof callback_ === 'function') {\n        var eagCounter = 0\n        callback = function (er, _, __) {\n          if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n            eagCounter ++\n            return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n          }\n          callback_.apply(this, arguments)\n        }\n      }\n      return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n    }\n\n    // This ensures `util.promisify` works as it does for native `fs.read`.\n    read.__proto__ = fs$read\n    return read\n  })(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options, cb) {\n      if (typeof options === 'function') {\n        cb = options\n        options = null\n      }\n      function callback (er, stats) {\n        if (stats) {\n          if (stats.uid < 0) stats.uid += 0x100000000\n          if (stats.gid < 0) stats.gid += 0x100000000\n        }\n        if (cb) cb.apply(this, arguments)\n      }\n      return options ? orig.call(fs, target, options, callback)\n        : orig.call(fs, target, callback)\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options) {\n      var stats = options ? orig.call(fs, target, options)\n        : orig.call(fs, target)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2dyYWNlZnVsLWZzL3BvbHlmaWxscy5qcz84YjhmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLDRCQUFXOztBQUVuQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTCw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2dyYWNlZnVsLWZzL3BvbHlmaWxscy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBjb25zdGFudHMgPSByZXF1aXJlKCdjb25zdGFudHMnKVxuXG52YXIgb3JpZ0N3ZCA9IHByb2Nlc3MuY3dkXG52YXIgY3dkID0gbnVsbFxuXG52YXIgcGxhdGZvcm0gPSBwcm9jZXNzLmVudi5HUkFDRUZVTF9GU19QTEFURk9STSB8fCBwcm9jZXNzLnBsYXRmb3JtXG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24oKSB7XG4gIGlmICghY3dkKVxuICAgIGN3ZCA9IG9yaWdDd2QuY2FsbChwcm9jZXNzKVxuICByZXR1cm4gY3dkXG59XG50cnkge1xuICBwcm9jZXNzLmN3ZCgpXG59IGNhdGNoIChlcikge31cblxudmFyIGNoZGlyID0gcHJvY2Vzcy5jaGRpclxucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uKGQpIHtcbiAgY3dkID0gbnVsbFxuICBjaGRpci5jYWxsKHByb2Nlc3MsIGQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hcblxuZnVuY3Rpb24gcGF0Y2ggKGZzKSB7XG4gIC8vIChyZS0paW1wbGVtZW50IHNvbWUgdGhpbmdzIHRoYXQgYXJlIGtub3duIGJ1c3RlZCBvciBtaXNzaW5nLlxuXG4gIC8vIGxjaG1vZCwgYnJva2VuIHByaW9yIHRvIDAuNi4yXG4gIC8vIGJhY2stcG9ydCB0aGUgZml4IGhlcmUuXG4gIGlmIChjb25zdGFudHMuaGFzT3duUHJvcGVydHkoJ09fU1lNTElOSycpICYmXG4gICAgICBwcm9jZXNzLnZlcnNpb24ubWF0Y2goL152MFxcLjZcXC5bMC0yXXxedjBcXC41XFwuLykpIHtcbiAgICBwYXRjaExjaG1vZChmcylcbiAgfVxuXG4gIC8vIGx1dGltZXMgaW1wbGVtZW50YXRpb24sIG9yIG5vLW9wXG4gIGlmICghZnMubHV0aW1lcykge1xuICAgIHBhdGNoTHV0aW1lcyhmcylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1ncmFjZWZ1bC1mcy9pc3N1ZXMvNFxuICAvLyBDaG93biBzaG91bGQgbm90IGZhaWwgb24gZWludmFsIG9yIGVwZXJtIGlmIG5vbi1yb290LlxuICAvLyBJdCBzaG91bGQgbm90IGZhaWwgb24gZW5vc3lzIGV2ZXIsIGFzIHRoaXMganVzdCBpbmRpY2F0ZXNcbiAgLy8gdGhhdCBhIGZzIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgaW50ZW5kZWQgb3BlcmF0aW9uLlxuXG4gIGZzLmNob3duID0gY2hvd25GaXgoZnMuY2hvd24pXG4gIGZzLmZjaG93biA9IGNob3duRml4KGZzLmZjaG93bilcbiAgZnMubGNob3duID0gY2hvd25GaXgoZnMubGNob3duKVxuXG4gIGZzLmNobW9kID0gY2htb2RGaXgoZnMuY2htb2QpXG4gIGZzLmZjaG1vZCA9IGNobW9kRml4KGZzLmZjaG1vZClcbiAgZnMubGNobW9kID0gY2htb2RGaXgoZnMubGNobW9kKVxuXG4gIGZzLmNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5jaG93blN5bmMpXG4gIGZzLmZjaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMuZmNob3duU3luYylcbiAgZnMubGNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5sY2hvd25TeW5jKVxuXG4gIGZzLmNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5jaG1vZFN5bmMpXG4gIGZzLmZjaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMuZmNobW9kU3luYylcbiAgZnMubGNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5sY2htb2RTeW5jKVxuXG4gIGZzLnN0YXQgPSBzdGF0Rml4KGZzLnN0YXQpXG4gIGZzLmZzdGF0ID0gc3RhdEZpeChmcy5mc3RhdClcbiAgZnMubHN0YXQgPSBzdGF0Rml4KGZzLmxzdGF0KVxuXG4gIGZzLnN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMuc3RhdFN5bmMpXG4gIGZzLmZzdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLmZzdGF0U3luYylcbiAgZnMubHN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMubHN0YXRTeW5jKVxuXG4gIC8vIGlmIGxjaG1vZC9sY2hvd24gZG8gbm90IGV4aXN0LCB0aGVuIG1ha2UgdGhlbSBuby1vcHNcbiAgaWYgKCFmcy5sY2htb2QpIHtcbiAgICBmcy5sY2htb2QgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSwgY2IpIHtcbiAgICAgIGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYilcbiAgICB9XG4gICAgZnMubGNobW9kU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gIH1cbiAgaWYgKCFmcy5sY2hvd24pIHtcbiAgICBmcy5sY2hvd24gPSBmdW5jdGlvbiAocGF0aCwgdWlkLCBnaWQsIGNiKSB7XG4gICAgICBpZiAoY2IpIHByb2Nlc3MubmV4dFRpY2soY2IpXG4gICAgfVxuICAgIGZzLmxjaG93blN5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgLy8gb24gV2luZG93cywgQS9WIHNvZnR3YXJlIGNhbiBsb2NrIHRoZSBkaXJlY3RvcnksIGNhdXNpbmcgdGhpc1xuICAvLyB0byBmYWlsIHdpdGggYW4gRUFDQ0VTIG9yIEVQRVJNIGlmIHRoZSBkaXJlY3RvcnkgY29udGFpbnMgbmV3bHlcbiAgLy8gY3JlYXRlZCBmaWxlcy4gIFRyeSBhZ2FpbiBvbiBmYWlsdXJlLCBmb3IgdXAgdG8gNjAgc2Vjb25kcy5cblxuICAvLyBTZXQgdGhlIHRpbWVvdXQgdGhpcyBsb25nIGJlY2F1c2Ugc29tZSBXaW5kb3dzIEFudGktVmlydXMsIHN1Y2ggYXMgUGFyaXR5XG4gIC8vIGJpdDksIG1heSBsb2NrIGZpbGVzIGZvciB1cCB0byBhIG1pbnV0ZSwgY2F1c2luZyBucG0gcGFja2FnZSBpbnN0YWxsXG4gIC8vIGZhaWx1cmVzLiBBbHNvLCB0YWtlIGNhcmUgdG8geWllbGQgdGhlIHNjaGVkdWxlci4gV2luZG93cyBzY2hlZHVsaW5nIGdpdmVzXG4gIC8vIENQVSB0byBhIGJ1c3kgbG9vcGluZyBwcm9jZXNzLCB3aGljaCBjYW4gY2F1c2UgdGhlIHByb2dyYW0gY2F1c2luZyB0aGUgbG9ja1xuICAvLyBjb250ZW50aW9uIHRvIGJlIHN0YXJ2ZWQgb2YgQ1BVIGJ5IG5vZGUsIHNvIHRoZSBjb250ZW50aW9uIGRvZXNuJ3QgcmVzb2x2ZS5cbiAgaWYgKHBsYXRmb3JtID09PSBcIndpbjMyXCIpIHtcbiAgICBmcy5yZW5hbWUgPSAoZnVuY3Rpb24gKGZzJHJlbmFtZSkgeyByZXR1cm4gZnVuY3Rpb24gKGZyb20sIHRvLCBjYikge1xuICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgICAgdmFyIGJhY2tvZmYgPSAwO1xuICAgICAgZnMkcmVuYW1lKGZyb20sIHRvLCBmdW5jdGlvbiBDQiAoZXIpIHtcbiAgICAgICAgaWYgKGVyXG4gICAgICAgICAgICAmJiAoZXIuY29kZSA9PT0gXCJFQUNDRVNcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICAgICAgICAmJiBEYXRlLm5vdygpIC0gc3RhcnQgPCA2MDAwMCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmcy5zdGF0KHRvLCBmdW5jdGlvbiAoc3RhdGVyLCBzdCkge1xuICAgICAgICAgICAgICBpZiAoc3RhdGVyICYmIHN0YXRlci5jb2RlID09PSBcIkVOT0VOVFwiKVxuICAgICAgICAgICAgICAgIGZzJHJlbmFtZShmcm9tLCB0bywgQ0IpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2IoZXIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0sIGJhY2tvZmYpXG4gICAgICAgICAgaWYgKGJhY2tvZmYgPCAxMDApXG4gICAgICAgICAgICBiYWNrb2ZmICs9IDEwO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IpIGNiKGVyKVxuICAgICAgfSlcbiAgICB9fSkoZnMucmVuYW1lKVxuICB9XG5cbiAgLy8gaWYgcmVhZCgpIHJldHVybnMgRUFHQUlOLCB0aGVuIGp1c3QgdHJ5IGl0IGFnYWluLlxuICBmcy5yZWFkID0gKGZ1bmN0aW9uIChmcyRyZWFkKSB7XG4gICAgZnVuY3Rpb24gcmVhZCAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFja18pIHtcbiAgICAgIHZhciBjYWxsYmFja1xuICAgICAgaWYgKGNhbGxiYWNrXyAmJiB0eXBlb2YgY2FsbGJhY2tfID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBlYWdDb3VudGVyID0gMFxuICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIChlciwgXywgX18pIHtcbiAgICAgICAgICBpZiAoZXIgJiYgZXIuY29kZSA9PT0gJ0VBR0FJTicgJiYgZWFnQ291bnRlciA8IDEwKSB7XG4gICAgICAgICAgICBlYWdDb3VudGVyICsrXG4gICAgICAgICAgICByZXR1cm4gZnMkcmVhZC5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFja18uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnMkcmVhZC5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKVxuICAgIH1cblxuICAgIC8vIFRoaXMgZW5zdXJlcyBgdXRpbC5wcm9taXNpZnlgIHdvcmtzIGFzIGl0IGRvZXMgZm9yIG5hdGl2ZSBgZnMucmVhZGAuXG4gICAgcmVhZC5fX3Byb3RvX18gPSBmcyRyZWFkXG4gICAgcmV0dXJuIHJlYWRcbiAgfSkoZnMucmVhZClcblxuICBmcy5yZWFkU3luYyA9IChmdW5jdGlvbiAoZnMkcmVhZFN5bmMpIHsgcmV0dXJuIGZ1bmN0aW9uIChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICB2YXIgZWFnQ291bnRlciA9IDBcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZzJHJlYWRTeW5jLmNhbGwoZnMsIGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbilcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmIChlci5jb2RlID09PSAnRUFHQUlOJyAmJiBlYWdDb3VudGVyIDwgMTApIHtcbiAgICAgICAgICBlYWdDb3VudGVyICsrXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlclxuICAgICAgfVxuICAgIH1cbiAgfX0pKGZzLnJlYWRTeW5jKVxuXG4gIGZ1bmN0aW9uIHBhdGNoTGNobW9kIChmcykge1xuICAgIGZzLmxjaG1vZCA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlLCBjYWxsYmFjaykge1xuICAgICAgZnMub3BlbiggcGF0aFxuICAgICAgICAgICAgICwgY29uc3RhbnRzLk9fV1JPTkxZIHwgY29uc3RhbnRzLk9fU1lNTElOS1xuICAgICAgICAgICAgICwgbW9kZVxuICAgICAgICAgICAgICwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIC8vIHByZWZlciB0byByZXR1cm4gdGhlIGNobW9kIGVycm9yLCBpZiBvbmUgb2NjdXJzLFxuICAgICAgICAvLyBidXQgc3RpbGwgdHJ5IHRvIGNsb3NlLCBhbmQgcmVwb3J0IGNsb3NpbmcgZXJyb3JzIGlmIHRoZXkgb2NjdXIuXG4gICAgICAgIGZzLmZjaG1vZChmZCwgbW9kZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGZzLmNsb3NlKGZkLCBmdW5jdGlvbihlcnIyKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVyciB8fCBlcnIyKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZzLmxjaG1vZFN5bmMgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSkge1xuICAgICAgdmFyIGZkID0gZnMub3BlblN5bmMocGF0aCwgY29uc3RhbnRzLk9fV1JPTkxZIHwgY29uc3RhbnRzLk9fU1lNTElOSywgbW9kZSlcblxuICAgICAgLy8gcHJlZmVyIHRvIHJldHVybiB0aGUgY2htb2QgZXJyb3IsIGlmIG9uZSBvY2N1cnMsXG4gICAgICAvLyBidXQgc3RpbGwgdHJ5IHRvIGNsb3NlLCBhbmQgcmVwb3J0IGNsb3NpbmcgZXJyb3JzIGlmIHRoZXkgb2NjdXIuXG4gICAgICB2YXIgdGhyZXcgPSB0cnVlXG4gICAgICB2YXIgcmV0XG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBmcy5mY2htb2RTeW5jKGZkLCBtb2RlKVxuICAgICAgICB0aHJldyA9IGZhbHNlXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoTHV0aW1lcyAoZnMpIHtcbiAgICBpZiAoY29uc3RhbnRzLmhhc093blByb3BlcnR5KFwiT19TWU1MSU5LXCIpKSB7XG4gICAgICBmcy5sdXRpbWVzID0gZnVuY3Rpb24gKHBhdGgsIGF0LCBtdCwgY2IpIHtcbiAgICAgICAgZnMub3BlbihwYXRoLCBjb25zdGFudHMuT19TWU1MSU5LLCBmdW5jdGlvbiAoZXIsIGZkKSB7XG4gICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICBpZiAoY2IpIGNiKGVyKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGZzLmZ1dGltZXMoZmQsIGF0LCBtdCwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24gKGVyMikge1xuICAgICAgICAgICAgICBpZiAoY2IpIGNiKGVyIHx8IGVyMilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgZnMubHV0aW1lc1N5bmMgPSBmdW5jdGlvbiAocGF0aCwgYXQsIG10KSB7XG4gICAgICAgIHZhciBmZCA9IGZzLm9wZW5TeW5jKHBhdGgsIGNvbnN0YW50cy5PX1NZTUxJTkspXG4gICAgICAgIHZhciByZXRcbiAgICAgICAgdmFyIHRocmV3ID0gdHJ1ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldCA9IGZzLmZ1dGltZXNTeW5jKGZkLCBhdCwgbXQpXG4gICAgICAgICAgdGhyZXcgPSBmYWxzZVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmICh0aHJldykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGZzLmx1dGltZXMgPSBmdW5jdGlvbiAoX2EsIF9iLCBfYywgY2IpIHsgaWYgKGNiKSBwcm9jZXNzLm5leHRUaWNrKGNiKSB9XG4gICAgICBmcy5sdXRpbWVzU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2htb2RGaXggKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG1vZGUsIGNiKSB7XG4gICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG1vZGUsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICBpZiAoY2hvd25Fck9rKGVyKSkgZXIgPSBudWxsXG4gICAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaG1vZEZpeFN5bmMgKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG1vZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvcmlnLmNhbGwoZnMsIHRhcmdldCwgbW9kZSlcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmICghY2hvd25Fck9rKGVyKSkgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGNob3duRml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCB1aWQsIGdpZCwgY2IpIHtcbiAgICAgIHJldHVybiBvcmlnLmNhbGwoZnMsIHRhcmdldCwgdWlkLCBnaWQsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICBpZiAoY2hvd25Fck9rKGVyKSkgZXIgPSBudWxsXG4gICAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaG93bkZpeFN5bmMgKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHVpZCwgZ2lkKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIHVpZCwgZ2lkKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgaWYgKCFjaG93bkVyT2soZXIpKSB0aHJvdyBlclxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXRGaXggKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgTm9kZSBlcnJvbmVvdXNseSByZXR1cm5lZCBzaWduZWQgaW50ZWdlcnMgZm9yXG4gICAgLy8gdWlkICsgZ2lkLlxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zLCBjYikge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNiID0gb3B0aW9uc1xuICAgICAgICBvcHRpb25zID0gbnVsbFxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2FsbGJhY2sgKGVyLCBzdGF0cykge1xuICAgICAgICBpZiAoc3RhdHMpIHtcbiAgICAgICAgICBpZiAoc3RhdHMudWlkIDwgMCkgc3RhdHMudWlkICs9IDB4MTAwMDAwMDAwXG4gICAgICAgICAgaWYgKHN0YXRzLmdpZCA8IDApIHN0YXRzLmdpZCArPSAweDEwMDAwMDAwMFxuICAgICAgICB9XG4gICAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMgPyBvcmlnLmNhbGwoZnMsIHRhcmdldCwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgICAgIDogb3JpZy5jYWxsKGZzLCB0YXJnZXQsIGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXRGaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIE5vZGUgZXJyb25lb3VzbHkgcmV0dXJuZWQgc2lnbmVkIGludGVnZXJzIGZvclxuICAgIC8vIHVpZCArIGdpZC5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgdmFyIHN0YXRzID0gb3B0aW9ucyA/IG9yaWcuY2FsbChmcywgdGFyZ2V0LCBvcHRpb25zKVxuICAgICAgICA6IG9yaWcuY2FsbChmcywgdGFyZ2V0KVxuICAgICAgaWYgKHN0YXRzLnVpZCA8IDApIHN0YXRzLnVpZCArPSAweDEwMDAwMDAwMFxuICAgICAgaWYgKHN0YXRzLmdpZCA8IDApIHN0YXRzLmdpZCArPSAweDEwMDAwMDAwMFxuICAgICAgcmV0dXJuIHN0YXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVOT1NZUyBtZWFucyB0aGF0IHRoZSBmcyBkb2Vzbid0IHN1cHBvcnQgdGhlIG9wLiBKdXN0IGlnbm9yZVxuICAvLyB0aGF0LCBiZWNhdXNlIGl0IGRvZXNuJ3QgbWF0dGVyLlxuICAvL1xuICAvLyBpZiB0aGVyZSdzIG5vIGdldHVpZCwgb3IgaWYgZ2V0dWlkKCkgaXMgc29tZXRoaW5nIG90aGVyXG4gIC8vIHRoYW4gMCwgYW5kIHRoZSBlcnJvciBpcyBFSU5WQUwgb3IgRVBFUk0sIHRoZW4ganVzdCBpZ25vcmVcbiAgLy8gaXQuXG4gIC8vXG4gIC8vIFRoaXMgc3BlY2lmaWMgY2FzZSBpcyBhIHNpbGVudCBmYWlsdXJlIGluIGNwLCBpbnN0YWxsLCB0YXIsXG4gIC8vIGFuZCBtb3N0IG90aGVyIHVuaXggdG9vbHMgdGhhdCBtYW5hZ2UgcGVybWlzc2lvbnMuXG4gIC8vXG4gIC8vIFdoZW4gcnVubmluZyBhcyByb290LCBvciBpZiBvdGhlciB0eXBlcyBvZiBlcnJvcnMgYXJlXG4gIC8vIGVuY291bnRlcmVkLCB0aGVuIGl0J3Mgc3RyaWN0LlxuICBmdW5jdGlvbiBjaG93bkVyT2sgKGVyKSB7XG4gICAgaWYgKCFlcilcbiAgICAgIHJldHVybiB0cnVlXG5cbiAgICBpZiAoZXIuY29kZSA9PT0gXCJFTk9TWVNcIilcbiAgICAgIHJldHVybiB0cnVlXG5cbiAgICB2YXIgbm9ucm9vdCA9ICFwcm9jZXNzLmdldHVpZCB8fCBwcm9jZXNzLmdldHVpZCgpICE9PSAwXG4gICAgaWYgKG5vbnJvb3QpIHtcbiAgICAgIGlmIChlci5jb2RlID09PSBcIkVJTlZBTFwiIHx8IGVyLmNvZGUgPT09IFwiRVBFUk1cIilcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/graceful-fs/polyfills.js\n");

/***/ }),

/***/ "../../node_modules/hashids/cjs/index.js":
/*!*****************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/hashids/cjs/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ../dist/hashids.js */ \"../../node_modules/hashids/dist/hashids.js\").default\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2hhc2hpZHMvY2pzL2luZGV4LmpzP2YxZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsc0VBQW9CIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9oYXNoaWRzL2Nqcy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vZGlzdC9oYXNoaWRzLmpzJykuZGVmYXVsdFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/hashids/cjs/index.js\n");

/***/ }),

/***/ "../../node_modules/hashids/dist/hashids.js":
/*!********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/hashids/dist/hashids.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_exports) {\n  \"use strict\";\n\n  _exports.__esModule = true;\n  _exports.onlyChars = _exports.withoutChars = _exports.keepUnique = _exports.default = void 0;\n\n  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\n  function _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\n  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\n  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\n  var Hashids =\n  /*#__PURE__*/\n  function () {\n    function Hashids(salt, minLength, alphabet, seps) {\n      if (salt === void 0) {\n        salt = '';\n      }\n\n      if (minLength === void 0) {\n        minLength = 0;\n      }\n\n      if (alphabet === void 0) {\n        alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';\n      }\n\n      if (seps === void 0) {\n        seps = 'cfhistuCFHISTU';\n      }\n\n      this.minLength = minLength;\n\n      if (typeof minLength !== 'number') {\n        throw new TypeError(\"Hashids: Provided 'minLength' has to be a number (is \" + typeof minLength + \")\");\n      }\n\n      if (typeof salt !== 'string') {\n        throw new TypeError(\"Hashids: Provided 'salt' has to be a string (is \" + typeof salt + \")\");\n      }\n\n      if (typeof alphabet !== 'string') {\n        throw new TypeError(\"Hashids: Provided alphabet has to be a string (is \" + typeof alphabet + \")\");\n      }\n\n      var saltChars = Array.from(salt);\n      var alphabetChars = Array.from(alphabet);\n      var sepsChars = Array.from(seps);\n      this.salt = saltChars;\n      var uniqueAlphabet = keepUnique(alphabetChars);\n\n      if (uniqueAlphabet.length < minAlphabetLength) {\n        throw new Error(\"Hashids: alphabet must contain at least \" + minAlphabetLength + \" unique characters, provided: \" + uniqueAlphabet);\n      }\n      /** `alphabet` should not contains `seps` */\n\n\n      this.alphabet = withoutChars(uniqueAlphabet, sepsChars);\n      /** `seps` should contain only characters present in `alphabet` */\n\n      var filteredSeps = onlyChars(sepsChars, uniqueAlphabet);\n      this.seps = shuffle(filteredSeps, saltChars);\n      var sepsLength;\n      var diff;\n\n      if (this.seps.length === 0 || this.alphabet.length / this.seps.length > sepDiv) {\n        sepsLength = Math.ceil(this.alphabet.length / sepDiv);\n\n        if (sepsLength > this.seps.length) {\n          var _this$seps;\n\n          diff = sepsLength - this.seps.length;\n\n          (_this$seps = this.seps).push.apply(_this$seps, _toConsumableArray(this.alphabet.slice(0, diff)));\n\n          this.alphabet = this.alphabet.slice(diff);\n        }\n      }\n\n      this.alphabet = shuffle(this.alphabet, saltChars);\n      var guardCount = Math.ceil(this.alphabet.length / guardDiv);\n\n      if (this.alphabet.length < 3) {\n        this.guards = this.seps.slice(0, guardCount);\n        this.seps = this.seps.slice(guardCount);\n      } else {\n        this.guards = this.alphabet.slice(0, guardCount);\n        this.alphabet = this.alphabet.slice(guardCount);\n      }\n\n      this.guardsRegExp = makeAnyOfCharsRegExp(this.guards);\n      this.sepsRegExp = makeAnyOfCharsRegExp(this.seps);\n      this.allowedCharsRegExp = makeAtLeastSomeCharRegExp([].concat(_toConsumableArray(this.alphabet), _toConsumableArray(this.guards), _toConsumableArray(this.seps)));\n    }\n\n    var _proto = Hashids.prototype;\n\n    _proto.encode = function encode(first) {\n      for (var _len = arguments.length, numbers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        numbers[_key - 1] = arguments[_key];\n      }\n\n      var ret = '';\n\n      if (Array.isArray(first)) {\n        numbers = first;\n      } else {\n        // eslint-disable-next-line eqeqeq\n        numbers = [].concat(_toConsumableArray(first != null ? [first] : []), _toConsumableArray(numbers));\n      }\n\n      if (!numbers.length) {\n        return ret;\n      }\n\n      if (!numbers.every(isIntegerNumber)) {\n        numbers = numbers.map(function (n) {\n          return typeof n === 'bigint' || typeof n === 'number' ? n : safeParseInt10(String(n));\n        });\n      }\n\n      if (!numbers.every(isPositiveAndFinite)) {\n        return ret;\n      }\n\n      return this._encode(numbers).join('');\n    };\n\n    _proto.decode = function decode(id) {\n      if (!id || typeof id !== 'string' || id.length === 0) return [];\n      return this._decode(id);\n    }\n    /**\n     * @description Splits a hex string into groups of 12-digit hexadecimal numbers,\n     * then prefixes each with '1' and encodes the resulting array of numbers\n     *\n     * Encoding '00000000000f00000000000f000f' would be the equivalent of:\n     * Hashids.encode([0x100000000000f, 0x100000000000f, 0x1000f])\n     *\n     * This means that if your environment supports BigInts,\n     * you will get different (shorter) results if you provide\n     * a BigInt representation of your hex and use `encode` directly, e.g.:\n     * Hashids.encode(BigInt(`0x${hex}`))\n     *\n     * To decode such a representation back to a hex string, use the following snippet:\n     * Hashids.decode(id)[0].toString(16)\n     */\n    ;\n\n    _proto.encodeHex = function encodeHex(hex) {\n      switch (typeof hex) {\n        case 'bigint':\n          hex = hex.toString(16);\n          break;\n\n        case 'string':\n          if (!/^[0-9a-fA-F]+$/.test(hex)) return '';\n          break;\n\n        default:\n          throw new Error(\"Hashids: The provided value is neither a string, nor a BigInt (got: \" + typeof hex + \")\");\n      }\n\n      var numbers = splitAtIntervalAndMap(hex, 12, function (part) {\n        return parseInt(\"1\" + part, 16);\n      });\n      return this.encode(numbers);\n    };\n\n    _proto.decodeHex = function decodeHex(id) {\n      return this.decode(id).map(function (number) {\n        return number.toString(16).slice(1);\n      }).join('');\n    };\n\n    _proto._encode = function _encode(numbers) {\n      var _this = this;\n\n      var alphabet = this.alphabet;\n      var numbersIdInt = numbers.reduce(function (last, number, i) {\n        return last + (typeof number === 'bigint' ? Number(number % BigInt(i + 100)) : number % (i + 100));\n      }, 0);\n      var ret = [alphabet[numbersIdInt % alphabet.length]];\n      var lottery = ret.slice();\n      var seps = this.seps;\n      var guards = this.guards;\n      numbers.forEach(function (number, i) {\n        var _ret;\n\n        var buffer = lottery.concat(_this.salt, alphabet);\n        alphabet = shuffle(alphabet, buffer);\n        var last = toAlphabet(number, alphabet);\n\n        (_ret = ret).push.apply(_ret, _toConsumableArray(last));\n\n        if (i + 1 < numbers.length) {\n          var charCode = last[0].codePointAt(0) + i;\n          var extraNumber = typeof number === 'bigint' ? Number(number % BigInt(charCode)) : number % charCode;\n          ret.push(seps[extraNumber % seps.length]);\n        }\n      });\n\n      if (ret.length < this.minLength) {\n        var prefixGuardIndex = (numbersIdInt + ret[0].codePointAt(0)) % guards.length;\n        ret.unshift(guards[prefixGuardIndex]);\n\n        if (ret.length < this.minLength) {\n          var suffixGuardIndex = (numbersIdInt + ret[2].codePointAt(0)) % guards.length;\n          ret.push(guards[suffixGuardIndex]);\n        }\n      }\n\n      var halfLength = Math.floor(alphabet.length / 2);\n\n      while (ret.length < this.minLength) {\n        var _ret2, _ret3;\n\n        alphabet = shuffle(alphabet, alphabet);\n\n        (_ret2 = ret).unshift.apply(_ret2, _toConsumableArray(alphabet.slice(halfLength)));\n\n        (_ret3 = ret).push.apply(_ret3, _toConsumableArray(alphabet.slice(0, halfLength)));\n\n        var excess = ret.length - this.minLength;\n\n        if (excess > 0) {\n          var halfOfExcess = excess / 2;\n          ret = ret.slice(halfOfExcess, halfOfExcess + this.minLength);\n        }\n      }\n\n      return ret;\n    };\n\n    _proto.isValidId = function isValidId(id) {\n      return this.allowedCharsRegExp.test(id);\n    };\n\n    _proto._decode = function _decode(id) {\n      if (!this.isValidId(id)) {\n        throw new Error(\"The provided ID (\" + id + \") is invalid, as it contains characters that do not exist in the alphabet (\" + this.guards.join('') + this.seps.join('') + this.alphabet.join('') + \")\");\n      }\n\n      var idGuardsArray = id.split(this.guardsRegExp);\n      var splitIndex = idGuardsArray.length === 3 || idGuardsArray.length === 2 ? 1 : 0;\n      var idBreakdown = idGuardsArray[splitIndex];\n      if (idBreakdown.length === 0) return [];\n      var lotteryChar = idBreakdown[Symbol.iterator]().next().value;\n      var idArray = idBreakdown.slice(lotteryChar.length).split(this.sepsRegExp);\n      var lastAlphabet = this.alphabet;\n      var result = [];\n\n      for (var _iterator = idArray, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var subId = _ref;\n        var buffer = [lotteryChar].concat(_toConsumableArray(this.salt), _toConsumableArray(lastAlphabet));\n        var nextAlphabet = shuffle(lastAlphabet, buffer.slice(0, lastAlphabet.length));\n        result.push(fromAlphabet(Array.from(subId), nextAlphabet));\n        lastAlphabet = nextAlphabet;\n      } // if the result is different from what we'd expect, we return an empty result (malformed input):\n\n\n      if (this._encode(result).join('') !== id) return [];\n      return result;\n    };\n\n    return Hashids;\n  }();\n\n  _exports.default = Hashids;\n  var minAlphabetLength = 16;\n  var sepDiv = 3.5;\n  var guardDiv = 12;\n\n  var keepUnique = function keepUnique(content) {\n    return Array.from(new Set(content));\n  };\n\n  _exports.keepUnique = keepUnique;\n\n  var withoutChars = function withoutChars(chars, _withoutChars) {\n    return chars.filter(function (char) {\n      return !_withoutChars.includes(char);\n    });\n  };\n\n  _exports.withoutChars = withoutChars;\n\n  var onlyChars = function onlyChars(chars, keepChars) {\n    return chars.filter(function (char) {\n      return keepChars.includes(char);\n    });\n  };\n\n  _exports.onlyChars = onlyChars;\n\n  var isIntegerNumber = function isIntegerNumber(n) {\n    return typeof n === 'bigint' || !Number.isNaN(Number(n)) && Math.floor(Number(n)) === n;\n  };\n\n  var isPositiveAndFinite = function isPositiveAndFinite(n) {\n    return typeof n === 'bigint' || n >= 0 && Number.isSafeInteger(n);\n  };\n\n  function shuffle(alphabetChars, saltChars) {\n    if (saltChars.length === 0) {\n      return alphabetChars;\n    }\n\n    var integer;\n    var transformed = alphabetChars.slice();\n\n    for (var i = transformed.length - 1, v = 0, p = 0; i > 0; i--, v++) {\n      v %= saltChars.length;\n      p += integer = saltChars[v].codePointAt(0);\n      var j = (integer + v + p) % i; // swap characters at positions i and j\n\n      var a = transformed[i];\n      var b = transformed[j];\n      transformed[j] = a;\n      transformed[i] = b;\n    }\n\n    return transformed;\n  }\n\n  var toAlphabet = function toAlphabet(input, alphabetChars) {\n    var id = [];\n\n    if (typeof input === 'bigint') {\n      var alphabetLength = BigInt(alphabetChars.length);\n\n      do {\n        id.unshift(alphabetChars[Number(input % alphabetLength)]);\n        input = input / alphabetLength;\n      } while (input > BigInt(0));\n    } else {\n      do {\n        id.unshift(alphabetChars[input % alphabetChars.length]);\n        input = Math.floor(input / alphabetChars.length);\n      } while (input > 0);\n    }\n\n    return id;\n  };\n\n  var fromAlphabet = function fromAlphabet(inputChars, alphabetChars) {\n    return inputChars.reduce(function (carry, item) {\n      var index = alphabetChars.indexOf(item);\n\n      if (index === -1) {\n        throw new Error(\"The provided ID (\" + inputChars.join('') + \") is invalid, as it contains characters that do not exist in the alphabet (\" + alphabetChars.join('') + \")\");\n      }\n\n      if (typeof carry === 'bigint') {\n        return carry * BigInt(alphabetChars.length) + BigInt(index);\n      }\n\n      var value = carry * alphabetChars.length + index;\n      var isSafeValue = Number.isSafeInteger(value);\n\n      if (isSafeValue) {\n        return value;\n      } else {\n        if (typeof BigInt === 'function') {\n          return BigInt(carry) * BigInt(alphabetChars.length) + BigInt(index);\n        } else {\n          // we do not have support for BigInt:\n          throw new Error(\"Unable to decode the provided string, due to lack of support for BigInt numbers in the current environment\");\n        }\n      }\n    }, 0);\n  };\n\n  var safeToParseNumberRegExp = /^\\+?[0-9]+$/;\n\n  var safeParseInt10 = function safeParseInt10(str) {\n    return safeToParseNumberRegExp.test(str) ? parseInt(str, 10) : NaN;\n  };\n\n  var splitAtIntervalAndMap = function splitAtIntervalAndMap(str, nth, map) {\n    return Array.from({\n      length: Math.ceil(str.length / nth)\n    }, function (_, index) {\n      return map(str.slice(index * nth, (index + 1) * nth));\n    });\n  };\n\n  var makeAnyOfCharsRegExp = function makeAnyOfCharsRegExp(chars) {\n    return new RegExp(chars.map(function (char) {\n      return escapeRegExp(char);\n    }) // we need to sort these from longest to shortest,\n    // as they may contain multibyte unicode characters (these should come first)\n    .sort(function (a, b) {\n      return b.length - a.length;\n    }).join('|'));\n  };\n\n  var makeAtLeastSomeCharRegExp = function makeAtLeastSomeCharRegExp(chars) {\n    return new RegExp(\"^[\" + chars.map(function (char) {\n      return escapeRegExp(char);\n    }) // we need to sort these from longest to shortest,\n    // as they may contain multibyte unicode characters (these should come first)\n    .sort(function (a, b) {\n      return b.length - a.length;\n    }).join('') + \"]+$\");\n  };\n\n  var escapeRegExp = function escapeRegExp(text) {\n    return text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n  };\n});\n\n//# sourceMappingURL=hashids.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2hhc2hpZHMvZGlzdC9oYXNoaWRzLmpzPzcwYzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxNQUFNLElBQTBDO0FBQ2hELElBQUksaUNBQWtCLENBQUMsT0FBUyxDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDM0MsR0FBRyxNQUFNLFlBUU47QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0MsaUZBQWlGOztBQUVySCxpQ0FBaUMsd0VBQXdFOztBQUV6RyxtQ0FBbUMsK0hBQStIOztBQUVsSyxvQ0FBb0MsMEJBQTBCLDhDQUE4QyxnQkFBZ0IsT0FBTyxrQkFBa0IsRUFBRSxhQUFhLEVBQUU7O0FBRXRLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwrRkFBK0YsYUFBYTtBQUM1RztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrSkFBa0o7QUFDbEo7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxDQUFDOztBQUVEIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9oYXNoaWRzL2Rpc3QvaGFzaGlkcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShcIkhhc2hpZHNcIiwgW1wiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBmYWN0b3J5KGV4cG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBtb2QgPSB7XG4gICAgICBleHBvcnRzOiB7fVxuICAgIH07XG4gICAgZmFjdG9yeShtb2QuZXhwb3J0cyk7XG4gICAgZ2xvYmFsLkhhc2hpZHMgPSBtb2QuZXhwb3J0cztcbiAgfVxufSkodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24gKF9leHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIF9leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICBfZXhwb3J0cy5vbmx5Q2hhcnMgPSBfZXhwb3J0cy53aXRob3V0Q2hhcnMgPSBfZXhwb3J0cy5rZWVwVW5pcXVlID0gX2V4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfVxuXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbiAgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gfVxuXG4gIHZhciBIYXNoaWRzID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGFzaGlkcyhzYWx0LCBtaW5MZW5ndGgsIGFscGhhYmV0LCBzZXBzKSB7XG4gICAgICBpZiAoc2FsdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNhbHQgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKG1pbkxlbmd0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG1pbkxlbmd0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbHBoYWJldCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoxMjM0NTY3ODkwJztcbiAgICAgIH1cblxuICAgICAgaWYgKHNlcHMgPT09IHZvaWQgMCkge1xuICAgICAgICBzZXBzID0gJ2NmaGlzdHVDRkhJU1RVJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5taW5MZW5ndGggPSBtaW5MZW5ndGg7XG5cbiAgICAgIGlmICh0eXBlb2YgbWluTGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSGFzaGlkczogUHJvdmlkZWQgJ21pbkxlbmd0aCcgaGFzIHRvIGJlIGEgbnVtYmVyIChpcyBcIiArIHR5cGVvZiBtaW5MZW5ndGggKyBcIilcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2FsdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkhhc2hpZHM6IFByb3ZpZGVkICdzYWx0JyBoYXMgdG8gYmUgYSBzdHJpbmcgKGlzIFwiICsgdHlwZW9mIHNhbHQgKyBcIilcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgYWxwaGFiZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJIYXNoaWRzOiBQcm92aWRlZCBhbHBoYWJldCBoYXMgdG8gYmUgYSBzdHJpbmcgKGlzIFwiICsgdHlwZW9mIGFscGhhYmV0ICsgXCIpXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2FsdENoYXJzID0gQXJyYXkuZnJvbShzYWx0KTtcbiAgICAgIHZhciBhbHBoYWJldENoYXJzID0gQXJyYXkuZnJvbShhbHBoYWJldCk7XG4gICAgICB2YXIgc2Vwc0NoYXJzID0gQXJyYXkuZnJvbShzZXBzKTtcbiAgICAgIHRoaXMuc2FsdCA9IHNhbHRDaGFycztcbiAgICAgIHZhciB1bmlxdWVBbHBoYWJldCA9IGtlZXBVbmlxdWUoYWxwaGFiZXRDaGFycyk7XG5cbiAgICAgIGlmICh1bmlxdWVBbHBoYWJldC5sZW5ndGggPCBtaW5BbHBoYWJldExlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYXNoaWRzOiBhbHBoYWJldCBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgXCIgKyBtaW5BbHBoYWJldExlbmd0aCArIFwiIHVuaXF1ZSBjaGFyYWN0ZXJzLCBwcm92aWRlZDogXCIgKyB1bmlxdWVBbHBoYWJldCk7XG4gICAgICB9XG4gICAgICAvKiogYGFscGhhYmV0YCBzaG91bGQgbm90IGNvbnRhaW5zIGBzZXBzYCAqL1xuXG5cbiAgICAgIHRoaXMuYWxwaGFiZXQgPSB3aXRob3V0Q2hhcnModW5pcXVlQWxwaGFiZXQsIHNlcHNDaGFycyk7XG4gICAgICAvKiogYHNlcHNgIHNob3VsZCBjb250YWluIG9ubHkgY2hhcmFjdGVycyBwcmVzZW50IGluIGBhbHBoYWJldGAgKi9cblxuICAgICAgdmFyIGZpbHRlcmVkU2VwcyA9IG9ubHlDaGFycyhzZXBzQ2hhcnMsIHVuaXF1ZUFscGhhYmV0KTtcbiAgICAgIHRoaXMuc2VwcyA9IHNodWZmbGUoZmlsdGVyZWRTZXBzLCBzYWx0Q2hhcnMpO1xuICAgICAgdmFyIHNlcHNMZW5ndGg7XG4gICAgICB2YXIgZGlmZjtcblxuICAgICAgaWYgKHRoaXMuc2Vwcy5sZW5ndGggPT09IDAgfHwgdGhpcy5hbHBoYWJldC5sZW5ndGggLyB0aGlzLnNlcHMubGVuZ3RoID4gc2VwRGl2KSB7XG4gICAgICAgIHNlcHNMZW5ndGggPSBNYXRoLmNlaWwodGhpcy5hbHBoYWJldC5sZW5ndGggLyBzZXBEaXYpO1xuXG4gICAgICAgIGlmIChzZXBzTGVuZ3RoID4gdGhpcy5zZXBzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBfdGhpcyRzZXBzO1xuXG4gICAgICAgICAgZGlmZiA9IHNlcHNMZW5ndGggLSB0aGlzLnNlcHMubGVuZ3RoO1xuXG4gICAgICAgICAgKF90aGlzJHNlcHMgPSB0aGlzLnNlcHMpLnB1c2guYXBwbHkoX3RoaXMkc2VwcywgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuYWxwaGFiZXQuc2xpY2UoMCwgZGlmZikpKTtcblxuICAgICAgICAgIHRoaXMuYWxwaGFiZXQgPSB0aGlzLmFscGhhYmV0LnNsaWNlKGRpZmYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWxwaGFiZXQgPSBzaHVmZmxlKHRoaXMuYWxwaGFiZXQsIHNhbHRDaGFycyk7XG4gICAgICB2YXIgZ3VhcmRDb3VudCA9IE1hdGguY2VpbCh0aGlzLmFscGhhYmV0Lmxlbmd0aCAvIGd1YXJkRGl2KTtcblxuICAgICAgaWYgKHRoaXMuYWxwaGFiZXQubGVuZ3RoIDwgMykge1xuICAgICAgICB0aGlzLmd1YXJkcyA9IHRoaXMuc2Vwcy5zbGljZSgwLCBndWFyZENvdW50KTtcbiAgICAgICAgdGhpcy5zZXBzID0gdGhpcy5zZXBzLnNsaWNlKGd1YXJkQ291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ndWFyZHMgPSB0aGlzLmFscGhhYmV0LnNsaWNlKDAsIGd1YXJkQ291bnQpO1xuICAgICAgICB0aGlzLmFscGhhYmV0ID0gdGhpcy5hbHBoYWJldC5zbGljZShndWFyZENvdW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ndWFyZHNSZWdFeHAgPSBtYWtlQW55T2ZDaGFyc1JlZ0V4cCh0aGlzLmd1YXJkcyk7XG4gICAgICB0aGlzLnNlcHNSZWdFeHAgPSBtYWtlQW55T2ZDaGFyc1JlZ0V4cCh0aGlzLnNlcHMpO1xuICAgICAgdGhpcy5hbGxvd2VkQ2hhcnNSZWdFeHAgPSBtYWtlQXRMZWFzdFNvbWVDaGFyUmVnRXhwKFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5hbHBoYWJldCksIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmd1YXJkcyksIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLnNlcHMpKSk7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IEhhc2hpZHMucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShmaXJzdCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG51bWJlcnMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBudW1iZXJzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldCA9ICcnO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShmaXJzdCkpIHtcbiAgICAgICAgbnVtYmVycyA9IGZpcnN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICBudW1iZXJzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShmaXJzdCAhPSBudWxsID8gW2ZpcnN0XSA6IFtdKSwgX3RvQ29uc3VtYWJsZUFycmF5KG51bWJlcnMpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFudW1iZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuXG4gICAgICBpZiAoIW51bWJlcnMuZXZlcnkoaXNJbnRlZ2VyTnVtYmVyKSkge1xuICAgICAgICBudW1iZXJzID0gbnVtYmVycy5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIG4gPT09ICdiaWdpbnQnIHx8IHR5cGVvZiBuID09PSAnbnVtYmVyJyA/IG4gOiBzYWZlUGFyc2VJbnQxMChTdHJpbmcobikpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFudW1iZXJzLmV2ZXJ5KGlzUG9zaXRpdmVBbmRGaW5pdGUpKSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9lbmNvZGUobnVtYmVycykuam9pbignJyk7XG4gICAgfTtcblxuICAgIF9wcm90by5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoaWQpIHtcbiAgICAgIGlmICghaWQgfHwgdHlwZW9mIGlkICE9PSAnc3RyaW5nJyB8fCBpZC5sZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgICAgIHJldHVybiB0aGlzLl9kZWNvZGUoaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gU3BsaXRzIGEgaGV4IHN0cmluZyBpbnRvIGdyb3VwcyBvZiAxMi1kaWdpdCBoZXhhZGVjaW1hbCBudW1iZXJzLFxuICAgICAqIHRoZW4gcHJlZml4ZXMgZWFjaCB3aXRoICcxJyBhbmQgZW5jb2RlcyB0aGUgcmVzdWx0aW5nIGFycmF5IG9mIG51bWJlcnNcbiAgICAgKlxuICAgICAqIEVuY29kaW5nICcwMDAwMDAwMDAwMGYwMDAwMDAwMDAwMGYwMDBmJyB3b3VsZCBiZSB0aGUgZXF1aXZhbGVudCBvZjpcbiAgICAgKiBIYXNoaWRzLmVuY29kZShbMHgxMDAwMDAwMDAwMDBmLCAweDEwMDAwMDAwMDAwMGYsIDB4MTAwMGZdKVxuICAgICAqXG4gICAgICogVGhpcyBtZWFucyB0aGF0IGlmIHlvdXIgZW52aXJvbm1lbnQgc3VwcG9ydHMgQmlnSW50cyxcbiAgICAgKiB5b3Ugd2lsbCBnZXQgZGlmZmVyZW50IChzaG9ydGVyKSByZXN1bHRzIGlmIHlvdSBwcm92aWRlXG4gICAgICogYSBCaWdJbnQgcmVwcmVzZW50YXRpb24gb2YgeW91ciBoZXggYW5kIHVzZSBgZW5jb2RlYCBkaXJlY3RseSwgZS5nLjpcbiAgICAgKiBIYXNoaWRzLmVuY29kZShCaWdJbnQoYDB4JHtoZXh9YCkpXG4gICAgICpcbiAgICAgKiBUbyBkZWNvZGUgc3VjaCBhIHJlcHJlc2VudGF0aW9uIGJhY2sgdG8gYSBoZXggc3RyaW5nLCB1c2UgdGhlIGZvbGxvd2luZyBzbmlwcGV0OlxuICAgICAqIEhhc2hpZHMuZGVjb2RlKGlkKVswXS50b1N0cmluZygxNilcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uZW5jb2RlSGV4ID0gZnVuY3Rpb24gZW5jb2RlSGV4KGhleCkge1xuICAgICAgc3dpdGNoICh0eXBlb2YgaGV4KSB7XG4gICAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgICAgaGV4ID0gaGV4LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgIGlmICghL15bMC05YS1mQS1GXSskLy50ZXN0KGhleCkpIHJldHVybiAnJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhhc2hpZHM6IFRoZSBwcm92aWRlZCB2YWx1ZSBpcyBuZWl0aGVyIGEgc3RyaW5nLCBub3IgYSBCaWdJbnQgKGdvdDogXCIgKyB0eXBlb2YgaGV4ICsgXCIpXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbnVtYmVycyA9IHNwbGl0QXRJbnRlcnZhbEFuZE1hcChoZXgsIDEyLCBmdW5jdGlvbiAocGFydCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoXCIxXCIgKyBwYXJ0LCAxNik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLmVuY29kZShudW1iZXJzKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmRlY29kZUhleCA9IGZ1bmN0aW9uIGRlY29kZUhleChpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKGlkKS5tYXAoZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICByZXR1cm4gbnVtYmVyLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgICAgIH0pLmpvaW4oJycpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2VuY29kZSA9IGZ1bmN0aW9uIF9lbmNvZGUobnVtYmVycykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGFscGhhYmV0ID0gdGhpcy5hbHBoYWJldDtcbiAgICAgIHZhciBudW1iZXJzSWRJbnQgPSBudW1iZXJzLnJlZHVjZShmdW5jdGlvbiAobGFzdCwgbnVtYmVyLCBpKSB7XG4gICAgICAgIHJldHVybiBsYXN0ICsgKHR5cGVvZiBudW1iZXIgPT09ICdiaWdpbnQnID8gTnVtYmVyKG51bWJlciAlIEJpZ0ludChpICsgMTAwKSkgOiBudW1iZXIgJSAoaSArIDEwMCkpO1xuICAgICAgfSwgMCk7XG4gICAgICB2YXIgcmV0ID0gW2FscGhhYmV0W251bWJlcnNJZEludCAlIGFscGhhYmV0Lmxlbmd0aF1dO1xuICAgICAgdmFyIGxvdHRlcnkgPSByZXQuc2xpY2UoKTtcbiAgICAgIHZhciBzZXBzID0gdGhpcy5zZXBzO1xuICAgICAgdmFyIGd1YXJkcyA9IHRoaXMuZ3VhcmRzO1xuICAgICAgbnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChudW1iZXIsIGkpIHtcbiAgICAgICAgdmFyIF9yZXQ7XG5cbiAgICAgICAgdmFyIGJ1ZmZlciA9IGxvdHRlcnkuY29uY2F0KF90aGlzLnNhbHQsIGFscGhhYmV0KTtcbiAgICAgICAgYWxwaGFiZXQgPSBzaHVmZmxlKGFscGhhYmV0LCBidWZmZXIpO1xuICAgICAgICB2YXIgbGFzdCA9IHRvQWxwaGFiZXQobnVtYmVyLCBhbHBoYWJldCk7XG5cbiAgICAgICAgKF9yZXQgPSByZXQpLnB1c2guYXBwbHkoX3JldCwgX3RvQ29uc3VtYWJsZUFycmF5KGxhc3QpKTtcblxuICAgICAgICBpZiAoaSArIDEgPCBudW1iZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBjaGFyQ29kZSA9IGxhc3RbMF0uY29kZVBvaW50QXQoMCkgKyBpO1xuICAgICAgICAgIHZhciBleHRyYU51bWJlciA9IHR5cGVvZiBudW1iZXIgPT09ICdiaWdpbnQnID8gTnVtYmVyKG51bWJlciAlIEJpZ0ludChjaGFyQ29kZSkpIDogbnVtYmVyICUgY2hhckNvZGU7XG4gICAgICAgICAgcmV0LnB1c2goc2Vwc1tleHRyYU51bWJlciAlIHNlcHMubGVuZ3RoXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmV0Lmxlbmd0aCA8IHRoaXMubWluTGVuZ3RoKSB7XG4gICAgICAgIHZhciBwcmVmaXhHdWFyZEluZGV4ID0gKG51bWJlcnNJZEludCArIHJldFswXS5jb2RlUG9pbnRBdCgwKSkgJSBndWFyZHMubGVuZ3RoO1xuICAgICAgICByZXQudW5zaGlmdChndWFyZHNbcHJlZml4R3VhcmRJbmRleF0pO1xuXG4gICAgICAgIGlmIChyZXQubGVuZ3RoIDwgdGhpcy5taW5MZW5ndGgpIHtcbiAgICAgICAgICB2YXIgc3VmZml4R3VhcmRJbmRleCA9IChudW1iZXJzSWRJbnQgKyByZXRbMl0uY29kZVBvaW50QXQoMCkpICUgZ3VhcmRzLmxlbmd0aDtcbiAgICAgICAgICByZXQucHVzaChndWFyZHNbc3VmZml4R3VhcmRJbmRleF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBoYWxmTGVuZ3RoID0gTWF0aC5mbG9vcihhbHBoYWJldC5sZW5ndGggLyAyKTtcblxuICAgICAgd2hpbGUgKHJldC5sZW5ndGggPCB0aGlzLm1pbkxlbmd0aCkge1xuICAgICAgICB2YXIgX3JldDIsIF9yZXQzO1xuXG4gICAgICAgIGFscGhhYmV0ID0gc2h1ZmZsZShhbHBoYWJldCwgYWxwaGFiZXQpO1xuXG4gICAgICAgIChfcmV0MiA9IHJldCkudW5zaGlmdC5hcHBseShfcmV0MiwgX3RvQ29uc3VtYWJsZUFycmF5KGFscGhhYmV0LnNsaWNlKGhhbGZMZW5ndGgpKSk7XG5cbiAgICAgICAgKF9yZXQzID0gcmV0KS5wdXNoLmFwcGx5KF9yZXQzLCBfdG9Db25zdW1hYmxlQXJyYXkoYWxwaGFiZXQuc2xpY2UoMCwgaGFsZkxlbmd0aCkpKTtcblxuICAgICAgICB2YXIgZXhjZXNzID0gcmV0Lmxlbmd0aCAtIHRoaXMubWluTGVuZ3RoO1xuXG4gICAgICAgIGlmIChleGNlc3MgPiAwKSB7XG4gICAgICAgICAgdmFyIGhhbGZPZkV4Y2VzcyA9IGV4Y2VzcyAvIDI7XG4gICAgICAgICAgcmV0ID0gcmV0LnNsaWNlKGhhbGZPZkV4Y2VzcywgaGFsZk9mRXhjZXNzICsgdGhpcy5taW5MZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIF9wcm90by5pc1ZhbGlkSWQgPSBmdW5jdGlvbiBpc1ZhbGlkSWQoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFsbG93ZWRDaGFyc1JlZ0V4cC50ZXN0KGlkKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9kZWNvZGUgPSBmdW5jdGlvbiBfZGVjb2RlKGlkKSB7XG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZElkKGlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcHJvdmlkZWQgSUQgKFwiICsgaWQgKyBcIikgaXMgaW52YWxpZCwgYXMgaXQgY29udGFpbnMgY2hhcmFjdGVycyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgYWxwaGFiZXQgKFwiICsgdGhpcy5ndWFyZHMuam9pbignJykgKyB0aGlzLnNlcHMuam9pbignJykgKyB0aGlzLmFscGhhYmV0LmpvaW4oJycpICsgXCIpXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWRHdWFyZHNBcnJheSA9IGlkLnNwbGl0KHRoaXMuZ3VhcmRzUmVnRXhwKTtcbiAgICAgIHZhciBzcGxpdEluZGV4ID0gaWRHdWFyZHNBcnJheS5sZW5ndGggPT09IDMgfHwgaWRHdWFyZHNBcnJheS5sZW5ndGggPT09IDIgPyAxIDogMDtcbiAgICAgIHZhciBpZEJyZWFrZG93biA9IGlkR3VhcmRzQXJyYXlbc3BsaXRJbmRleF07XG4gICAgICBpZiAoaWRCcmVha2Rvd24ubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gICAgICB2YXIgbG90dGVyeUNoYXIgPSBpZEJyZWFrZG93bltTeW1ib2wuaXRlcmF0b3JdKCkubmV4dCgpLnZhbHVlO1xuICAgICAgdmFyIGlkQXJyYXkgPSBpZEJyZWFrZG93bi5zbGljZShsb3R0ZXJ5Q2hhci5sZW5ndGgpLnNwbGl0KHRoaXMuc2Vwc1JlZ0V4cCk7XG4gICAgICB2YXIgbGFzdEFscGhhYmV0ID0gdGhpcy5hbHBoYWJldDtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gaWRBcnJheSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgdmFyIF9yZWY7XG5cbiAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3ViSWQgPSBfcmVmO1xuICAgICAgICB2YXIgYnVmZmVyID0gW2xvdHRlcnlDaGFyXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuc2FsdCksIF90b0NvbnN1bWFibGVBcnJheShsYXN0QWxwaGFiZXQpKTtcbiAgICAgICAgdmFyIG5leHRBbHBoYWJldCA9IHNodWZmbGUobGFzdEFscGhhYmV0LCBidWZmZXIuc2xpY2UoMCwgbGFzdEFscGhhYmV0Lmxlbmd0aCkpO1xuICAgICAgICByZXN1bHQucHVzaChmcm9tQWxwaGFiZXQoQXJyYXkuZnJvbShzdWJJZCksIG5leHRBbHBoYWJldCkpO1xuICAgICAgICBsYXN0QWxwaGFiZXQgPSBuZXh0QWxwaGFiZXQ7XG4gICAgICB9IC8vIGlmIHRoZSByZXN1bHQgaXMgZGlmZmVyZW50IGZyb20gd2hhdCB3ZSdkIGV4cGVjdCwgd2UgcmV0dXJuIGFuIGVtcHR5IHJlc3VsdCAobWFsZm9ybWVkIGlucHV0KTpcblxuXG4gICAgICBpZiAodGhpcy5fZW5jb2RlKHJlc3VsdCkuam9pbignJykgIT09IGlkKSByZXR1cm4gW107XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICByZXR1cm4gSGFzaGlkcztcbiAgfSgpO1xuXG4gIF9leHBvcnRzLmRlZmF1bHQgPSBIYXNoaWRzO1xuICB2YXIgbWluQWxwaGFiZXRMZW5ndGggPSAxNjtcbiAgdmFyIHNlcERpdiA9IDMuNTtcbiAgdmFyIGd1YXJkRGl2ID0gMTI7XG5cbiAgdmFyIGtlZXBVbmlxdWUgPSBmdW5jdGlvbiBrZWVwVW5pcXVlKGNvbnRlbnQpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGNvbnRlbnQpKTtcbiAgfTtcblxuICBfZXhwb3J0cy5rZWVwVW5pcXVlID0ga2VlcFVuaXF1ZTtcblxuICB2YXIgd2l0aG91dENoYXJzID0gZnVuY3Rpb24gd2l0aG91dENoYXJzKGNoYXJzLCBfd2l0aG91dENoYXJzKSB7XG4gICAgcmV0dXJuIGNoYXJzLmZpbHRlcihmdW5jdGlvbiAoY2hhcikge1xuICAgICAgcmV0dXJuICFfd2l0aG91dENoYXJzLmluY2x1ZGVzKGNoYXIpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9leHBvcnRzLndpdGhvdXRDaGFycyA9IHdpdGhvdXRDaGFycztcblxuICB2YXIgb25seUNoYXJzID0gZnVuY3Rpb24gb25seUNoYXJzKGNoYXJzLCBrZWVwQ2hhcnMpIHtcbiAgICByZXR1cm4gY2hhcnMuZmlsdGVyKGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICByZXR1cm4ga2VlcENoYXJzLmluY2x1ZGVzKGNoYXIpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9leHBvcnRzLm9ubHlDaGFycyA9IG9ubHlDaGFycztcblxuICB2YXIgaXNJbnRlZ2VyTnVtYmVyID0gZnVuY3Rpb24gaXNJbnRlZ2VyTnVtYmVyKG4pIHtcbiAgICByZXR1cm4gdHlwZW9mIG4gPT09ICdiaWdpbnQnIHx8ICFOdW1iZXIuaXNOYU4oTnVtYmVyKG4pKSAmJiBNYXRoLmZsb29yKE51bWJlcihuKSkgPT09IG47XG4gIH07XG5cbiAgdmFyIGlzUG9zaXRpdmVBbmRGaW5pdGUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlQW5kRmluaXRlKG4pIHtcbiAgICByZXR1cm4gdHlwZW9mIG4gPT09ICdiaWdpbnQnIHx8IG4gPj0gMCAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcihuKTtcbiAgfTtcblxuICBmdW5jdGlvbiBzaHVmZmxlKGFscGhhYmV0Q2hhcnMsIHNhbHRDaGFycykge1xuICAgIGlmIChzYWx0Q2hhcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYWxwaGFiZXRDaGFycztcbiAgICB9XG5cbiAgICB2YXIgaW50ZWdlcjtcbiAgICB2YXIgdHJhbnNmb3JtZWQgPSBhbHBoYWJldENoYXJzLnNsaWNlKCk7XG5cbiAgICBmb3IgKHZhciBpID0gdHJhbnNmb3JtZWQubGVuZ3RoIC0gMSwgdiA9IDAsIHAgPSAwOyBpID4gMDsgaS0tLCB2KyspIHtcbiAgICAgIHYgJT0gc2FsdENoYXJzLmxlbmd0aDtcbiAgICAgIHAgKz0gaW50ZWdlciA9IHNhbHRDaGFyc1t2XS5jb2RlUG9pbnRBdCgwKTtcbiAgICAgIHZhciBqID0gKGludGVnZXIgKyB2ICsgcCkgJSBpOyAvLyBzd2FwIGNoYXJhY3RlcnMgYXQgcG9zaXRpb25zIGkgYW5kIGpcblxuICAgICAgdmFyIGEgPSB0cmFuc2Zvcm1lZFtpXTtcbiAgICAgIHZhciBiID0gdHJhbnNmb3JtZWRbal07XG4gICAgICB0cmFuc2Zvcm1lZFtqXSA9IGE7XG4gICAgICB0cmFuc2Zvcm1lZFtpXSA9IGI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICB9XG5cbiAgdmFyIHRvQWxwaGFiZXQgPSBmdW5jdGlvbiB0b0FscGhhYmV0KGlucHV0LCBhbHBoYWJldENoYXJzKSB7XG4gICAgdmFyIGlkID0gW107XG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgdmFyIGFscGhhYmV0TGVuZ3RoID0gQmlnSW50KGFscGhhYmV0Q2hhcnMubGVuZ3RoKTtcblxuICAgICAgZG8ge1xuICAgICAgICBpZC51bnNoaWZ0KGFscGhhYmV0Q2hhcnNbTnVtYmVyKGlucHV0ICUgYWxwaGFiZXRMZW5ndGgpXSk7XG4gICAgICAgIGlucHV0ID0gaW5wdXQgLyBhbHBoYWJldExlbmd0aDtcbiAgICAgIH0gd2hpbGUgKGlucHV0ID4gQmlnSW50KDApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG8ge1xuICAgICAgICBpZC51bnNoaWZ0KGFscGhhYmV0Q2hhcnNbaW5wdXQgJSBhbHBoYWJldENoYXJzLmxlbmd0aF0pO1xuICAgICAgICBpbnB1dCA9IE1hdGguZmxvb3IoaW5wdXQgLyBhbHBoYWJldENoYXJzLmxlbmd0aCk7XG4gICAgICB9IHdoaWxlIChpbnB1dCA+IDApO1xuICAgIH1cblxuICAgIHJldHVybiBpZDtcbiAgfTtcblxuICB2YXIgZnJvbUFscGhhYmV0ID0gZnVuY3Rpb24gZnJvbUFscGhhYmV0KGlucHV0Q2hhcnMsIGFscGhhYmV0Q2hhcnMpIHtcbiAgICByZXR1cm4gaW5wdXRDaGFycy5yZWR1Y2UoZnVuY3Rpb24gKGNhcnJ5LCBpdGVtKSB7XG4gICAgICB2YXIgaW5kZXggPSBhbHBoYWJldENoYXJzLmluZGV4T2YoaXRlbSk7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHByb3ZpZGVkIElEIChcIiArIGlucHV0Q2hhcnMuam9pbignJykgKyBcIikgaXMgaW52YWxpZCwgYXMgaXQgY29udGFpbnMgY2hhcmFjdGVycyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgYWxwaGFiZXQgKFwiICsgYWxwaGFiZXRDaGFycy5qb2luKCcnKSArIFwiKVwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjYXJyeSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIGNhcnJ5ICogQmlnSW50KGFscGhhYmV0Q2hhcnMubGVuZ3RoKSArIEJpZ0ludChpbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGNhcnJ5ICogYWxwaGFiZXRDaGFycy5sZW5ndGggKyBpbmRleDtcbiAgICAgIHZhciBpc1NhZmVWYWx1ZSA9IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKTtcblxuICAgICAgaWYgKGlzU2FmZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgQmlnSW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIEJpZ0ludChjYXJyeSkgKiBCaWdJbnQoYWxwaGFiZXRDaGFycy5sZW5ndGgpICsgQmlnSW50KGluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB3ZSBkbyBub3QgaGF2ZSBzdXBwb3J0IGZvciBCaWdJbnQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRlY29kZSB0aGUgcHJvdmlkZWQgc3RyaW5nLCBkdWUgdG8gbGFjayBvZiBzdXBwb3J0IGZvciBCaWdJbnQgbnVtYmVycyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDApO1xuICB9O1xuXG4gIHZhciBzYWZlVG9QYXJzZU51bWJlclJlZ0V4cCA9IC9eXFwrP1swLTldKyQvO1xuXG4gIHZhciBzYWZlUGFyc2VJbnQxMCA9IGZ1bmN0aW9uIHNhZmVQYXJzZUludDEwKHN0cikge1xuICAgIHJldHVybiBzYWZlVG9QYXJzZU51bWJlclJlZ0V4cC50ZXN0KHN0cikgPyBwYXJzZUludChzdHIsIDEwKSA6IE5hTjtcbiAgfTtcblxuICB2YXIgc3BsaXRBdEludGVydmFsQW5kTWFwID0gZnVuY3Rpb24gc3BsaXRBdEludGVydmFsQW5kTWFwKHN0ciwgbnRoLCBtYXApIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh7XG4gICAgICBsZW5ndGg6IE1hdGguY2VpbChzdHIubGVuZ3RoIC8gbnRoKVxuICAgIH0sIGZ1bmN0aW9uIChfLCBpbmRleCkge1xuICAgICAgcmV0dXJuIG1hcChzdHIuc2xpY2UoaW5kZXggKiBudGgsIChpbmRleCArIDEpICogbnRoKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIG1ha2VBbnlPZkNoYXJzUmVnRXhwID0gZnVuY3Rpb24gbWFrZUFueU9mQ2hhcnNSZWdFeHAoY2hhcnMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChjaGFycy5tYXAoZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgIHJldHVybiBlc2NhcGVSZWdFeHAoY2hhcik7XG4gICAgfSkgLy8gd2UgbmVlZCB0byBzb3J0IHRoZXNlIGZyb20gbG9uZ2VzdCB0byBzaG9ydGVzdCxcbiAgICAvLyBhcyB0aGV5IG1heSBjb250YWluIG11bHRpYnl0ZSB1bmljb2RlIGNoYXJhY3RlcnMgKHRoZXNlIHNob3VsZCBjb21lIGZpcnN0KVxuICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICB9KS5qb2luKCd8JykpO1xuICB9O1xuXG4gIHZhciBtYWtlQXRMZWFzdFNvbWVDaGFyUmVnRXhwID0gZnVuY3Rpb24gbWFrZUF0TGVhc3RTb21lQ2hhclJlZ0V4cChjaGFycykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXltcIiArIGNoYXJzLm1hcChmdW5jdGlvbiAoY2hhcikge1xuICAgICAgcmV0dXJuIGVzY2FwZVJlZ0V4cChjaGFyKTtcbiAgICB9KSAvLyB3ZSBuZWVkIHRvIHNvcnQgdGhlc2UgZnJvbSBsb25nZXN0IHRvIHNob3J0ZXN0LFxuICAgIC8vIGFzIHRoZXkgbWF5IGNvbnRhaW4gbXVsdGlieXRlIHVuaWNvZGUgY2hhcmFjdGVycyAodGhlc2Ugc2hvdWxkIGNvbWUgZmlyc3QpXG4gICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgIH0pLmpvaW4oJycpICsgXCJdKyRcIik7XG4gIH07XG5cbiAgdmFyIGVzY2FwZVJlZ0V4cCA9IGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbiAgfTtcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoaWRzLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/hashids/dist/hashids.js\n");

/***/ }),

/***/ "../../node_modules/ip/lib/ip.js":
/*!*********************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/ip/lib/ip.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ip = exports;\nvar Buffer = __webpack_require__(/*! buffer */ \"buffer\").Buffer;\nvar os = __webpack_require__(/*! os */ \"os\");\n\nip.toBuffer = function(ip, buff, offset) {\n  offset = ~~offset;\n\n  var result;\n\n  if (this.isV4Format(ip)) {\n    result = buff || new Buffer(offset + 4);\n    ip.split(/\\./g).map(function(byte) {\n      result[offset++] = parseInt(byte, 10) & 0xff;\n    });\n  } else if (this.isV6Format(ip)) {\n    var sections = ip.split(':', 8);\n\n    var i;\n    for (i = 0; i < sections.length; i++) {\n      var isv4 = this.isV4Format(sections[i]);\n      var v4Buffer;\n\n      if (isv4) {\n        v4Buffer = this.toBuffer(sections[i]);\n        sections[i] = v4Buffer.slice(0, 2).toString('hex');\n      }\n\n      if (v4Buffer && ++i < 8) {\n        sections.splice(i, 0, v4Buffer.slice(2, 4).toString('hex'));\n      }\n    }\n\n    if (sections[0] === '') {\n      while (sections.length < 8) sections.unshift('0');\n    } else if (sections[sections.length - 1] === '') {\n      while (sections.length < 8) sections.push('0');\n    } else if (sections.length < 8) {\n      for (i = 0; i < sections.length && sections[i] !== ''; i++);\n      var argv = [ i, 1 ];\n      for (i = 9 - sections.length; i > 0; i--) {\n        argv.push('0');\n      }\n      sections.splice.apply(sections, argv);\n    }\n\n    result = buff || new Buffer(offset + 16);\n    for (i = 0; i < sections.length; i++) {\n      var word = parseInt(sections[i], 16);\n      result[offset++] = (word >> 8) & 0xff;\n      result[offset++] = word & 0xff;\n    }\n  }\n\n  if (!result) {\n    throw Error('Invalid ip address: ' + ip);\n  }\n\n  return result;\n};\n\nip.toString = function(buff, offset, length) {\n  offset = ~~offset;\n  length = length || (buff.length - offset);\n\n  var result = [];\n  if (length === 4) {\n    // IPv4\n    for (var i = 0; i < length; i++) {\n      result.push(buff[offset + i]);\n    }\n    result = result.join('.');\n  } else if (length === 16) {\n    // IPv6\n    for (var i = 0; i < length; i += 2) {\n      result.push(buff.readUInt16BE(offset + i).toString(16));\n    }\n    result = result.join(':');\n    result = result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3');\n    result = result.replace(/:{3,4}/, '::');\n  }\n\n  return result;\n};\n\nvar ipv4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/;\nvar ipv6Regex =\n    /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;\n\nip.isV4Format = function(ip) {\n  return ipv4Regex.test(ip);\n};\n\nip.isV6Format = function(ip) {\n  return ipv6Regex.test(ip);\n};\nfunction _normalizeFamily(family) {\n  return family ? family.toLowerCase() : 'ipv4';\n}\n\nip.fromPrefixLen = function(prefixlen, family) {\n  if (prefixlen > 32) {\n    family = 'ipv6';\n  } else {\n    family = _normalizeFamily(family);\n  }\n\n  var len = 4;\n  if (family === 'ipv6') {\n    len = 16;\n  }\n  var buff = new Buffer(len);\n\n  for (var i = 0, n = buff.length; i < n; ++i) {\n    var bits = 8;\n    if (prefixlen < 8) {\n      bits = prefixlen;\n    }\n    prefixlen -= bits;\n\n    buff[i] = ~(0xff >> bits) & 0xff;\n  }\n\n  return ip.toString(buff);\n};\n\nip.mask = function(addr, mask) {\n  addr = ip.toBuffer(addr);\n  mask = ip.toBuffer(mask);\n\n  var result = new Buffer(Math.max(addr.length, mask.length));\n\n  var i = 0;\n  // Same protocol - do bitwise and\n  if (addr.length === mask.length) {\n    for (i = 0; i < addr.length; i++) {\n      result[i] = addr[i] & mask[i];\n    }\n  } else if (mask.length === 4) {\n    // IPv6 address and IPv4 mask\n    // (Mask low bits)\n    for (i = 0; i < mask.length; i++) {\n      result[i] = addr[addr.length - 4  + i] & mask[i];\n    }\n  } else {\n    // IPv6 mask and IPv4 addr\n    for (var i = 0; i < result.length - 6; i++) {\n      result[i] = 0;\n    }\n\n    // ::ffff:ipv4\n    result[10] = 0xff;\n    result[11] = 0xff;\n    for (i = 0; i < addr.length; i++) {\n      result[i + 12] = addr[i] & mask[i + 12];\n    }\n    i = i + 12;\n  }\n  for (; i < result.length; i++)\n    result[i] = 0;\n\n  return ip.toString(result);\n};\n\nip.cidr = function(cidrString) {\n  var cidrParts = cidrString.split('/');\n\n  var addr = cidrParts[0];\n  if (cidrParts.length !== 2)\n    throw new Error('invalid CIDR subnet: ' + addr);\n\n  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n\n  return ip.mask(addr, mask);\n};\n\nip.subnet = function(addr, mask) {\n  var networkAddress = ip.toLong(ip.mask(addr, mask));\n\n  // Calculate the mask's length.\n  var maskBuffer = ip.toBuffer(mask);\n  var maskLength = 0;\n\n  for (var i = 0; i < maskBuffer.length; i++) {\n    if (maskBuffer[i] === 0xff) {\n      maskLength += 8;\n    } else {\n      var octet = maskBuffer[i] & 0xff;\n      while (octet) {\n        octet = (octet << 1) & 0xff;\n        maskLength++;\n      }\n    }\n  }\n\n  var numberOfAddresses = Math.pow(2, 32 - maskLength);\n\n  return {\n    networkAddress: ip.fromLong(networkAddress),\n    firstAddress: numberOfAddresses <= 2 ?\n                    ip.fromLong(networkAddress) :\n                    ip.fromLong(networkAddress + 1),\n    lastAddress: numberOfAddresses <= 2 ?\n                    ip.fromLong(networkAddress + numberOfAddresses - 1) :\n                    ip.fromLong(networkAddress + numberOfAddresses - 2),\n    broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),\n    subnetMask: mask,\n    subnetMaskLength: maskLength,\n    numHosts: numberOfAddresses <= 2 ?\n                numberOfAddresses : numberOfAddresses - 2,\n    length: numberOfAddresses,\n    contains: function(other) {\n      return networkAddress === ip.toLong(ip.mask(other, mask));\n    }\n  };\n};\n\nip.cidrSubnet = function(cidrString) {\n  var cidrParts = cidrString.split('/');\n\n  var addr = cidrParts[0];\n  if (cidrParts.length !== 2)\n    throw new Error('invalid CIDR subnet: ' + addr);\n\n  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n\n  return ip.subnet(addr, mask);\n};\n\nip.not = function(addr) {\n  var buff = ip.toBuffer(addr);\n  for (var i = 0; i < buff.length; i++) {\n    buff[i] = 0xff ^ buff[i];\n  }\n  return ip.toString(buff);\n};\n\nip.or = function(a, b) {\n  a = ip.toBuffer(a);\n  b = ip.toBuffer(b);\n\n  // same protocol\n  if (a.length === b.length) {\n    for (var i = 0; i < a.length; ++i) {\n      a[i] |= b[i];\n    }\n    return ip.toString(a);\n\n  // mixed protocols\n  } else {\n    var buff = a;\n    var other = b;\n    if (b.length > a.length) {\n      buff = b;\n      other = a;\n    }\n\n    var offset = buff.length - other.length;\n    for (var i = offset; i < buff.length; ++i) {\n      buff[i] |= other[i - offset];\n    }\n\n    return ip.toString(buff);\n  }\n};\n\nip.isEqual = function(a, b) {\n  a = ip.toBuffer(a);\n  b = ip.toBuffer(b);\n\n  // Same protocol\n  if (a.length === b.length) {\n    for (var i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n\n  // Swap\n  if (b.length === 4) {\n    var t = b;\n    b = a;\n    a = t;\n  }\n\n  // a - IPv4, b - IPv6\n  for (var i = 0; i < 10; i++) {\n    if (b[i] !== 0) return false;\n  }\n\n  var word = b.readUInt16BE(10);\n  if (word !== 0 && word !== 0xffff) return false;\n\n  for (var i = 0; i < 4; i++) {\n    if (a[i] !== b[i + 12]) return false;\n  }\n\n  return true;\n};\n\nip.isPrivate = function(addr) {\n  return /^(::f{4}:)?10\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i\n      .test(addr) ||\n    /^(::f{4}:)?192\\.168\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) ||\n    /^(::f{4}:)?172\\.(1[6-9]|2\\d|30|31)\\.([0-9]{1,3})\\.([0-9]{1,3})$/i\n      .test(addr) ||\n    /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) ||\n    /^(::f{4}:)?169\\.254\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) ||\n    /^f[cd][0-9a-f]{2}:/i.test(addr) ||\n    /^fe80:/i.test(addr) ||\n    /^::1$/.test(addr) ||\n    /^::$/.test(addr);\n};\n\nip.isPublic = function(addr) {\n  return !ip.isPrivate(addr);\n};\n\nip.isLoopback = function(addr) {\n  return /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})/\n      .test(addr) ||\n    /^fe80::1$/.test(addr) ||\n    /^::1$/.test(addr) ||\n    /^::$/.test(addr);\n};\n\nip.loopback = function(family) {\n  //\n  // Default to `ipv4`\n  //\n  family = _normalizeFamily(family);\n\n  if (family !== 'ipv4' && family !== 'ipv6') {\n    throw new Error('family must be ipv4 or ipv6');\n  }\n\n  return family === 'ipv4' ? '127.0.0.1' : 'fe80::1';\n};\n\n//\n// ### function address (name, family)\n// #### @name {string|'public'|'private'} **Optional** Name or security\n//      of the network interface.\n// #### @family {ipv4|ipv6} **Optional** IP family of the address (defaults\n//      to ipv4).\n//\n// Returns the address for the network interface on the current system with\n// the specified `name`:\n//   * String: First `family` address of the interface.\n//             If not found see `undefined`.\n//   * 'public': the first public ip address of family.\n//   * 'private': the first private ip address of family.\n//   * undefined: First address with `ipv4` or loopback address `127.0.0.1`.\n//\nip.address = function(name, family) {\n  var interfaces = os.networkInterfaces();\n  var all;\n\n  //\n  // Default to `ipv4`\n  //\n  family = _normalizeFamily(family);\n\n  //\n  // If a specific network interface has been named,\n  // return the address.\n  //\n  if (name && name !== 'private' && name !== 'public') {\n    var res = interfaces[name].filter(function(details) {\n      var itemFamily = details.family.toLowerCase();\n      return itemFamily === family;\n    });\n    if (res.length === 0)\n      return undefined;\n    return res[0].address;\n  }\n\n  var all = Object.keys(interfaces).map(function (nic) {\n    //\n    // Note: name will only be `public` or `private`\n    // when this is called.\n    //\n    var addresses = interfaces[nic].filter(function (details) {\n      details.family = details.family.toLowerCase();\n      if (details.family !== family || ip.isLoopback(details.address)) {\n        return false;\n      } else if (!name) {\n        return true;\n      }\n\n      return name === 'public' ? ip.isPrivate(details.address) :\n          ip.isPublic(details.address);\n    });\n\n    return addresses.length ? addresses[0].address : undefined;\n  }).filter(Boolean);\n\n  return !all.length ? ip.loopback(family) : all[0];\n};\n\nip.toLong = function(ip) {\n  var ipl = 0;\n  ip.split('.').forEach(function(octet) {\n    ipl <<= 8;\n    ipl += parseInt(octet);\n  });\n  return(ipl >>> 0);\n};\n\nip.fromLong = function(ipl) {\n  return ((ipl >>> 24) + '.' +\n      (ipl >> 16 & 255) + '.' +\n      (ipl >> 8 & 255) + '.' +\n      (ipl & 255) );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2lwL2xpYi9pcC5qcz9jNmFiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLFNBQVMsbUJBQU8sQ0FBQyxjQUFJOztBQUVyQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsMkNBQTJDO0FBQzVEO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixJQUFJO0FBQ25DOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLElBQUksSUFBSSxJQUFJLEdBQUcsSUFBSTtBQUN6QztBQUNBLGlCQUFpQixJQUFJLElBQUksRUFBRSxJQUFJLElBQUksRUFBRSxFQUFFLGFBQWEsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJOztBQUVwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLE9BQU87QUFD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bm9kZV9tb2R1bGVzL2lwL2xpYi9pcC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGlwID0gZXhwb3J0cztcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgb3MgPSByZXF1aXJlKCdvcycpO1xuXG5pcC50b0J1ZmZlciA9IGZ1bmN0aW9uKGlwLCBidWZmLCBvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gfn5vZmZzZXQ7XG5cbiAgdmFyIHJlc3VsdDtcblxuICBpZiAodGhpcy5pc1Y0Rm9ybWF0KGlwKSkge1xuICAgIHJlc3VsdCA9IGJ1ZmYgfHwgbmV3IEJ1ZmZlcihvZmZzZXQgKyA0KTtcbiAgICBpcC5zcGxpdCgvXFwuL2cpLm1hcChmdW5jdGlvbihieXRlKSB7XG4gICAgICByZXN1bHRbb2Zmc2V0KytdID0gcGFyc2VJbnQoYnl0ZSwgMTApICYgMHhmZjtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0aGlzLmlzVjZGb3JtYXQoaXApKSB7XG4gICAgdmFyIHNlY3Rpb25zID0gaXAuc3BsaXQoJzonLCA4KTtcblxuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlzdjQgPSB0aGlzLmlzVjRGb3JtYXQoc2VjdGlvbnNbaV0pO1xuICAgICAgdmFyIHY0QnVmZmVyO1xuXG4gICAgICBpZiAoaXN2NCkge1xuICAgICAgICB2NEJ1ZmZlciA9IHRoaXMudG9CdWZmZXIoc2VjdGlvbnNbaV0pO1xuICAgICAgICBzZWN0aW9uc1tpXSA9IHY0QnVmZmVyLnNsaWNlKDAsIDIpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHY0QnVmZmVyICYmICsraSA8IDgpIHtcbiAgICAgICAgc2VjdGlvbnMuc3BsaWNlKGksIDAsIHY0QnVmZmVyLnNsaWNlKDIsIDQpLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlY3Rpb25zWzBdID09PSAnJykge1xuICAgICAgd2hpbGUgKHNlY3Rpb25zLmxlbmd0aCA8IDgpIHNlY3Rpb25zLnVuc2hpZnQoJzAnKTtcbiAgICB9IGVsc2UgaWYgKHNlY3Rpb25zW3NlY3Rpb25zLmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgd2hpbGUgKHNlY3Rpb25zLmxlbmd0aCA8IDgpIHNlY3Rpb25zLnB1c2goJzAnKTtcbiAgICB9IGVsc2UgaWYgKHNlY3Rpb25zLmxlbmd0aCA8IDgpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGggJiYgc2VjdGlvbnNbaV0gIT09ICcnOyBpKyspO1xuICAgICAgdmFyIGFyZ3YgPSBbIGksIDEgXTtcbiAgICAgIGZvciAoaSA9IDkgLSBzZWN0aW9ucy5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgYXJndi5wdXNoKCcwJyk7XG4gICAgICB9XG4gICAgICBzZWN0aW9ucy5zcGxpY2UuYXBwbHkoc2VjdGlvbnMsIGFyZ3YpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IGJ1ZmYgfHwgbmV3IEJ1ZmZlcihvZmZzZXQgKyAxNik7XG4gICAgZm9yIChpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd29yZCA9IHBhcnNlSW50KHNlY3Rpb25zW2ldLCAxNik7XG4gICAgICByZXN1bHRbb2Zmc2V0KytdID0gKHdvcmQgPj4gOCkgJiAweGZmO1xuICAgICAgcmVzdWx0W29mZnNldCsrXSA9IHdvcmQgJiAweGZmO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcmVzdWx0KSB7XG4gICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgaXAgYWRkcmVzczogJyArIGlwKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5pcC50b1N0cmluZyA9IGZ1bmN0aW9uKGJ1ZmYsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IH5+b2Zmc2V0O1xuICBsZW5ndGggPSBsZW5ndGggfHwgKGJ1ZmYubGVuZ3RoIC0gb2Zmc2V0KTtcblxuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChsZW5ndGggPT09IDQpIHtcbiAgICAvLyBJUHY0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goYnVmZltvZmZzZXQgKyBpXSk7XG4gICAgfVxuICAgIHJlc3VsdCA9IHJlc3VsdC5qb2luKCcuJyk7XG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSAxNikge1xuICAgIC8vIElQdjZcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICByZXN1bHQucHVzaChidWZmLnJlYWRVSW50MTZCRShvZmZzZXQgKyBpKS50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICByZXN1bHQgPSByZXN1bHQuam9pbignOicpO1xuICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC8oXnw6KTAoOjApKjowKDp8JCkvLCAnJDE6OiQzJyk7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoLzp7Myw0fS8sICc6OicpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBpcHY0UmVnZXggPSAvXihcXGR7MSwzfVxcLil7MywzfVxcZHsxLDN9JC87XG52YXIgaXB2NlJlZ2V4ID1cbiAgICAvXig6Oik/KCgoXFxkezEsM31cXC4pezN9KFxcZHsxLDN9KXsxfSk/KFswLTlhLWZdKXswLDR9OnswLDJ9KXsxLDh9KDo6KT8kL2k7XG5cbmlwLmlzVjRGb3JtYXQgPSBmdW5jdGlvbihpcCkge1xuICByZXR1cm4gaXB2NFJlZ2V4LnRlc3QoaXApO1xufTtcblxuaXAuaXNWNkZvcm1hdCA9IGZ1bmN0aW9uKGlwKSB7XG4gIHJldHVybiBpcHY2UmVnZXgudGVzdChpcCk7XG59O1xuZnVuY3Rpb24gX25vcm1hbGl6ZUZhbWlseShmYW1pbHkpIHtcbiAgcmV0dXJuIGZhbWlseSA/IGZhbWlseS50b0xvd2VyQ2FzZSgpIDogJ2lwdjQnO1xufVxuXG5pcC5mcm9tUHJlZml4TGVuID0gZnVuY3Rpb24ocHJlZml4bGVuLCBmYW1pbHkpIHtcbiAgaWYgKHByZWZpeGxlbiA+IDMyKSB7XG4gICAgZmFtaWx5ID0gJ2lwdjYnO1xuICB9IGVsc2Uge1xuICAgIGZhbWlseSA9IF9ub3JtYWxpemVGYW1pbHkoZmFtaWx5KTtcbiAgfVxuXG4gIHZhciBsZW4gPSA0O1xuICBpZiAoZmFtaWx5ID09PSAnaXB2NicpIHtcbiAgICBsZW4gPSAxNjtcbiAgfVxuICB2YXIgYnVmZiA9IG5ldyBCdWZmZXIobGVuKTtcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IGJ1ZmYubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgdmFyIGJpdHMgPSA4O1xuICAgIGlmIChwcmVmaXhsZW4gPCA4KSB7XG4gICAgICBiaXRzID0gcHJlZml4bGVuO1xuICAgIH1cbiAgICBwcmVmaXhsZW4gLT0gYml0cztcblxuICAgIGJ1ZmZbaV0gPSB+KDB4ZmYgPj4gYml0cykgJiAweGZmO1xuICB9XG5cbiAgcmV0dXJuIGlwLnRvU3RyaW5nKGJ1ZmYpO1xufTtcblxuaXAubWFzayA9IGZ1bmN0aW9uKGFkZHIsIG1hc2spIHtcbiAgYWRkciA9IGlwLnRvQnVmZmVyKGFkZHIpO1xuICBtYXNrID0gaXAudG9CdWZmZXIobWFzayk7XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBCdWZmZXIoTWF0aC5tYXgoYWRkci5sZW5ndGgsIG1hc2subGVuZ3RoKSk7XG5cbiAgdmFyIGkgPSAwO1xuICAvLyBTYW1lIHByb3RvY29sIC0gZG8gYml0d2lzZSBhbmRcbiAgaWYgKGFkZHIubGVuZ3RoID09PSBtYXNrLmxlbmd0aCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBhZGRyLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBhZGRyW2ldICYgbWFza1tpXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobWFzay5sZW5ndGggPT09IDQpIHtcbiAgICAvLyBJUHY2IGFkZHJlc3MgYW5kIElQdjQgbWFza1xuICAgIC8vIChNYXNrIGxvdyBiaXRzKVxuICAgIGZvciAoaSA9IDA7IGkgPCBtYXNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBhZGRyW2FkZHIubGVuZ3RoIC0gNCAgKyBpXSAmIG1hc2tbaV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElQdjYgbWFzayBhbmQgSVB2NCBhZGRyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoIC0gNjsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSAwO1xuICAgIH1cblxuICAgIC8vIDo6ZmZmZjppcHY0XG4gICAgcmVzdWx0WzEwXSA9IDB4ZmY7XG4gICAgcmVzdWx0WzExXSA9IDB4ZmY7XG4gICAgZm9yIChpID0gMDsgaSA8IGFkZHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpICsgMTJdID0gYWRkcltpXSAmIG1hc2tbaSArIDEyXTtcbiAgICB9XG4gICAgaSA9IGkgKyAxMjtcbiAgfVxuICBmb3IgKDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKylcbiAgICByZXN1bHRbaV0gPSAwO1xuXG4gIHJldHVybiBpcC50b1N0cmluZyhyZXN1bHQpO1xufTtcblxuaXAuY2lkciA9IGZ1bmN0aW9uKGNpZHJTdHJpbmcpIHtcbiAgdmFyIGNpZHJQYXJ0cyA9IGNpZHJTdHJpbmcuc3BsaXQoJy8nKTtcblxuICB2YXIgYWRkciA9IGNpZHJQYXJ0c1swXTtcbiAgaWYgKGNpZHJQYXJ0cy5sZW5ndGggIT09IDIpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIENJRFIgc3VibmV0OiAnICsgYWRkcik7XG5cbiAgdmFyIG1hc2sgPSBpcC5mcm9tUHJlZml4TGVuKHBhcnNlSW50KGNpZHJQYXJ0c1sxXSwgMTApKTtcblxuICByZXR1cm4gaXAubWFzayhhZGRyLCBtYXNrKTtcbn07XG5cbmlwLnN1Ym5ldCA9IGZ1bmN0aW9uKGFkZHIsIG1hc2spIHtcbiAgdmFyIG5ldHdvcmtBZGRyZXNzID0gaXAudG9Mb25nKGlwLm1hc2soYWRkciwgbWFzaykpO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgbWFzaydzIGxlbmd0aC5cbiAgdmFyIG1hc2tCdWZmZXIgPSBpcC50b0J1ZmZlcihtYXNrKTtcbiAgdmFyIG1hc2tMZW5ndGggPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWFza0J1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtYXNrQnVmZmVyW2ldID09PSAweGZmKSB7XG4gICAgICBtYXNrTGVuZ3RoICs9IDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvY3RldCA9IG1hc2tCdWZmZXJbaV0gJiAweGZmO1xuICAgICAgd2hpbGUgKG9jdGV0KSB7XG4gICAgICAgIG9jdGV0ID0gKG9jdGV0IDw8IDEpICYgMHhmZjtcbiAgICAgICAgbWFza0xlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBudW1iZXJPZkFkZHJlc3NlcyA9IE1hdGgucG93KDIsIDMyIC0gbWFza0xlbmd0aCk7XG5cbiAgcmV0dXJuIHtcbiAgICBuZXR3b3JrQWRkcmVzczogaXAuZnJvbUxvbmcobmV0d29ya0FkZHJlc3MpLFxuICAgIGZpcnN0QWRkcmVzczogbnVtYmVyT2ZBZGRyZXNzZXMgPD0gMiA/XG4gICAgICAgICAgICAgICAgICAgIGlwLmZyb21Mb25nKG5ldHdvcmtBZGRyZXNzKSA6XG4gICAgICAgICAgICAgICAgICAgIGlwLmZyb21Mb25nKG5ldHdvcmtBZGRyZXNzICsgMSksXG4gICAgbGFzdEFkZHJlc3M6IG51bWJlck9mQWRkcmVzc2VzIDw9IDIgP1xuICAgICAgICAgICAgICAgICAgICBpcC5mcm9tTG9uZyhuZXR3b3JrQWRkcmVzcyArIG51bWJlck9mQWRkcmVzc2VzIC0gMSkgOlxuICAgICAgICAgICAgICAgICAgICBpcC5mcm9tTG9uZyhuZXR3b3JrQWRkcmVzcyArIG51bWJlck9mQWRkcmVzc2VzIC0gMiksXG4gICAgYnJvYWRjYXN0QWRkcmVzczogaXAuZnJvbUxvbmcobmV0d29ya0FkZHJlc3MgKyBudW1iZXJPZkFkZHJlc3NlcyAtIDEpLFxuICAgIHN1Ym5ldE1hc2s6IG1hc2ssXG4gICAgc3VibmV0TWFza0xlbmd0aDogbWFza0xlbmd0aCxcbiAgICBudW1Ib3N0czogbnVtYmVyT2ZBZGRyZXNzZXMgPD0gMiA/XG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZBZGRyZXNzZXMgOiBudW1iZXJPZkFkZHJlc3NlcyAtIDIsXG4gICAgbGVuZ3RoOiBudW1iZXJPZkFkZHJlc3NlcyxcbiAgICBjb250YWluczogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIHJldHVybiBuZXR3b3JrQWRkcmVzcyA9PT0gaXAudG9Mb25nKGlwLm1hc2sob3RoZXIsIG1hc2spKTtcbiAgICB9XG4gIH07XG59O1xuXG5pcC5jaWRyU3VibmV0ID0gZnVuY3Rpb24oY2lkclN0cmluZykge1xuICB2YXIgY2lkclBhcnRzID0gY2lkclN0cmluZy5zcGxpdCgnLycpO1xuXG4gIHZhciBhZGRyID0gY2lkclBhcnRzWzBdO1xuICBpZiAoY2lkclBhcnRzLmxlbmd0aCAhPT0gMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgQ0lEUiBzdWJuZXQ6ICcgKyBhZGRyKTtcblxuICB2YXIgbWFzayA9IGlwLmZyb21QcmVmaXhMZW4ocGFyc2VJbnQoY2lkclBhcnRzWzFdLCAxMCkpO1xuXG4gIHJldHVybiBpcC5zdWJuZXQoYWRkciwgbWFzayk7XG59O1xuXG5pcC5ub3QgPSBmdW5jdGlvbihhZGRyKSB7XG4gIHZhciBidWZmID0gaXAudG9CdWZmZXIoYWRkcik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZi5sZW5ndGg7IGkrKykge1xuICAgIGJ1ZmZbaV0gPSAweGZmIF4gYnVmZltpXTtcbiAgfVxuICByZXR1cm4gaXAudG9TdHJpbmcoYnVmZik7XG59O1xuXG5pcC5vciA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgYSA9IGlwLnRvQnVmZmVyKGEpO1xuICBiID0gaXAudG9CdWZmZXIoYik7XG5cbiAgLy8gc2FtZSBwcm90b2NvbFxuICBpZiAoYS5sZW5ndGggPT09IGIubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICBhW2ldIHw9IGJbaV07XG4gICAgfVxuICAgIHJldHVybiBpcC50b1N0cmluZyhhKTtcblxuICAvLyBtaXhlZCBwcm90b2NvbHNcbiAgfSBlbHNlIHtcbiAgICB2YXIgYnVmZiA9IGE7XG4gICAgdmFyIG90aGVyID0gYjtcbiAgICBpZiAoYi5sZW5ndGggPiBhLmxlbmd0aCkge1xuICAgICAgYnVmZiA9IGI7XG4gICAgICBvdGhlciA9IGE7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldCA9IGJ1ZmYubGVuZ3RoIC0gb3RoZXIubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBidWZmLmxlbmd0aDsgKytpKSB7XG4gICAgICBidWZmW2ldIHw9IG90aGVyW2kgLSBvZmZzZXRdO1xuICAgIH1cblxuICAgIHJldHVybiBpcC50b1N0cmluZyhidWZmKTtcbiAgfVxufTtcblxuaXAuaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgYSA9IGlwLnRvQnVmZmVyKGEpO1xuICBiID0gaXAudG9CdWZmZXIoYik7XG5cbiAgLy8gU2FtZSBwcm90b2NvbFxuICBpZiAoYS5sZW5ndGggPT09IGIubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFN3YXBcbiAgaWYgKGIubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIHQgPSBiO1xuICAgIGIgPSBhO1xuICAgIGEgPSB0O1xuICB9XG5cbiAgLy8gYSAtIElQdjQsIGIgLSBJUHY2XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIGlmIChiW2ldICE9PSAwKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgd29yZCA9IGIucmVhZFVJbnQxNkJFKDEwKTtcbiAgaWYgKHdvcmQgIT09IDAgJiYgd29yZCAhPT0gMHhmZmZmKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpICsgMTJdKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmlwLmlzUHJpdmF0ZSA9IGZ1bmN0aW9uKGFkZHIpIHtcbiAgcmV0dXJuIC9eKDo6Zns0fTopPzEwXFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pJC9pXG4gICAgICAudGVzdChhZGRyKSB8fFxuICAgIC9eKDo6Zns0fTopPzE5MlxcLjE2OFxcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KSQvaS50ZXN0KGFkZHIpIHx8XG4gICAgL14oOjpmezR9Oik/MTcyXFwuKDFbNi05XXwyXFxkfDMwfDMxKVxcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KSQvaVxuICAgICAgLnRlc3QoYWRkcikgfHxcbiAgICAvXig6OmZ7NH06KT8xMjdcXC4oWzAtOV17MSwzfSlcXC4oWzAtOV17MSwzfSlcXC4oWzAtOV17MSwzfSkkL2kudGVzdChhZGRyKSB8fFxuICAgIC9eKDo6Zns0fTopPzE2OVxcLjI1NFxcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KSQvaS50ZXN0KGFkZHIpIHx8XG4gICAgL15mW2NkXVswLTlhLWZdezJ9Oi9pLnRlc3QoYWRkcikgfHxcbiAgICAvXmZlODA6L2kudGVzdChhZGRyKSB8fFxuICAgIC9eOjoxJC8udGVzdChhZGRyKSB8fFxuICAgIC9eOjokLy50ZXN0KGFkZHIpO1xufTtcblxuaXAuaXNQdWJsaWMgPSBmdW5jdGlvbihhZGRyKSB7XG4gIHJldHVybiAhaXAuaXNQcml2YXRlKGFkZHIpO1xufTtcblxuaXAuaXNMb29wYmFjayA9IGZ1bmN0aW9uKGFkZHIpIHtcbiAgcmV0dXJuIC9eKDo6Zns0fTopPzEyN1xcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KS9cbiAgICAgIC50ZXN0KGFkZHIpIHx8XG4gICAgL15mZTgwOjoxJC8udGVzdChhZGRyKSB8fFxuICAgIC9eOjoxJC8udGVzdChhZGRyKSB8fFxuICAgIC9eOjokLy50ZXN0KGFkZHIpO1xufTtcblxuaXAubG9vcGJhY2sgPSBmdW5jdGlvbihmYW1pbHkpIHtcbiAgLy9cbiAgLy8gRGVmYXVsdCB0byBgaXB2NGBcbiAgLy9cbiAgZmFtaWx5ID0gX25vcm1hbGl6ZUZhbWlseShmYW1pbHkpO1xuXG4gIGlmIChmYW1pbHkgIT09ICdpcHY0JyAmJiBmYW1pbHkgIT09ICdpcHY2Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignZmFtaWx5IG11c3QgYmUgaXB2NCBvciBpcHY2Jyk7XG4gIH1cblxuICByZXR1cm4gZmFtaWx5ID09PSAnaXB2NCcgPyAnMTI3LjAuMC4xJyA6ICdmZTgwOjoxJztcbn07XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gYWRkcmVzcyAobmFtZSwgZmFtaWx5KVxuLy8gIyMjIyBAbmFtZSB7c3RyaW5nfCdwdWJsaWMnfCdwcml2YXRlJ30gKipPcHRpb25hbCoqIE5hbWUgb3Igc2VjdXJpdHlcbi8vICAgICAgb2YgdGhlIG5ldHdvcmsgaW50ZXJmYWNlLlxuLy8gIyMjIyBAZmFtaWx5IHtpcHY0fGlwdjZ9ICoqT3B0aW9uYWwqKiBJUCBmYW1pbHkgb2YgdGhlIGFkZHJlc3MgKGRlZmF1bHRzXG4vLyAgICAgIHRvIGlwdjQpLlxuLy9cbi8vIFJldHVybnMgdGhlIGFkZHJlc3MgZm9yIHRoZSBuZXR3b3JrIGludGVyZmFjZSBvbiB0aGUgY3VycmVudCBzeXN0ZW0gd2l0aFxuLy8gdGhlIHNwZWNpZmllZCBgbmFtZWA6XG4vLyAgICogU3RyaW5nOiBGaXJzdCBgZmFtaWx5YCBhZGRyZXNzIG9mIHRoZSBpbnRlcmZhY2UuXG4vLyAgICAgICAgICAgICBJZiBub3QgZm91bmQgc2VlIGB1bmRlZmluZWRgLlxuLy8gICAqICdwdWJsaWMnOiB0aGUgZmlyc3QgcHVibGljIGlwIGFkZHJlc3Mgb2YgZmFtaWx5LlxuLy8gICAqICdwcml2YXRlJzogdGhlIGZpcnN0IHByaXZhdGUgaXAgYWRkcmVzcyBvZiBmYW1pbHkuXG4vLyAgICogdW5kZWZpbmVkOiBGaXJzdCBhZGRyZXNzIHdpdGggYGlwdjRgIG9yIGxvb3BiYWNrIGFkZHJlc3MgYDEyNy4wLjAuMWAuXG4vL1xuaXAuYWRkcmVzcyA9IGZ1bmN0aW9uKG5hbWUsIGZhbWlseSkge1xuICB2YXIgaW50ZXJmYWNlcyA9IG9zLm5ldHdvcmtJbnRlcmZhY2VzKCk7XG4gIHZhciBhbGw7XG5cbiAgLy9cbiAgLy8gRGVmYXVsdCB0byBgaXB2NGBcbiAgLy9cbiAgZmFtaWx5ID0gX25vcm1hbGl6ZUZhbWlseShmYW1pbHkpO1xuXG4gIC8vXG4gIC8vIElmIGEgc3BlY2lmaWMgbmV0d29yayBpbnRlcmZhY2UgaGFzIGJlZW4gbmFtZWQsXG4gIC8vIHJldHVybiB0aGUgYWRkcmVzcy5cbiAgLy9cbiAgaWYgKG5hbWUgJiYgbmFtZSAhPT0gJ3ByaXZhdGUnICYmIG5hbWUgIT09ICdwdWJsaWMnKSB7XG4gICAgdmFyIHJlcyA9IGludGVyZmFjZXNbbmFtZV0uZmlsdGVyKGZ1bmN0aW9uKGRldGFpbHMpIHtcbiAgICAgIHZhciBpdGVtRmFtaWx5ID0gZGV0YWlscy5mYW1pbHkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiBpdGVtRmFtaWx5ID09PSBmYW1pbHk7XG4gICAgfSk7XG4gICAgaWYgKHJlcy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXNbMF0uYWRkcmVzcztcbiAgfVxuXG4gIHZhciBhbGwgPSBPYmplY3Qua2V5cyhpbnRlcmZhY2VzKS5tYXAoZnVuY3Rpb24gKG5pYykge1xuICAgIC8vXG4gICAgLy8gTm90ZTogbmFtZSB3aWxsIG9ubHkgYmUgYHB1YmxpY2Agb3IgYHByaXZhdGVgXG4gICAgLy8gd2hlbiB0aGlzIGlzIGNhbGxlZC5cbiAgICAvL1xuICAgIHZhciBhZGRyZXNzZXMgPSBpbnRlcmZhY2VzW25pY10uZmlsdGVyKGZ1bmN0aW9uIChkZXRhaWxzKSB7XG4gICAgICBkZXRhaWxzLmZhbWlseSA9IGRldGFpbHMuZmFtaWx5LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoZGV0YWlscy5mYW1pbHkgIT09IGZhbWlseSB8fCBpcC5pc0xvb3BiYWNrKGRldGFpbHMuYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghbmFtZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hbWUgPT09ICdwdWJsaWMnID8gaXAuaXNQcml2YXRlKGRldGFpbHMuYWRkcmVzcykgOlxuICAgICAgICAgIGlwLmlzUHVibGljKGRldGFpbHMuYWRkcmVzcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYWRkcmVzc2VzLmxlbmd0aCA/IGFkZHJlc3Nlc1swXS5hZGRyZXNzIDogdW5kZWZpbmVkO1xuICB9KS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgcmV0dXJuICFhbGwubGVuZ3RoID8gaXAubG9vcGJhY2soZmFtaWx5KSA6IGFsbFswXTtcbn07XG5cbmlwLnRvTG9uZyA9IGZ1bmN0aW9uKGlwKSB7XG4gIHZhciBpcGwgPSAwO1xuICBpcC5zcGxpdCgnLicpLmZvckVhY2goZnVuY3Rpb24ob2N0ZXQpIHtcbiAgICBpcGwgPDw9IDg7XG4gICAgaXBsICs9IHBhcnNlSW50KG9jdGV0KTtcbiAgfSk7XG4gIHJldHVybihpcGwgPj4+IDApO1xufTtcblxuaXAuZnJvbUxvbmcgPSBmdW5jdGlvbihpcGwpIHtcbiAgcmV0dXJuICgoaXBsID4+PiAyNCkgKyAnLicgK1xuICAgICAgKGlwbCA+PiAxNiAmIDI1NSkgKyAnLicgK1xuICAgICAgKGlwbCA+PiA4ICYgMjU1KSArICcuJyArXG4gICAgICAoaXBsICYgMjU1KSApO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/ip/lib/ip.js\n");

/***/ }),

/***/ "../../node_modules/is_js/is.js":
/*!********************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/is_js/is.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * is.js 0.8.0\n * Author: Aras Atasaygin\n */\n\n// AMD with global, Node, or global\n;(function(root, factory) {    // eslint-disable-line no-extra-semi\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            // Also create a global in case some scripts\n            // that are loaded still are looking for\n            // a global even when an AMD loader is in use.\n            return (root.is = factory());\n        }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function() {\n\n    // Baseline\n    /* -------------------------------------------------------------------------- */\n\n    // define 'is' object and current version\n    var is = {};\n    is.VERSION = '0.8.0';\n\n    // define interfaces\n    is.not = {};\n    is.all = {};\n    is.any = {};\n\n    // cache some methods to call later on\n    var toString = Object.prototype.toString;\n    var slice = Array.prototype.slice;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    // helper function which reverses the sense of predicate result\n    function not(func) {\n        return function() {\n            return !func.apply(null, slice.call(arguments));\n        };\n    }\n\n    // helper function which call predicate function per parameter and return true if all pass\n    function all(func) {\n        return function() {\n            var params = getParams(arguments);\n            var length = params.length;\n            for (var i = 0; i < length; i++) {\n                if (!func.call(null, params[i])) {\n                    return false;\n                }\n            }\n            return true;\n        };\n    }\n\n    // helper function which call predicate function per parameter and return true if any pass\n    function any(func) {\n        return function() {\n            var params = getParams(arguments);\n            var length = params.length;\n            for (var i = 0; i < length; i++) {\n                if (func.call(null, params[i])) {\n                    return true;\n                }\n            }\n            return false;\n        };\n    }\n\n    // build a 'comparator' object for various comparison checks\n    var comparator = {\n        '<': function(a, b) { return a < b; },\n        '<=': function(a, b) { return a <= b; },\n        '>': function(a, b) { return a > b; },\n        '>=': function(a, b) { return a >= b; }\n    }\n\n    // helper function which compares a version to a range\n    function compareVersion(version, range) {\n        var string = (range + '');\n        var n = +(string.match(/\\d+/) || NaN);\n        var op = string.match(/^[<>]=?|/)[0];\n        return comparator[op] ? comparator[op](version, n) : (version == n || n !== n);\n    }\n\n    // helper function which extracts params from arguments\n    function getParams(args) {\n        var params = slice.call(args);\n        var length = params.length;\n        if (length === 1 && is.array(params[0])) {    // support array\n            params = params[0];\n        }\n        return params;\n    }\n\n    // Type checks\n    /* -------------------------------------------------------------------------- */\n\n    // is a given value Arguments?\n    is.arguments = function(value) {    // fallback check is for IE\n        return toString.call(value) === '[object Arguments]' ||\n            (value != null && typeof value === 'object' && 'callee' in value);\n    };\n\n    // is a given value Array?\n    is.array = Array.isArray || function(value) {    // check native isArray first\n        return toString.call(value) === '[object Array]';\n    };\n\n    // is a given value Boolean?\n    is.boolean = function(value) {\n        return value === true || value === false || toString.call(value) === '[object Boolean]';\n    };\n\n    // is a given value Char?\n    is.char = function(value) {\n        return is.string(value) && value.length === 1;\n    };\n\n    // is a given value Date Object?\n    is.date = function(value) {\n        return toString.call(value) === '[object Date]';\n    };\n\n    // is a given object a DOM node?\n    is.domNode = function(object) {\n        return is.object(object) && object.nodeType > 0;\n    };\n\n    // is a given value Error object?\n    is.error = function(value) {\n        return toString.call(value) === '[object Error]';\n    };\n\n    // is a given value function?\n    is['function'] = function(value) {    // fallback check is for IE\n        return toString.call(value) === '[object Function]' || typeof value === 'function';\n    };\n\n    // is given value a pure JSON object?\n    is.json = function(value) {\n        return toString.call(value) === '[object Object]';\n    };\n\n    // is a given value NaN?\n    is.nan = function(value) {    // NaN is number :) Also it is the only value which does not equal itself\n        return value !== value;\n    };\n\n    // is a given value null?\n    is['null'] = function(value) {\n        return value === null;\n    };\n\n    // is a given value number?\n    is.number = function(value) {\n        return is.not.nan(value) && toString.call(value) === '[object Number]';\n    };\n\n    // is a given value object?\n    is.object = function(value) {\n        return Object(value) === value;\n    };\n\n    // is a given value RegExp?\n    is.regexp = function(value) {\n        return toString.call(value) === '[object RegExp]';\n    };\n\n    // are given values same type?\n    // prevent NaN, Number same type check\n    is.sameType = function(value, other) {\n        var tag = toString.call(value);\n        if (tag !== toString.call(other)) {\n            return false;\n        }\n        if (tag === '[object Number]') {\n            return !is.any.nan(value, other) || is.all.nan(value, other);\n        }\n        return true;\n    };\n    // sameType method does not support 'all' and 'any' interfaces\n    is.sameType.api = ['not'];\n\n    // is a given value String?\n    is.string = function(value) {\n        return toString.call(value) === '[object String]';\n    };\n\n    // is a given value undefined?\n    is.undefined = function(value) {\n        return value === void 0;\n    };\n\n    // is a given value window?\n    // setInterval method is only available for window object\n    is.windowObject = function(value) {\n        return value != null && typeof value === 'object' && 'setInterval' in value;\n    };\n\n    // Presence checks\n    /* -------------------------------------------------------------------------- */\n\n    //is a given value empty? Objects, arrays, strings\n    is.empty = function(value) {\n        if (is.object(value)) {\n            var length = Object.getOwnPropertyNames(value).length;\n            if (length === 0 || (length === 1 && is.array(value)) ||\n                    (length === 2 && is.arguments(value))) {\n                return true;\n            }\n            return false;\n        }\n        return value === '';\n    };\n\n    // is a given value existy?\n    is.existy = function(value) {\n        return value != null;\n    };\n\n    // is a given value falsy?\n    is.falsy = function(value) {\n        return !value;\n    };\n\n    // is a given value truthy?\n    is.truthy = not(is.falsy);\n\n    // Arithmetic checks\n    /* -------------------------------------------------------------------------- */\n\n    // is a given number above minimum parameter?\n    is.above = function(n, min) {\n        return is.all.number(n, min) && n > min;\n    };\n    // above method does not support 'all' and 'any' interfaces\n    is.above.api = ['not'];\n\n    // is a given number decimal?\n    is.decimal = function(n) {\n        return is.number(n) && n % 1 !== 0;\n    };\n\n    // are given values equal? supports numbers, strings, regexes, booleans\n    // TODO: Add object and array support\n    is.equal = function(value, other) {\n        // check 0 and -0 equity with Infinity and -Infinity\n        if (is.all.number(value, other)) {\n            return value === other && 1 / value === 1 / other;\n        }\n        // check regexes as strings too\n        if (is.all.string(value, other) || is.all.regexp(value, other)) {\n            return '' + value === '' + other;\n        }\n        if (is.all.boolean(value, other)) {\n            return value === other;\n        }\n        return false;\n    };\n    // equal method does not support 'all' and 'any' interfaces\n    is.equal.api = ['not'];\n\n    // is a given number even?\n    is.even = function(n) {\n        return is.number(n) && n % 2 === 0;\n    };\n\n    // is a given number finite?\n    is.finite = isFinite || function(n) {\n        return is.not.infinite(n) && is.not.nan(n);\n    };\n\n    // is a given number infinite?\n    is.infinite = function(n) {\n        return n === Infinity || n === -Infinity;\n    };\n\n    // is a given number integer?\n    is.integer = function(n) {\n        return is.number(n) && n % 1 === 0;\n    };\n\n    // is a given number negative?\n    is.negative = function(n) {\n        return is.number(n) && n < 0;\n    };\n\n    // is a given number odd?\n    is.odd = function(n) {\n        return is.number(n) && n % 2 === 1;\n    };\n\n    // is a given number positive?\n    is.positive = function(n) {\n        return is.number(n) && n > 0;\n    };\n\n    // is a given number above maximum parameter?\n    is.under = function(n, max) {\n        return is.all.number(n, max) && n < max;\n    };\n    // least method does not support 'all' and 'any' interfaces\n    is.under.api = ['not'];\n\n    // is a given number within minimum and maximum parameters?\n    is.within = function(n, min, max) {\n        return is.all.number(n, min, max) && n > min && n < max;\n    };\n    // within method does not support 'all' and 'any' interfaces\n    is.within.api = ['not'];\n\n    // Regexp checks\n    /* -------------------------------------------------------------------------- */\n    // Steven Levithan, Jan Goyvaerts: Regular Expressions Cookbook\n    // Scott Gonzalez: Email address validation\n\n    // dateString match m/d/yy and mm/dd/yyyy, allowing any combination of one or two digits for the day and month, and two or four digits for the year\n    // eppPhone match extensible provisioning protocol format\n    // nanpPhone match north american number plan format\n    // time match hours, minutes, and seconds, 24-hour clock\n    var regexes = {\n        affirmative: /^(?:1|t(?:rue)?|y(?:es)?|ok(?:ay)?)$/,\n        alphaNumeric: /^[A-Za-z0-9]+$/,\n        caPostalCode: /^(?!.*[DFIOQU])[A-VXY][0-9][A-Z]\\s?[0-9][A-Z][0-9]$/,\n        creditCard: /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/,\n        dateString: /^(1[0-2]|0?[1-9])([\\/-])(3[01]|[12][0-9]|0?[1-9])(?:\\2)(?:[0-9]{2})?[0-9]{2}$/,\n        email: /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i, // eslint-disable-line no-control-regex\n        eppPhone: /^\\+[0-9]{1,3}\\.[0-9]{4,14}(?:x.+)?$/,\n        hexadecimal: /^(?:0x)?[0-9a-fA-F]+$/,\n        hexColor: /^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/,\n        ipv4: /^(?:(?:\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.){3}(?:\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])$/,\n        ipv6: /^((?=.*::)(?!.*::.+::)(::)?([\\dA-F]{1,4}:(:|\\b)|){5}|([\\dA-F]{1,4}:){6})((([\\dA-F]{1,4}((?!\\3)::|:\\b|$))|(?!\\2\\3)){2}|(((2[0-4]|1\\d|[1-9])?\\d|25[0-5])\\.?\\b){4})$/i,\n        nanpPhone: /^\\(?([0-9]{3})\\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$/,\n        socialSecurityNumber: /^(?!000|666)[0-8][0-9]{2}-?(?!00)[0-9]{2}-?(?!0000)[0-9]{4}$/,\n        timeString: /^(2[0-3]|[01]?[0-9]):([0-5]?[0-9]):([0-5]?[0-9])$/,\n        ukPostCode: /^[A-Z]{1,2}[0-9RCHNQ][0-9A-Z]?\\s?[0-9][ABD-HJLNP-UW-Z]{2}$|^[A-Z]{2}-?[0-9]{4}$/,\n        url: /^(?:(?:https?|ftp):\\/\\/)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:\\/\\S*)?$/i,\n        usZipCode: /^[0-9]{5}(?:-[0-9]{4})?$/\n    };\n\n    function regexpCheck(regexp, regexes) {\n        is[regexp] = function(value) {\n            return regexes[regexp].test(value);\n        };\n    }\n\n    // create regexp checks methods from 'regexes' object\n    for (var regexp in regexes) {\n        if (regexes.hasOwnProperty(regexp)) {\n            regexpCheck(regexp, regexes);\n        }\n    }\n\n    // simplify IP checks by calling the regex helpers for IPv4 and IPv6\n    is.ip = function(value) {\n        return is.ipv4(value) || is.ipv6(value);\n    };\n\n    // String checks\n    /* -------------------------------------------------------------------------- */\n\n    // is a given string or sentence capitalized?\n    is.capitalized = function(string) {\n        if (is.not.string(string)) {\n            return false;\n        }\n        var words = string.split(' ');\n        for (var i = 0; i < words.length; i++) {\n            var word = words[i];\n            if (word.length) {\n                var chr = word.charAt(0);\n                if (chr !== chr.toUpperCase()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n\n    // is string end with a given target parameter?\n    is.endWith = function(string, target) {\n        if (is.not.string(string)) {\n            return false;\n        }\n        target += '';\n        var position = string.length - target.length;\n        return position >= 0 && string.indexOf(target, position) === position;\n    };\n    // endWith method does not support 'all' and 'any' interfaces\n    is.endWith.api = ['not'];\n\n    // is a given string include parameter target?\n    is.include = function(string, target) {\n        return string.indexOf(target) > -1;\n    };\n    // include method does not support 'all' and 'any' interfaces\n    is.include.api = ['not'];\n\n    // is a given string all lowercase?\n    is.lowerCase = function(string) {\n        return is.string(string) && string === string.toLowerCase();\n    };\n\n    // is a given string palindrome?\n    is.palindrome = function(string) {\n        if (is.not.string(string)) {\n            return false;\n        }\n        string = string.replace(/[^a-zA-Z0-9]+/g, '').toLowerCase();\n        var length = string.length - 1;\n        for (var i = 0, half = Math.floor(length / 2); i <= half; i++) {\n            if (string.charAt(i) !== string.charAt(length - i)) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    // is a given value space?\n    // horizantal tab: 9, line feed: 10, vertical tab: 11, form feed: 12, carriage return: 13, space: 32\n    is.space = function(value) {\n        if (is.not.char(value)) {\n            return false;\n        }\n        var charCode = value.charCodeAt(0);\n        return (charCode > 8 && charCode < 14) || charCode === 32;\n    };\n\n    // is string start with a given target parameter?\n    is.startWith = function(string, target) {\n        return is.string(string) && string.indexOf(target) === 0;\n    };\n    // startWith method does not support 'all' and 'any' interfaces\n    is.startWith.api = ['not'];\n\n    // is a given string all uppercase?\n    is.upperCase = function(string) {\n        return is.string(string) && string === string.toUpperCase();\n    };\n\n    // Time checks\n    /* -------------------------------------------------------------------------- */\n\n    var days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\n    var months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];\n\n    // is a given dates day equal given day parameter?\n    is.day = function(date, day) {\n        return is.date(date) && day.toLowerCase() === days[date.getDay()];\n    };\n    // day method does not support 'all' and 'any' interfaces\n    is.day.api = ['not'];\n\n    // is a given date in daylight saving time?\n    is.dayLightSavingTime = function(date) {\n        var january = new Date(date.getFullYear(), 0, 1);\n        var july = new Date(date.getFullYear(), 6, 1);\n        var stdTimezoneOffset = Math.max(january.getTimezoneOffset(), july.getTimezoneOffset());\n        return date.getTimezoneOffset() < stdTimezoneOffset;\n    };\n\n    // is a given date future?\n    is.future = function(date) {\n        var now = new Date();\n        return is.date(date) && date.getTime() > now.getTime();\n    };\n\n    // is date within given range?\n    is.inDateRange = function(date, start, end) {\n        if (is.not.date(date) || is.not.date(start) || is.not.date(end)) {\n            return false;\n        }\n        var stamp = date.getTime();\n        return stamp > start.getTime() && stamp < end.getTime();\n    };\n    // inDateRange method does not support 'all' and 'any' interfaces\n    is.inDateRange.api = ['not'];\n\n    // is a given date in last month range?\n    is.inLastMonth = function(date) {\n        return is.inDateRange(date, new Date(new Date().setMonth(new Date().getMonth() - 1)), new Date());\n    };\n\n    // is a given date in last week range?\n    is.inLastWeek = function(date) {\n        return is.inDateRange(date, new Date(new Date().setDate(new Date().getDate() - 7)), new Date());\n    };\n\n    // is a given date in last year range?\n    is.inLastYear = function(date) {\n        return is.inDateRange(date, new Date(new Date().setFullYear(new Date().getFullYear() - 1)), new Date());\n    };\n\n    // is a given date in next month range?\n    is.inNextMonth = function(date) {\n        return is.inDateRange(date, new Date(), new Date(new Date().setMonth(new Date().getMonth() + 1)));\n    };\n\n    // is a given date in next week range?\n    is.inNextWeek = function(date) {\n        return is.inDateRange(date, new Date(), new Date(new Date().setDate(new Date().getDate() + 7)));\n    };\n\n    // is a given date in next year range?\n    is.inNextYear = function(date) {\n        return is.inDateRange(date, new Date(), new Date(new Date().setFullYear(new Date().getFullYear() + 1)));\n    };\n\n    // is the given year a leap year?\n    is.leapYear = function(year) {\n        return is.number(year) && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);\n    };\n\n    // is a given dates month equal given month parameter?\n    is.month = function(date, month) {\n        return is.date(date) && month.toLowerCase() === months[date.getMonth()];\n    };\n    // month method does not support 'all' and 'any' interfaces\n    is.month.api = ['not'];\n\n    // is a given date past?\n    is.past = function(date) {\n        var now = new Date();\n        return is.date(date) && date.getTime() < now.getTime();\n    };\n\n    // is a given date in the parameter quarter?\n    is.quarterOfYear = function(date, quarter) {\n        return is.date(date) && is.number(quarter) && quarter === Math.floor((date.getMonth() + 3) / 3);\n    };\n    // quarterOfYear method does not support 'all' and 'any' interfaces\n    is.quarterOfYear.api = ['not'];\n\n    // is a given date indicate today?\n    is.today = function(date) {\n        var now = new Date();\n        var todayString = now.toDateString();\n        return is.date(date) && date.toDateString() === todayString;\n    };\n\n    // is a given date indicate tomorrow?\n    is.tomorrow = function(date) {\n        var now = new Date();\n        var tomorrowString = new Date(now.setDate(now.getDate() + 1)).toDateString();\n        return is.date(date) && date.toDateString() === tomorrowString;\n    };\n\n    // is a given date weekend?\n    // 6: Saturday, 0: Sunday\n    is.weekend = function(date) {\n        return is.date(date) && (date.getDay() === 6 || date.getDay() === 0);\n    };\n\n    // is a given date weekday?\n    is.weekday = not(is.weekend);\n\n    // is a given dates year equal given year parameter?\n    is.year = function(date, year) {\n        return is.date(date) && is.number(year) && year === date.getFullYear();\n    };\n    // year method does not support 'all' and 'any' interfaces\n    is.year.api = ['not'];\n\n    // is a given date indicate yesterday?\n    is.yesterday = function(date) {\n        var now = new Date();\n        var yesterdayString = new Date(now.setDate(now.getDate() - 1)).toDateString();\n        return is.date(date) && date.toDateString() === yesterdayString;\n    };\n\n    // Environment checks\n    /* -------------------------------------------------------------------------- */\n\n    var freeGlobal = is.windowObject(typeof global == 'object' && global) && global;\n    var freeSelf = is.windowObject(typeof self == 'object' && self) && self;\n    var thisGlobal = is.windowObject(typeof this == 'object' && this) && this;\n    var root = freeGlobal || freeSelf || thisGlobal || Function('return this')();\n\n    var document = freeSelf && freeSelf.document;\n    var previousIs = root.is;\n\n    // store navigator properties to use later\n    var navigator = freeSelf && freeSelf.navigator;\n    var appVersion = (navigator && navigator.appVersion || '').toLowerCase();\n    var userAgent = (navigator && navigator.userAgent || '').toLowerCase();\n    var vendor = (navigator && navigator.vendor || '').toLowerCase();\n\n    // is current device android?\n    is.android = function() {\n        return /android/.test(userAgent);\n    };\n    // android method does not support 'all' and 'any' interfaces\n    is.android.api = ['not'];\n\n    // is current device android phone?\n    is.androidPhone = function() {\n        return /android/.test(userAgent) && /mobile/.test(userAgent);\n    };\n    // androidPhone method does not support 'all' and 'any' interfaces\n    is.androidPhone.api = ['not'];\n\n    // is current device android tablet?\n    is.androidTablet = function() {\n        return /android/.test(userAgent) && !/mobile/.test(userAgent);\n    };\n    // androidTablet method does not support 'all' and 'any' interfaces\n    is.androidTablet.api = ['not'];\n\n    // is current device blackberry?\n    is.blackberry = function() {\n        return /blackberry/.test(userAgent) || /bb10/.test(userAgent);\n    };\n    // blackberry method does not support 'all' and 'any' interfaces\n    is.blackberry.api = ['not'];\n\n    // is current browser chrome?\n    // parameter is optional\n    is.chrome = function(range) {\n        var match = /google inc/.test(vendor) ? userAgent.match(/(?:chrome|crios)\\/(\\d+)/) : null;\n        return match !== null && compareVersion(match[1], range);\n    };\n    // chrome method does not support 'all' and 'any' interfaces\n    is.chrome.api = ['not'];\n\n    // is current device desktop?\n    is.desktop = function() {\n        return is.not.mobile() && is.not.tablet();\n    };\n    // desktop method does not support 'all' and 'any' interfaces\n    is.desktop.api = ['not'];\n\n    // is current browser edge?\n    // parameter is optional\n    is.edge = function(range) {\n        var match = userAgent.match(/edge\\/(\\d+)/);\n        return match !== null && compareVersion(match[1], range);\n    };\n    // edge method does not support 'all' and 'any' interfaces\n    is.edge.api = ['not'];\n\n    // is current browser firefox?\n    // parameter is optional\n    is.firefox = function(range) {\n        var match = userAgent.match(/(?:firefox|fxios)\\/(\\d+)/);\n        return match !== null && compareVersion(match[1], range);\n    };\n    // firefox method does not support 'all' and 'any' interfaces\n    is.firefox.api = ['not'];\n\n    // is current browser internet explorer?\n    // parameter is optional\n    is.ie = function(range) {\n        var match = userAgent.match(/(?:msie |trident.+?; rv:)(\\d+)/);\n        return match !== null && compareVersion(match[1], range);\n    };\n    // ie method does not support 'all' and 'any' interfaces\n    is.ie.api = ['not'];\n\n    // is current device ios?\n    is.ios = function() {\n        return is.iphone() || is.ipad() || is.ipod();\n    };\n    // ios method does not support 'all' and 'any' interfaces\n    is.ios.api = ['not'];\n\n    // is current device ipad?\n    // parameter is optional\n    is.ipad = function(range) {\n        var match = userAgent.match(/ipad.+?os (\\d+)/);\n        return match !== null && compareVersion(match[1], range);\n    };\n    // ipad method does not support 'all' and 'any' interfaces\n    is.ipad.api = ['not'];\n\n    // is current device iphone?\n    // parameter is optional\n    is.iphone = function(range) {\n        // original iPhone doesn't have the os portion of the UA\n        var match = userAgent.match(/iphone(?:.+?os (\\d+))?/);\n        return match !== null && compareVersion(match[1] || 1, range);\n    };\n    // iphone method does not support 'all' and 'any' interfaces\n    is.iphone.api = ['not'];\n\n    // is current device ipod?\n    // parameter is optional\n    is.ipod = function(range) {\n        var match = userAgent.match(/ipod.+?os (\\d+)/);\n        return match !== null && compareVersion(match[1], range);\n    };\n    // ipod method does not support 'all' and 'any' interfaces\n    is.ipod.api = ['not'];\n\n    // is current operating system linux?\n    is.linux = function() {\n        return /linux/.test(appVersion);\n    };\n    // linux method does not support 'all' and 'any' interfaces\n    is.linux.api = ['not'];\n\n    // is current operating system mac?\n    is.mac = function() {\n        return /mac/.test(appVersion);\n    };\n    // mac method does not support 'all' and 'any' interfaces\n    is.mac.api = ['not'];\n\n    // is current device mobile?\n    is.mobile = function() {\n        return is.iphone() || is.ipod() || is.androidPhone() || is.blackberry() || is.windowsPhone();\n    };\n    // mobile method does not support 'all' and 'any' interfaces\n    is.mobile.api = ['not'];\n\n    // is current state offline?\n    is.offline = not(is.online);\n    // offline method does not support 'all' and 'any' interfaces\n    is.offline.api = ['not'];\n\n    // is current state online?\n    is.online = function() {\n        return !navigator || navigator.onLine === true;\n    };\n    // online method does not support 'all' and 'any' interfaces\n    is.online.api = ['not'];\n\n    // is current browser opera?\n    // parameter is optional\n    is.opera = function(range) {\n        var match = userAgent.match(/(?:^opera.+?version|opr)\\/(\\d+)/);\n        return match !== null && compareVersion(match[1], range);\n    };\n    // opera method does not support 'all' and 'any' interfaces\n    is.opera.api = ['not'];\n\n    // is current browser phantomjs?\n    // parameter is optional\n    is.phantom = function(range) {\n        var match = userAgent.match(/phantomjs\\/(\\d+)/);\n        return match !== null && compareVersion(match[1], range);\n    };\n    // phantom method does not support 'all' and 'any' interfaces\n    is.phantom.api = ['not'];\n\n    // is current browser safari?\n    // parameter is optional\n    is.safari = function(range) {\n        var match = userAgent.match(/version\\/(\\d+).+?safari/);\n        return match !== null && compareVersion(match[1], range);\n    };\n    // safari method does not support 'all' and 'any' interfaces\n    is.safari.api = ['not'];\n\n    // is current device tablet?\n    is.tablet = function() {\n        return is.ipad() || is.androidTablet() || is.windowsTablet();\n    };\n    // tablet method does not support 'all' and 'any' interfaces\n    is.tablet.api = ['not'];\n\n    // is current device supports touch?\n    is.touchDevice = function() {\n        return !!document && ('ontouchstart' in freeSelf ||\n            ('DocumentTouch' in freeSelf && document instanceof DocumentTouch));\n    };\n    // touchDevice method does not support 'all' and 'any' interfaces\n    is.touchDevice.api = ['not'];\n\n    // is current operating system windows?\n    is.windows = function() {\n        return /win/.test(appVersion);\n    };\n    // windows method does not support 'all' and 'any' interfaces\n    is.windows.api = ['not'];\n\n    // is current device windows phone?\n    is.windowsPhone = function() {\n        return is.windows() && /phone/.test(userAgent);\n    };\n    // windowsPhone method does not support 'all' and 'any' interfaces\n    is.windowsPhone.api = ['not'];\n\n    // is current device windows tablet?\n    is.windowsTablet = function() {\n        return is.windows() && is.not.windowsPhone() && /touch/.test(userAgent);\n    };\n    // windowsTablet method does not support 'all' and 'any' interfaces\n    is.windowsTablet.api = ['not'];\n\n    // Object checks\n    /* -------------------------------------------------------------------------- */\n\n    // has a given object got parameterized count property?\n    is.propertyCount = function(object, count) {\n        if (is.not.object(object) || is.not.number(count)) {\n            return false;\n        }\n        var n = 0;\n        for (var property in object) {\n            if (hasOwnProperty.call(object, property) && ++n > count) {\n                return false;\n            }\n        }\n        return n === count;\n    };\n    // propertyCount method does not support 'all' and 'any' interfaces\n    is.propertyCount.api = ['not'];\n\n    // is given object has parameterized property?\n    is.propertyDefined = function(object, property) {\n        return is.object(object) && is.string(property) && property in object;\n    };\n    // propertyDefined method does not support 'all' and 'any' interfaces\n    is.propertyDefined.api = ['not'];\n\n    // Array checks\n    /* -------------------------------------------------------------------------- */\n\n    // is a given item in an array?\n    is.inArray = function(value, array) {\n        if (is.not.array(array)) {\n            return false;\n        }\n        for (var i = 0; i < array.length; i++) {\n            if (array[i] === value) {\n                return true;\n            }\n        }\n        return false;\n    };\n    // inArray method does not support 'all' and 'any' interfaces\n    is.inArray.api = ['not'];\n\n    // is a given array sorted?\n    is.sorted = function(array, sign) {\n        if (is.not.array(array)) {\n            return false;\n        }\n        var predicate = comparator[sign] || comparator['>='];\n        for (var i = 1; i < array.length; i++) {\n            if (!predicate(array[i], array[i - 1])) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    // API\n    // Set 'not', 'all' and 'any' interfaces to methods based on their api property\n    /* -------------------------------------------------------------------------- */\n\n    function setInterfaces() {\n        var options = is;\n        for (var option in options) {\n            if (hasOwnProperty.call(options, option) && is['function'](options[option])) {\n                var interfaces = options[option].api || ['not', 'all', 'any'];\n                for (var i = 0; i < interfaces.length; i++) {\n                    if (interfaces[i] === 'not') {\n                        is.not[option] = not(is[option]);\n                    }\n                    if (interfaces[i] === 'all') {\n                        is.all[option] = all(is[option]);\n                    }\n                    if (interfaces[i] === 'any') {\n                        is.any[option] = any(is[option]);\n                    }\n                }\n            }\n        }\n    }\n    setInterfaces();\n\n    // Configuration methods\n    // Intentionally added after setInterfaces function\n    /* -------------------------------------------------------------------------- */\n\n    // change namespace of library to prevent name collisions\n    // var preferredName = is.setNamespace();\n    // preferredName.odd(3);\n    // => true\n    is.setNamespace = function() {\n        root.is = previousIs;\n        return this;\n    };\n\n    // set optional regexes to methods\n    is.setRegexp = function(regexp, name) {\n        for (var r in regexes) {\n            if (hasOwnProperty.call(regexes, r) && (name === r)) {\n                regexes[r] = regexp;\n            }\n        }\n    };\n\n    return is;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2lzX2pzL2lzLmpzP2EwNmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQixRQUFRLElBQTBDO0FBQ2xEO0FBQ0EsUUFBUSxtQ0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUFBLG9HQUFDO0FBQ1YsS0FBSyxNQUFNLEVBUU47QUFDTCxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYyxFQUFFO0FBQzdDLDhCQUE4QixlQUFlLEVBQUU7QUFDL0MsNkJBQTZCLGNBQWMsRUFBRTtBQUM3Qyw4QkFBOEIsZUFBZTtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEdBQUcsU0FBUyxFQUFFLGlCQUFpQixHQUFHLGtCQUFrQixFQUFFLE9BQU8sR0FBRyxjQUFjLEdBQUcsOEJBQThCLEdBQUcsd0JBQXdCLEVBQUUsT0FBTyxHQUFHO0FBQ3ZMLHFGQUFxRixFQUFFLFFBQVEsRUFBRTtBQUNqRyxxREFBcUQsR0FBRyxtRkFBbUYsR0FBRztBQUM5SSw0QkFBNEIsSUFBSSxRQUFRLEtBQUs7QUFDN0M7QUFDQSxtQ0FBbUMsRUFBRSxhQUFhLEVBQUU7QUFDcEQscUNBQXFDLEVBQUUsc0JBQXNCLEVBQUUsa0JBQWtCLEVBQUU7QUFDbkYsbURBQW1ELElBQUksVUFBVSxFQUFFLFVBQVUsSUFBSSxHQUFHLEVBQUUsWUFBWSxJQUFJLDRCQUE0QixFQUFFLHdDQUF3QyxFQUFFO0FBQzlLLCtCQUErQixFQUFFLGlCQUFpQixFQUFFLGNBQWMsRUFBRTtBQUNwRSxzREFBc0QsRUFBRSxjQUFjLEVBQUUsZ0JBQWdCLEVBQUU7QUFDMUY7QUFDQSw0QkFBNEIsSUFBSSw0Q0FBNEMsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFO0FBQ25HLCtEQUErRCxJQUFJLEVBQUUsRUFBRSxpQ0FBaUMsSUFBSSxFQUFFLEVBQUUsc0NBQXNDLElBQUksRUFBRSxFQUFFLGdEQUFnRCxJQUFJLG9CQUFvQixFQUFFLG9MQUFvTCxHQUFHLFVBQVUsSUFBSTtBQUM3YSwyQkFBMkIsRUFBRSxVQUFVLEVBQUU7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFdBQVc7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvaXNfanMvaXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGlzLmpzIDAuOC4wXG4gKiBBdXRob3I6IEFyYXMgQXRhc2F5Z2luXG4gKi9cblxuLy8gQU1EIHdpdGggZ2xvYmFsLCBOb2RlLCBvciBnbG9iYWxcbjsoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkgeyAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV4dHJhLXNlbWlcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gQWxzbyBjcmVhdGUgYSBnbG9iYWwgaW4gY2FzZSBzb21lIHNjcmlwdHNcbiAgICAgICAgICAgIC8vIHRoYXQgYXJlIGxvYWRlZCBzdGlsbCBhcmUgbG9va2luZyBmb3JcbiAgICAgICAgICAgIC8vIGEgZ2xvYmFsIGV2ZW4gd2hlbiBhbiBBTUQgbG9hZGVyIGlzIGluIHVzZS5cbiAgICAgICAgICAgIHJldHVybiAocm9vdC5pcyA9IGZhY3RvcnkoKSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyBzZWxmKVxuICAgICAgICByb290LmlzID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBCYXNlbGluZVxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAvLyBkZWZpbmUgJ2lzJyBvYmplY3QgYW5kIGN1cnJlbnQgdmVyc2lvblxuICAgIHZhciBpcyA9IHt9O1xuICAgIGlzLlZFUlNJT04gPSAnMC44LjAnO1xuXG4gICAgLy8gZGVmaW5lIGludGVyZmFjZXNcbiAgICBpcy5ub3QgPSB7fTtcbiAgICBpcy5hbGwgPSB7fTtcbiAgICBpcy5hbnkgPSB7fTtcblxuICAgIC8vIGNhY2hlIHNvbWUgbWV0aG9kcyB0byBjYWxsIGxhdGVyIG9uXG4gICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiB3aGljaCByZXZlcnNlcyB0aGUgc2Vuc2Ugb2YgcHJlZGljYXRlIHJlc3VsdFxuICAgIGZ1bmN0aW9uIG5vdChmdW5jKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhZnVuYy5hcHBseShudWxsLCBzbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiB3aGljaCBjYWxsIHByZWRpY2F0ZSBmdW5jdGlvbiBwZXIgcGFyYW1ldGVyIGFuZCByZXR1cm4gdHJ1ZSBpZiBhbGwgcGFzc1xuICAgIGZ1bmN0aW9uIGFsbChmdW5jKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBnZXRQYXJhbXMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBwYXJhbXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghZnVuYy5jYWxsKG51bGwsIHBhcmFtc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiB3aGljaCBjYWxsIHByZWRpY2F0ZSBmdW5jdGlvbiBwZXIgcGFyYW1ldGVyIGFuZCByZXR1cm4gdHJ1ZSBpZiBhbnkgcGFzc1xuICAgIGZ1bmN0aW9uIGFueShmdW5jKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBnZXRQYXJhbXMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBwYXJhbXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChmdW5jLmNhbGwobnVsbCwgcGFyYW1zW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgYSAnY29tcGFyYXRvcicgb2JqZWN0IGZvciB2YXJpb3VzIGNvbXBhcmlzb24gY2hlY2tzXG4gICAgdmFyIGNvbXBhcmF0b3IgPSB7XG4gICAgICAgICc8JzogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSA8IGI7IH0sXG4gICAgICAgICc8PSc6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgPD0gYjsgfSxcbiAgICAgICAgJz4nOiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhID4gYjsgfSxcbiAgICAgICAgJz49JzogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSA+PSBiOyB9XG4gICAgfVxuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIHdoaWNoIGNvbXBhcmVzIGEgdmVyc2lvbiB0byBhIHJhbmdlXG4gICAgZnVuY3Rpb24gY29tcGFyZVZlcnNpb24odmVyc2lvbiwgcmFuZ2UpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IChyYW5nZSArICcnKTtcbiAgICAgICAgdmFyIG4gPSArKHN0cmluZy5tYXRjaCgvXFxkKy8pIHx8IE5hTik7XG4gICAgICAgIHZhciBvcCA9IHN0cmluZy5tYXRjaCgvXls8Pl09P3wvKVswXTtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3Jbb3BdID8gY29tcGFyYXRvcltvcF0odmVyc2lvbiwgbikgOiAodmVyc2lvbiA9PSBuIHx8IG4gIT09IG4pO1xuICAgIH1cblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiB3aGljaCBleHRyYWN0cyBwYXJhbXMgZnJvbSBhcmd1bWVudHNcbiAgICBmdW5jdGlvbiBnZXRQYXJhbXMoYXJncykge1xuICAgICAgICB2YXIgcGFyYW1zID0gc2xpY2UuY2FsbChhcmdzKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDEgJiYgaXMuYXJyYXkocGFyYW1zWzBdKSkgeyAgICAvLyBzdXBwb3J0IGFycmF5XG4gICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG5cbiAgICAvLyBUeXBlIGNoZWNrc1xuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAvLyBpcyBhIGdpdmVuIHZhbHVlIEFyZ3VtZW50cz9cbiAgICBpcy5hcmd1bWVudHMgPSBmdW5jdGlvbih2YWx1ZSkgeyAgICAvLyBmYWxsYmFjayBjaGVjayBpcyBmb3IgSUVcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcmd1bWVudHNdJyB8fFxuICAgICAgICAgICAgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAnY2FsbGVlJyBpbiB2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gdmFsdWUgQXJyYXk/XG4gICAgaXMuYXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7ICAgIC8vIGNoZWNrIG5hdGl2ZSBpc0FycmF5IGZpcnN0XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG4gICAgLy8gaXMgYSBnaXZlbiB2YWx1ZSBCb29sZWFuP1xuICAgIGlzLmJvb2xlYW4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gICAgfTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gdmFsdWUgQ2hhcj9cbiAgICBpcy5jaGFyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzLnN0cmluZyh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAxO1xuICAgIH07XG5cbiAgICAvLyBpcyBhIGdpdmVuIHZhbHVlIERhdGUgT2JqZWN0P1xuICAgIGlzLmRhdGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGVdJztcbiAgICB9O1xuXG4gICAgLy8gaXMgYSBnaXZlbiBvYmplY3QgYSBET00gbm9kZT9cbiAgICBpcy5kb21Ob2RlID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBpcy5vYmplY3Qob2JqZWN0KSAmJiBvYmplY3Qubm9kZVR5cGUgPiAwO1xuICAgIH07XG5cbiAgICAvLyBpcyBhIGdpdmVuIHZhbHVlIEVycm9yIG9iamVjdD9cbiAgICBpcy5lcnJvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJztcbiAgICB9O1xuXG4gICAgLy8gaXMgYSBnaXZlbiB2YWx1ZSBmdW5jdGlvbj9cbiAgICBpc1snZnVuY3Rpb24nXSA9IGZ1bmN0aW9uKHZhbHVlKSB7ICAgIC8vIGZhbGxiYWNrIGNoZWNrIGlzIGZvciBJRVxuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgIH07XG5cbiAgICAvLyBpcyBnaXZlbiB2YWx1ZSBhIHB1cmUgSlNPTiBvYmplY3Q/XG4gICAgaXMuanNvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgfTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gdmFsdWUgTmFOP1xuICAgIGlzLm5hbiA9IGZ1bmN0aW9uKHZhbHVlKSB7ICAgIC8vIE5hTiBpcyBudW1iZXIgOikgQWxzbyBpdCBpcyB0aGUgb25seSB2YWx1ZSB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGZcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gaXMgYSBnaXZlbiB2YWx1ZSBudWxsP1xuICAgIGlzWydudWxsJ10gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gdmFsdWUgbnVtYmVyP1xuICAgIGlzLm51bWJlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpcy5ub3QubmFuKHZhbHVlKSAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gdmFsdWUgb2JqZWN0P1xuICAgIGlzLm9iamVjdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QodmFsdWUpID09PSB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gaXMgYSBnaXZlbiB2YWx1ZSBSZWdFeHA/XG4gICAgaXMucmVnZXhwID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbiAgICB9O1xuXG4gICAgLy8gYXJlIGdpdmVuIHZhbHVlcyBzYW1lIHR5cGU/XG4gICAgLy8gcHJldmVudCBOYU4sIE51bWJlciBzYW1lIHR5cGUgY2hlY2tcbiAgICBpcy5zYW1lVHlwZSA9IGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICB2YXIgdGFnID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICAgIGlmICh0YWcgIT09IHRvU3RyaW5nLmNhbGwob3RoZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcbiAgICAgICAgICAgIHJldHVybiAhaXMuYW55Lm5hbih2YWx1ZSwgb3RoZXIpIHx8IGlzLmFsbC5uYW4odmFsdWUsIG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIHNhbWVUeXBlIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0ICdhbGwnIGFuZCAnYW55JyBpbnRlcmZhY2VzXG4gICAgaXMuc2FtZVR5cGUuYXBpID0gWydub3QnXTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gdmFsdWUgU3RyaW5nP1xuICAgIGlzLnN0cmluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG4gICAgfTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gdmFsdWUgdW5kZWZpbmVkP1xuICAgIGlzLnVuZGVmaW5lZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwO1xuICAgIH07XG5cbiAgICAvLyBpcyBhIGdpdmVuIHZhbHVlIHdpbmRvdz9cbiAgICAvLyBzZXRJbnRlcnZhbCBtZXRob2QgaXMgb25seSBhdmFpbGFibGUgZm9yIHdpbmRvdyBvYmplY3RcbiAgICBpcy53aW5kb3dPYmplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICdzZXRJbnRlcnZhbCcgaW4gdmFsdWU7XG4gICAgfTtcblxuICAgIC8vIFByZXNlbmNlIGNoZWNrc1xuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAvL2lzIGEgZ2l2ZW4gdmFsdWUgZW1wdHk/IE9iamVjdHMsIGFycmF5cywgc3RyaW5nc1xuICAgIGlzLmVtcHR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKGlzLm9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCB8fCAobGVuZ3RoID09PSAxICYmIGlzLmFycmF5KHZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGxlbmd0aCA9PT0gMiAmJiBpcy5hcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gJyc7XG4gICAgfTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gdmFsdWUgZXhpc3R5P1xuICAgIGlzLmV4aXN0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBpcyBhIGdpdmVuIHZhbHVlIGZhbHN5P1xuICAgIGlzLmZhbHN5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gaXMgYSBnaXZlbiB2YWx1ZSB0cnV0aHk/XG4gICAgaXMudHJ1dGh5ID0gbm90KGlzLmZhbHN5KTtcblxuICAgIC8vIEFyaXRobWV0aWMgY2hlY2tzXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgIC8vIGlzIGEgZ2l2ZW4gbnVtYmVyIGFib3ZlIG1pbmltdW0gcGFyYW1ldGVyP1xuICAgIGlzLmFib3ZlID0gZnVuY3Rpb24obiwgbWluKSB7XG4gICAgICAgIHJldHVybiBpcy5hbGwubnVtYmVyKG4sIG1pbikgJiYgbiA+IG1pbjtcbiAgICB9O1xuICAgIC8vIGFib3ZlIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0ICdhbGwnIGFuZCAnYW55JyBpbnRlcmZhY2VzXG4gICAgaXMuYWJvdmUuYXBpID0gWydub3QnXTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gbnVtYmVyIGRlY2ltYWw/XG4gICAgaXMuZGVjaW1hbCA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIGlzLm51bWJlcihuKSAmJiBuICUgMSAhPT0gMDtcbiAgICB9O1xuXG4gICAgLy8gYXJlIGdpdmVuIHZhbHVlcyBlcXVhbD8gc3VwcG9ydHMgbnVtYmVycywgc3RyaW5ncywgcmVnZXhlcywgYm9vbGVhbnNcbiAgICAvLyBUT0RPOiBBZGQgb2JqZWN0IGFuZCBhcnJheSBzdXBwb3J0XG4gICAgaXMuZXF1YWwgPSBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgLy8gY2hlY2sgMCBhbmQgLTAgZXF1aXR5IHdpdGggSW5maW5pdHkgYW5kIC1JbmZpbml0eVxuICAgICAgICBpZiAoaXMuYWxsLm51bWJlcih2YWx1ZSwgb3RoZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyICYmIDEgLyB2YWx1ZSA9PT0gMSAvIG90aGVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIHJlZ2V4ZXMgYXMgc3RyaW5ncyB0b29cbiAgICAgICAgaWYgKGlzLmFsbC5zdHJpbmcodmFsdWUsIG90aGVyKSB8fCBpcy5hbGwucmVnZXhwKHZhbHVlLCBvdGhlcikpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIHZhbHVlID09PSAnJyArIG90aGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcy5hbGwuYm9vbGVhbih2YWx1ZSwgb3RoZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIGVxdWFsIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0ICdhbGwnIGFuZCAnYW55JyBpbnRlcmZhY2VzXG4gICAgaXMuZXF1YWwuYXBpID0gWydub3QnXTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gbnVtYmVyIGV2ZW4/XG4gICAgaXMuZXZlbiA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIGlzLm51bWJlcihuKSAmJiBuICUgMiA9PT0gMDtcbiAgICB9O1xuXG4gICAgLy8gaXMgYSBnaXZlbiBudW1iZXIgZmluaXRlP1xuICAgIGlzLmZpbml0ZSA9IGlzRmluaXRlIHx8IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIGlzLm5vdC5pbmZpbml0ZShuKSAmJiBpcy5ub3QubmFuKG4pO1xuICAgIH07XG5cbiAgICAvLyBpcyBhIGdpdmVuIG51bWJlciBpbmZpbml0ZT9cbiAgICBpcy5pbmZpbml0ZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIG4gPT09IEluZmluaXR5IHx8IG4gPT09IC1JbmZpbml0eTtcbiAgICB9O1xuXG4gICAgLy8gaXMgYSBnaXZlbiBudW1iZXIgaW50ZWdlcj9cbiAgICBpcy5pbnRlZ2VyID0gZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gaXMubnVtYmVyKG4pICYmIG4gJSAxID09PSAwO1xuICAgIH07XG5cbiAgICAvLyBpcyBhIGdpdmVuIG51bWJlciBuZWdhdGl2ZT9cbiAgICBpcy5uZWdhdGl2ZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIGlzLm51bWJlcihuKSAmJiBuIDwgMDtcbiAgICB9O1xuXG4gICAgLy8gaXMgYSBnaXZlbiBudW1iZXIgb2RkP1xuICAgIGlzLm9kZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIGlzLm51bWJlcihuKSAmJiBuICUgMiA9PT0gMTtcbiAgICB9O1xuXG4gICAgLy8gaXMgYSBnaXZlbiBudW1iZXIgcG9zaXRpdmU/XG4gICAgaXMucG9zaXRpdmUgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBpcy5udW1iZXIobikgJiYgbiA+IDA7XG4gICAgfTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gbnVtYmVyIGFib3ZlIG1heGltdW0gcGFyYW1ldGVyP1xuICAgIGlzLnVuZGVyID0gZnVuY3Rpb24obiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBpcy5hbGwubnVtYmVyKG4sIG1heCkgJiYgbiA8IG1heDtcbiAgICB9O1xuICAgIC8vIGxlYXN0IG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0ICdhbGwnIGFuZCAnYW55JyBpbnRlcmZhY2VzXG4gICAgaXMudW5kZXIuYXBpID0gWydub3QnXTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gbnVtYmVyIHdpdGhpbiBtaW5pbXVtIGFuZCBtYXhpbXVtIHBhcmFtZXRlcnM/XG4gICAgaXMud2l0aGluID0gZnVuY3Rpb24obiwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIGlzLmFsbC5udW1iZXIobiwgbWluLCBtYXgpICYmIG4gPiBtaW4gJiYgbiA8IG1heDtcbiAgICB9O1xuICAgIC8vIHdpdGhpbiBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCAnYWxsJyBhbmQgJ2FueScgaW50ZXJmYWNlc1xuICAgIGlzLndpdGhpbi5hcGkgPSBbJ25vdCddO1xuXG4gICAgLy8gUmVnZXhwIGNoZWNrc1xuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgLy8gU3RldmVuIExldml0aGFuLCBKYW4gR295dmFlcnRzOiBSZWd1bGFyIEV4cHJlc3Npb25zIENvb2tib29rXG4gICAgLy8gU2NvdHQgR29uemFsZXo6IEVtYWlsIGFkZHJlc3MgdmFsaWRhdGlvblxuXG4gICAgLy8gZGF0ZVN0cmluZyBtYXRjaCBtL2QveXkgYW5kIG1tL2RkL3l5eXksIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBvbmUgb3IgdHdvIGRpZ2l0cyBmb3IgdGhlIGRheSBhbmQgbW9udGgsIGFuZCB0d28gb3IgZm91ciBkaWdpdHMgZm9yIHRoZSB5ZWFyXG4gICAgLy8gZXBwUGhvbmUgbWF0Y2ggZXh0ZW5zaWJsZSBwcm92aXNpb25pbmcgcHJvdG9jb2wgZm9ybWF0XG4gICAgLy8gbmFucFBob25lIG1hdGNoIG5vcnRoIGFtZXJpY2FuIG51bWJlciBwbGFuIGZvcm1hdFxuICAgIC8vIHRpbWUgbWF0Y2ggaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzLCAyNC1ob3VyIGNsb2NrXG4gICAgdmFyIHJlZ2V4ZXMgPSB7XG4gICAgICAgIGFmZmlybWF0aXZlOiAvXig/OjF8dCg/OnJ1ZSk/fHkoPzplcyk/fG9rKD86YXkpPykkLyxcbiAgICAgICAgYWxwaGFOdW1lcmljOiAvXltBLVphLXowLTldKyQvLFxuICAgICAgICBjYVBvc3RhbENvZGU6IC9eKD8hLipbREZJT1FVXSlbQS1WWFldWzAtOV1bQS1aXVxccz9bMC05XVtBLVpdWzAtOV0kLyxcbiAgICAgICAgY3JlZGl0Q2FyZDogL14oPzooNFswLTldezEyfSg/OlswLTldezN9KT8pfCg1WzEtNV1bMC05XXsxNH0pfCg2KD86MDExfDVbMC05XXsyfSlbMC05XXsxMn0pfCgzWzQ3XVswLTldezEzfSl8KDMoPzowWzAtNV18WzY4XVswLTldKVswLTldezExfSl8KCg/OjIxMzF8MTgwMHwzNVswLTldezN9KVswLTldezExfSkpJC8sXG4gICAgICAgIGRhdGVTdHJpbmc6IC9eKDFbMC0yXXwwP1sxLTldKShbXFwvLV0pKDNbMDFdfFsxMl1bMC05XXwwP1sxLTldKSg/OlxcMikoPzpbMC05XXsyfSk/WzAtOV17Mn0kLyxcbiAgICAgICAgZW1haWw6IC9eKCgoW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKyhcXC4oW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKykqKXwoKFxceDIyKSgoKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KChbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3Zl18XFx4MjF8W1xceDIzLVxceDViXXxbXFx4NWQtXFx4N2VdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoXFxcXChbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpKSooKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KFxceDIyKSkpQCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSQvaSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgICAgIGVwcFBob25lOiAvXlxcK1swLTldezEsM31cXC5bMC05XXs0LDE0fSg/OnguKyk/JC8sXG4gICAgICAgIGhleGFkZWNpbWFsOiAvXig/OjB4KT9bMC05YS1mQS1GXSskLyxcbiAgICAgICAgaGV4Q29sb3I6IC9eIz8oWzAtOWEtZkEtRl17M318WzAtOWEtZkEtRl17Nn0pJC8sXG4gICAgICAgIGlwdjQ6IC9eKD86KD86XFxkfFsxLTldXFxkfDFcXGR7Mn18MlswLTRdXFxkfDI1WzAtNV0pXFwuKXszfSg/OlxcZHxbMS05XVxcZHwxXFxkezJ9fDJbMC00XVxcZHwyNVswLTVdKSQvLFxuICAgICAgICBpcHY2OiAvXigoPz0uKjo6KSg/IS4qOjouKzo6KSg6Oik/KFtcXGRBLUZdezEsNH06KDp8XFxiKXwpezV9fChbXFxkQS1GXXsxLDR9Oil7Nn0pKCgoW1xcZEEtRl17MSw0fSgoPyFcXDMpOjp8OlxcYnwkKSl8KD8hXFwyXFwzKSl7Mn18KCgoMlswLTRdfDFcXGR8WzEtOV0pP1xcZHwyNVswLTVdKVxcLj9cXGIpezR9KSQvaSxcbiAgICAgICAgbmFucFBob25lOiAvXlxcKD8oWzAtOV17M30pXFwpP1stLiBdPyhbMC05XXszfSlbLS4gXT8oWzAtOV17NH0pJC8sXG4gICAgICAgIHNvY2lhbFNlY3VyaXR5TnVtYmVyOiAvXig/ITAwMHw2NjYpWzAtOF1bMC05XXsyfS0/KD8hMDApWzAtOV17Mn0tPyg/ITAwMDApWzAtOV17NH0kLyxcbiAgICAgICAgdGltZVN0cmluZzogL14oMlswLTNdfFswMV0/WzAtOV0pOihbMC01XT9bMC05XSk6KFswLTVdP1swLTldKSQvLFxuICAgICAgICB1a1Bvc3RDb2RlOiAvXltBLVpdezEsMn1bMC05UkNITlFdWzAtOUEtWl0/XFxzP1swLTldW0FCRC1ISkxOUC1VVy1aXXsyfSR8XltBLVpdezJ9LT9bMC05XXs0fSQvLFxuICAgICAgICB1cmw6IC9eKD86KD86aHR0cHM/fGZ0cCk6XFwvXFwvKT8oPzooPyEoPzoxMHwxMjcpKD86XFwuXFxkezEsM30pezN9KSg/ISg/OjE2OVxcLjI1NHwxOTJcXC4xNjgpKD86XFwuXFxkezEsM30pezJ9KSg/ITE3MlxcLig/OjFbNi05XXwyXFxkfDNbMC0xXSkoPzpcXC5cXGR7MSwzfSl7Mn0pKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswMV1cXGR8MjJbMC0zXSkoPzpcXC4oPzoxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSl7Mn0oPzpcXC4oPzpbMS05XVxcZD98MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC00XSkpfCg/Oig/OlthLXpcXHUwMGExLVxcdWZmZmYwLTldLSopKlthLXpcXHUwMGExLVxcdWZmZmYwLTldKykoPzpcXC4oPzpbYS16XFx1MDBhMS1cXHVmZmZmMC05XS0qKSpbYS16XFx1MDBhMS1cXHVmZmZmMC05XSspKig/OlxcLig/OlthLXpcXHUwMGExLVxcdWZmZmZdezIsfSkpKSg/OjpcXGR7Miw1fSk/KD86XFwvXFxTKik/JC9pLFxuICAgICAgICB1c1ppcENvZGU6IC9eWzAtOV17NX0oPzotWzAtOV17NH0pPyQvXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlZ2V4cENoZWNrKHJlZ2V4cCwgcmVnZXhlcykge1xuICAgICAgICBpc1tyZWdleHBdID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdleGVzW3JlZ2V4cF0udGVzdCh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHJlZ2V4cCBjaGVja3MgbWV0aG9kcyBmcm9tICdyZWdleGVzJyBvYmplY3RcbiAgICBmb3IgKHZhciByZWdleHAgaW4gcmVnZXhlcykge1xuICAgICAgICBpZiAocmVnZXhlcy5oYXNPd25Qcm9wZXJ0eShyZWdleHApKSB7XG4gICAgICAgICAgICByZWdleHBDaGVjayhyZWdleHAsIHJlZ2V4ZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2ltcGxpZnkgSVAgY2hlY2tzIGJ5IGNhbGxpbmcgdGhlIHJlZ2V4IGhlbHBlcnMgZm9yIElQdjQgYW5kIElQdjZcbiAgICBpcy5pcCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpcy5pcHY0KHZhbHVlKSB8fCBpcy5pcHY2KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLy8gU3RyaW5nIGNoZWNrc1xuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAvLyBpcyBhIGdpdmVuIHN0cmluZyBvciBzZW50ZW5jZSBjYXBpdGFsaXplZD9cbiAgICBpcy5jYXBpdGFsaXplZCA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICBpZiAoaXMubm90LnN0cmluZyhzdHJpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdvcmRzID0gc3RyaW5nLnNwbGl0KCcgJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB3b3JkID0gd29yZHNbaV07XG4gICAgICAgICAgICBpZiAod29yZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hyID0gd29yZC5jaGFyQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNociAhPT0gY2hyLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLy8gaXMgc3RyaW5nIGVuZCB3aXRoIGEgZ2l2ZW4gdGFyZ2V0IHBhcmFtZXRlcj9cbiAgICBpcy5lbmRXaXRoID0gZnVuY3Rpb24oc3RyaW5nLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKGlzLm5vdC5zdHJpbmcoc3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCArPSAnJztcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gc3RyaW5nLmxlbmd0aCAtIHRhcmdldC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbiA+PSAwICYmIHN0cmluZy5pbmRleE9mKHRhcmdldCwgcG9zaXRpb24pID09PSBwb3NpdGlvbjtcbiAgICB9O1xuICAgIC8vIGVuZFdpdGggbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgJ2FsbCcgYW5kICdhbnknIGludGVyZmFjZXNcbiAgICBpcy5lbmRXaXRoLmFwaSA9IFsnbm90J107XG5cbiAgICAvLyBpcyBhIGdpdmVuIHN0cmluZyBpbmNsdWRlIHBhcmFtZXRlciB0YXJnZXQ/XG4gICAgaXMuaW5jbHVkZSA9IGZ1bmN0aW9uKHN0cmluZywgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuaW5kZXhPZih0YXJnZXQpID4gLTE7XG4gICAgfTtcbiAgICAvLyBpbmNsdWRlIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0ICdhbGwnIGFuZCAnYW55JyBpbnRlcmZhY2VzXG4gICAgaXMuaW5jbHVkZS5hcGkgPSBbJ25vdCddO1xuXG4gICAgLy8gaXMgYSBnaXZlbiBzdHJpbmcgYWxsIGxvd2VyY2FzZT9cbiAgICBpcy5sb3dlckNhc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGlzLnN0cmluZyhzdHJpbmcpICYmIHN0cmluZyA9PT0gc3RyaW5nLnRvTG93ZXJDYXNlKCk7XG4gICAgfTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gc3RyaW5nIHBhbGluZHJvbWU/XG4gICAgaXMucGFsaW5kcm9tZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICBpZiAoaXMubm90LnN0cmluZyhzdHJpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1teYS16QS1aMC05XSsvZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGhhbGYgPSBNYXRoLmZsb29yKGxlbmd0aCAvIDIpOyBpIDw9IGhhbGY7IGkrKykge1xuICAgICAgICAgICAgaWYgKHN0cmluZy5jaGFyQXQoaSkgIT09IHN0cmluZy5jaGFyQXQobGVuZ3RoIC0gaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gdmFsdWUgc3BhY2U/XG4gICAgLy8gaG9yaXphbnRhbCB0YWI6IDksIGxpbmUgZmVlZDogMTAsIHZlcnRpY2FsIHRhYjogMTEsIGZvcm0gZmVlZDogMTIsIGNhcnJpYWdlIHJldHVybjogMTMsIHNwYWNlOiAzMlxuICAgIGlzLnNwYWNlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKGlzLm5vdC5jaGFyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHJldHVybiAoY2hhckNvZGUgPiA4ICYmIGNoYXJDb2RlIDwgMTQpIHx8IGNoYXJDb2RlID09PSAzMjtcbiAgICB9O1xuXG4gICAgLy8gaXMgc3RyaW5nIHN0YXJ0IHdpdGggYSBnaXZlbiB0YXJnZXQgcGFyYW1ldGVyP1xuICAgIGlzLnN0YXJ0V2l0aCA9IGZ1bmN0aW9uKHN0cmluZywgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBpcy5zdHJpbmcoc3RyaW5nKSAmJiBzdHJpbmcuaW5kZXhPZih0YXJnZXQpID09PSAwO1xuICAgIH07XG4gICAgLy8gc3RhcnRXaXRoIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0ICdhbGwnIGFuZCAnYW55JyBpbnRlcmZhY2VzXG4gICAgaXMuc3RhcnRXaXRoLmFwaSA9IFsnbm90J107XG5cbiAgICAvLyBpcyBhIGdpdmVuIHN0cmluZyBhbGwgdXBwZXJjYXNlP1xuICAgIGlzLnVwcGVyQ2FzZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gaXMuc3RyaW5nKHN0cmluZykgJiYgc3RyaW5nID09PSBzdHJpbmcudG9VcHBlckNhc2UoKTtcbiAgICB9O1xuXG4gICAgLy8gVGltZSBjaGVja3NcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgdmFyIGRheXMgPSBbJ3N1bmRheScsICdtb25kYXknLCAndHVlc2RheScsICd3ZWRuZXNkYXknLCAndGh1cnNkYXknLCAnZnJpZGF5JywgJ3NhdHVyZGF5J107XG4gICAgdmFyIG1vbnRocyA9IFsnamFudWFyeScsICdmZWJydWFyeScsICdtYXJjaCcsICdhcHJpbCcsICdtYXknLCAnanVuZScsICdqdWx5JywgJ2F1Z3VzdCcsICdzZXB0ZW1iZXInLCAnb2N0b2JlcicsICdub3ZlbWJlcicsICdkZWNlbWJlciddO1xuXG4gICAgLy8gaXMgYSBnaXZlbiBkYXRlcyBkYXkgZXF1YWwgZ2l2ZW4gZGF5IHBhcmFtZXRlcj9cbiAgICBpcy5kYXkgPSBmdW5jdGlvbihkYXRlLCBkYXkpIHtcbiAgICAgICAgcmV0dXJuIGlzLmRhdGUoZGF0ZSkgJiYgZGF5LnRvTG93ZXJDYXNlKCkgPT09IGRheXNbZGF0ZS5nZXREYXkoKV07XG4gICAgfTtcbiAgICAvLyBkYXkgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgJ2FsbCcgYW5kICdhbnknIGludGVyZmFjZXNcbiAgICBpcy5kYXkuYXBpID0gWydub3QnXTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gZGF0ZSBpbiBkYXlsaWdodCBzYXZpbmcgdGltZT9cbiAgICBpcy5kYXlMaWdodFNhdmluZ1RpbWUgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHZhciBqYW51YXJ5ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgICAgICAgdmFyIGp1bHkgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDYsIDEpO1xuICAgICAgICB2YXIgc3RkVGltZXpvbmVPZmZzZXQgPSBNYXRoLm1heChqYW51YXJ5LmdldFRpbWV6b25lT2Zmc2V0KCksIGp1bHkuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG4gICAgICAgIHJldHVybiBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgPCBzdGRUaW1lem9uZU9mZnNldDtcbiAgICB9O1xuXG4gICAgLy8gaXMgYSBnaXZlbiBkYXRlIGZ1dHVyZT9cbiAgICBpcy5mdXR1cmUgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICByZXR1cm4gaXMuZGF0ZShkYXRlKSAmJiBkYXRlLmdldFRpbWUoKSA+IG5vdy5nZXRUaW1lKCk7XG4gICAgfTtcblxuICAgIC8vIGlzIGRhdGUgd2l0aGluIGdpdmVuIHJhbmdlP1xuICAgIGlzLmluRGF0ZVJhbmdlID0gZnVuY3Rpb24oZGF0ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoaXMubm90LmRhdGUoZGF0ZSkgfHwgaXMubm90LmRhdGUoc3RhcnQpIHx8IGlzLm5vdC5kYXRlKGVuZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIHN0YW1wID4gc3RhcnQuZ2V0VGltZSgpICYmIHN0YW1wIDwgZW5kLmdldFRpbWUoKTtcbiAgICB9O1xuICAgIC8vIGluRGF0ZVJhbmdlIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0ICdhbGwnIGFuZCAnYW55JyBpbnRlcmZhY2VzXG4gICAgaXMuaW5EYXRlUmFuZ2UuYXBpID0gWydub3QnXTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gZGF0ZSBpbiBsYXN0IG1vbnRoIHJhbmdlP1xuICAgIGlzLmluTGFzdE1vbnRoID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICByZXR1cm4gaXMuaW5EYXRlUmFuZ2UoZGF0ZSwgbmV3IERhdGUobmV3IERhdGUoKS5zZXRNb250aChuZXcgRGF0ZSgpLmdldE1vbnRoKCkgLSAxKSksIG5ldyBEYXRlKCkpO1xuICAgIH07XG5cbiAgICAvLyBpcyBhIGdpdmVuIGRhdGUgaW4gbGFzdCB3ZWVrIHJhbmdlP1xuICAgIGlzLmluTGFzdFdlZWsgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHJldHVybiBpcy5pbkRhdGVSYW5nZShkYXRlLCBuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldERhdGUobmV3IERhdGUoKS5nZXREYXRlKCkgLSA3KSksIG5ldyBEYXRlKCkpO1xuICAgIH07XG5cbiAgICAvLyBpcyBhIGdpdmVuIGRhdGUgaW4gbGFzdCB5ZWFyIHJhbmdlP1xuICAgIGlzLmluTGFzdFllYXIgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHJldHVybiBpcy5pbkRhdGVSYW5nZShkYXRlLCBuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldEZ1bGxZZWFyKG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAtIDEpKSwgbmV3IERhdGUoKSk7XG4gICAgfTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gZGF0ZSBpbiBuZXh0IG1vbnRoIHJhbmdlP1xuICAgIGlzLmluTmV4dE1vbnRoID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICByZXR1cm4gaXMuaW5EYXRlUmFuZ2UoZGF0ZSwgbmV3IERhdGUoKSwgbmV3IERhdGUobmV3IERhdGUoKS5zZXRNb250aChuZXcgRGF0ZSgpLmdldE1vbnRoKCkgKyAxKSkpO1xuICAgIH07XG5cbiAgICAvLyBpcyBhIGdpdmVuIGRhdGUgaW4gbmV4dCB3ZWVrIHJhbmdlP1xuICAgIGlzLmluTmV4dFdlZWsgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHJldHVybiBpcy5pbkRhdGVSYW5nZShkYXRlLCBuZXcgRGF0ZSgpLCBuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldERhdGUobmV3IERhdGUoKS5nZXREYXRlKCkgKyA3KSkpO1xuICAgIH07XG5cbiAgICAvLyBpcyBhIGdpdmVuIGRhdGUgaW4gbmV4dCB5ZWFyIHJhbmdlP1xuICAgIGlzLmluTmV4dFllYXIgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHJldHVybiBpcy5pbkRhdGVSYW5nZShkYXRlLCBuZXcgRGF0ZSgpLCBuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldEZ1bGxZZWFyKG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSArIDEpKSk7XG4gICAgfTtcblxuICAgIC8vIGlzIHRoZSBnaXZlbiB5ZWFyIGEgbGVhcCB5ZWFyP1xuICAgIGlzLmxlYXBZZWFyID0gZnVuY3Rpb24oeWVhcikge1xuICAgICAgICByZXR1cm4gaXMubnVtYmVyKHllYXIpICYmICgoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG4gICAgfTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gZGF0ZXMgbW9udGggZXF1YWwgZ2l2ZW4gbW9udGggcGFyYW1ldGVyP1xuICAgIGlzLm1vbnRoID0gZnVuY3Rpb24oZGF0ZSwgbW9udGgpIHtcbiAgICAgICAgcmV0dXJuIGlzLmRhdGUoZGF0ZSkgJiYgbW9udGgudG9Mb3dlckNhc2UoKSA9PT0gbW9udGhzW2RhdGUuZ2V0TW9udGgoKV07XG4gICAgfTtcbiAgICAvLyBtb250aCBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCAnYWxsJyBhbmQgJ2FueScgaW50ZXJmYWNlc1xuICAgIGlzLm1vbnRoLmFwaSA9IFsnbm90J107XG5cbiAgICAvLyBpcyBhIGdpdmVuIGRhdGUgcGFzdD9cbiAgICBpcy5wYXN0ID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgcmV0dXJuIGlzLmRhdGUoZGF0ZSkgJiYgZGF0ZS5nZXRUaW1lKCkgPCBub3cuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICAvLyBpcyBhIGdpdmVuIGRhdGUgaW4gdGhlIHBhcmFtZXRlciBxdWFydGVyP1xuICAgIGlzLnF1YXJ0ZXJPZlllYXIgPSBmdW5jdGlvbihkYXRlLCBxdWFydGVyKSB7XG4gICAgICAgIHJldHVybiBpcy5kYXRlKGRhdGUpICYmIGlzLm51bWJlcihxdWFydGVyKSAmJiBxdWFydGVyID09PSBNYXRoLmZsb29yKChkYXRlLmdldE1vbnRoKCkgKyAzKSAvIDMpO1xuICAgIH07XG4gICAgLy8gcXVhcnRlck9mWWVhciBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCAnYWxsJyBhbmQgJ2FueScgaW50ZXJmYWNlc1xuICAgIGlzLnF1YXJ0ZXJPZlllYXIuYXBpID0gWydub3QnXTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gZGF0ZSBpbmRpY2F0ZSB0b2RheT9cbiAgICBpcy50b2RheSA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHZhciB0b2RheVN0cmluZyA9IG5vdy50b0RhdGVTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIGlzLmRhdGUoZGF0ZSkgJiYgZGF0ZS50b0RhdGVTdHJpbmcoKSA9PT0gdG9kYXlTdHJpbmc7XG4gICAgfTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gZGF0ZSBpbmRpY2F0ZSB0b21vcnJvdz9cbiAgICBpcy50b21vcnJvdyA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHZhciB0b21vcnJvd1N0cmluZyA9IG5ldyBEYXRlKG5vdy5zZXREYXRlKG5vdy5nZXREYXRlKCkgKyAxKSkudG9EYXRlU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBpcy5kYXRlKGRhdGUpICYmIGRhdGUudG9EYXRlU3RyaW5nKCkgPT09IHRvbW9ycm93U3RyaW5nO1xuICAgIH07XG5cbiAgICAvLyBpcyBhIGdpdmVuIGRhdGUgd2Vla2VuZD9cbiAgICAvLyA2OiBTYXR1cmRheSwgMDogU3VuZGF5XG4gICAgaXMud2Vla2VuZCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGlzLmRhdGUoZGF0ZSkgJiYgKGRhdGUuZ2V0RGF5KCkgPT09IDYgfHwgZGF0ZS5nZXREYXkoKSA9PT0gMCk7XG4gICAgfTtcblxuICAgIC8vIGlzIGEgZ2l2ZW4gZGF0ZSB3ZWVrZGF5P1xuICAgIGlzLndlZWtkYXkgPSBub3QoaXMud2Vla2VuZCk7XG5cbiAgICAvLyBpcyBhIGdpdmVuIGRhdGVzIHllYXIgZXF1YWwgZ2l2ZW4geWVhciBwYXJhbWV0ZXI/XG4gICAgaXMueWVhciA9IGZ1bmN0aW9uKGRhdGUsIHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzLmRhdGUoZGF0ZSkgJiYgaXMubnVtYmVyKHllYXIpICYmIHllYXIgPT09IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICB9O1xuICAgIC8vIHllYXIgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgJ2FsbCcgYW5kICdhbnknIGludGVyZmFjZXNcbiAgICBpcy55ZWFyLmFwaSA9IFsnbm90J107XG5cbiAgICAvLyBpcyBhIGdpdmVuIGRhdGUgaW5kaWNhdGUgeWVzdGVyZGF5P1xuICAgIGlzLnllc3RlcmRheSA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHZhciB5ZXN0ZXJkYXlTdHJpbmcgPSBuZXcgRGF0ZShub3cuc2V0RGF0ZShub3cuZ2V0RGF0ZSgpIC0gMSkpLnRvRGF0ZVN0cmluZygpO1xuICAgICAgICByZXR1cm4gaXMuZGF0ZShkYXRlKSAmJiBkYXRlLnRvRGF0ZVN0cmluZygpID09PSB5ZXN0ZXJkYXlTdHJpbmc7XG4gICAgfTtcblxuICAgIC8vIEVudmlyb25tZW50IGNoZWNrc1xuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICB2YXIgZnJlZUdsb2JhbCA9IGlzLndpbmRvd09iamVjdCh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCkgJiYgZ2xvYmFsO1xuICAgIHZhciBmcmVlU2VsZiA9IGlzLndpbmRvd09iamVjdCh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSAmJiBzZWxmO1xuICAgIHZhciB0aGlzR2xvYmFsID0gaXMud2luZG93T2JqZWN0KHR5cGVvZiB0aGlzID09ICdvYmplY3QnICYmIHRoaXMpICYmIHRoaXM7XG4gICAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IHRoaXNHbG9iYWwgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuICAgIHZhciBkb2N1bWVudCA9IGZyZWVTZWxmICYmIGZyZWVTZWxmLmRvY3VtZW50O1xuICAgIHZhciBwcmV2aW91c0lzID0gcm9vdC5pcztcblxuICAgIC8vIHN0b3JlIG5hdmlnYXRvciBwcm9wZXJ0aWVzIHRvIHVzZSBsYXRlclxuICAgIHZhciBuYXZpZ2F0b3IgPSBmcmVlU2VsZiAmJiBmcmVlU2VsZi5uYXZpZ2F0b3I7XG4gICAgdmFyIGFwcFZlcnNpb24gPSAobmF2aWdhdG9yICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciB1c2VyQWdlbnQgPSAobmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHZlbmRvciA9IChuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnZlbmRvciB8fCAnJykudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIGlzIGN1cnJlbnQgZGV2aWNlIGFuZHJvaWQ/XG4gICAgaXMuYW5kcm9pZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gL2FuZHJvaWQvLnRlc3QodXNlckFnZW50KTtcbiAgICB9O1xuICAgIC8vIGFuZHJvaWQgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgJ2FsbCcgYW5kICdhbnknIGludGVyZmFjZXNcbiAgICBpcy5hbmRyb2lkLmFwaSA9IFsnbm90J107XG5cbiAgICAvLyBpcyBjdXJyZW50IGRldmljZSBhbmRyb2lkIHBob25lP1xuICAgIGlzLmFuZHJvaWRQaG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gL2FuZHJvaWQvLnRlc3QodXNlckFnZW50KSAmJiAvbW9iaWxlLy50ZXN0KHVzZXJBZ2VudCk7XG4gICAgfTtcbiAgICAvLyBhbmRyb2lkUGhvbmUgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgJ2FsbCcgYW5kICdhbnknIGludGVyZmFjZXNcbiAgICBpcy5hbmRyb2lkUGhvbmUuYXBpID0gWydub3QnXTtcblxuICAgIC8vIGlzIGN1cnJlbnQgZGV2aWNlIGFuZHJvaWQgdGFibGV0P1xuICAgIGlzLmFuZHJvaWRUYWJsZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIC9hbmRyb2lkLy50ZXN0KHVzZXJBZ2VudCkgJiYgIS9tb2JpbGUvLnRlc3QodXNlckFnZW50KTtcbiAgICB9O1xuICAgIC8vIGFuZHJvaWRUYWJsZXQgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgJ2FsbCcgYW5kICdhbnknIGludGVyZmFjZXNcbiAgICBpcy5hbmRyb2lkVGFibGV0LmFwaSA9IFsnbm90J107XG5cbiAgICAvLyBpcyBjdXJyZW50IGRldmljZSBibGFja2JlcnJ5P1xuICAgIGlzLmJsYWNrYmVycnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIC9ibGFja2JlcnJ5Ly50ZXN0KHVzZXJBZ2VudCkgfHwgL2JiMTAvLnRlc3QodXNlckFnZW50KTtcbiAgICB9O1xuICAgIC8vIGJsYWNrYmVycnkgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgJ2FsbCcgYW5kICdhbnknIGludGVyZmFjZXNcbiAgICBpcy5ibGFja2JlcnJ5LmFwaSA9IFsnbm90J107XG5cbiAgICAvLyBpcyBjdXJyZW50IGJyb3dzZXIgY2hyb21lP1xuICAgIC8vIHBhcmFtZXRlciBpcyBvcHRpb25hbFxuICAgIGlzLmNocm9tZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IC9nb29nbGUgaW5jLy50ZXN0KHZlbmRvcikgPyB1c2VyQWdlbnQubWF0Y2goLyg/OmNocm9tZXxjcmlvcylcXC8oXFxkKykvKSA6IG51bGw7XG4gICAgICAgIHJldHVybiBtYXRjaCAhPT0gbnVsbCAmJiBjb21wYXJlVmVyc2lvbihtYXRjaFsxXSwgcmFuZ2UpO1xuICAgIH07XG4gICAgLy8gY2hyb21lIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0ICdhbGwnIGFuZCAnYW55JyBpbnRlcmZhY2VzXG4gICAgaXMuY2hyb21lLmFwaSA9IFsnbm90J107XG5cbiAgICAvLyBpcyBjdXJyZW50IGRldmljZSBkZXNrdG9wP1xuICAgIGlzLmRlc2t0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzLm5vdC5tb2JpbGUoKSAmJiBpcy5ub3QudGFibGV0KCk7XG4gICAgfTtcbiAgICAvLyBkZXNrdG9wIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0ICdhbGwnIGFuZCAnYW55JyBpbnRlcmZhY2VzXG4gICAgaXMuZGVza3RvcC5hcGkgPSBbJ25vdCddO1xuXG4gICAgLy8gaXMgY3VycmVudCBicm93c2VyIGVkZ2U/XG4gICAgLy8gcGFyYW1ldGVyIGlzIG9wdGlvbmFsXG4gICAgaXMuZWRnZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvZWRnZVxcLyhcXGQrKS8pO1xuICAgICAgICByZXR1cm4gbWF0Y2ggIT09IG51bGwgJiYgY29tcGFyZVZlcnNpb24obWF0Y2hbMV0sIHJhbmdlKTtcbiAgICB9O1xuICAgIC8vIGVkZ2UgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgJ2FsbCcgYW5kICdhbnknIGludGVyZmFjZXNcbiAgICBpcy5lZGdlLmFwaSA9IFsnbm90J107XG5cbiAgICAvLyBpcyBjdXJyZW50IGJyb3dzZXIgZmlyZWZveD9cbiAgICAvLyBwYXJhbWV0ZXIgaXMgb3B0aW9uYWxcbiAgICBpcy5maXJlZm94ID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC8oPzpmaXJlZm94fGZ4aW9zKVxcLyhcXGQrKS8pO1xuICAgICAgICByZXR1cm4gbWF0Y2ggIT09IG51bGwgJiYgY29tcGFyZVZlcnNpb24obWF0Y2hbMV0sIHJhbmdlKTtcbiAgICB9O1xuICAgIC8vIGZpcmVmb3ggbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgJ2FsbCcgYW5kICdhbnknIGludGVyZmFjZXNcbiAgICBpcy5maXJlZm94LmFwaSA9IFsnbm90J107XG5cbiAgICAvLyBpcyBjdXJyZW50IGJyb3dzZXIgaW50ZXJuZXQgZXhwbG9yZXI/XG4gICAgLy8gcGFyYW1ldGVyIGlzIG9wdGlvbmFsXG4gICAgaXMuaWUgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goLyg/Om1zaWUgfHRyaWRlbnQuKz87IHJ2OikoXFxkKykvKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoICE9PSBudWxsICYmIGNvbXBhcmVWZXJzaW9uKG1hdGNoWzFdLCByYW5nZSk7XG4gICAgfTtcbiAgICAvLyBpZSBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCAnYWxsJyBhbmQgJ2FueScgaW50ZXJmYWNlc1xuICAgIGlzLmllLmFwaSA9IFsnbm90J107XG5cbiAgICAvLyBpcyBjdXJyZW50IGRldmljZSBpb3M/XG4gICAgaXMuaW9zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpcy5pcGhvbmUoKSB8fCBpcy5pcGFkKCkgfHwgaXMuaXBvZCgpO1xuICAgIH07XG4gICAgLy8gaW9zIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0ICdhbGwnIGFuZCAnYW55JyBpbnRlcmZhY2VzXG4gICAgaXMuaW9zLmFwaSA9IFsnbm90J107XG5cbiAgICAvLyBpcyBjdXJyZW50IGRldmljZSBpcGFkP1xuICAgIC8vIHBhcmFtZXRlciBpcyBvcHRpb25hbFxuICAgIGlzLmlwYWQgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL2lwYWQuKz9vcyAoXFxkKykvKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoICE9PSBudWxsICYmIGNvbXBhcmVWZXJzaW9uKG1hdGNoWzFdLCByYW5nZSk7XG4gICAgfTtcbiAgICAvLyBpcGFkIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0ICdhbGwnIGFuZCAnYW55JyBpbnRlcmZhY2VzXG4gICAgaXMuaXBhZC5hcGkgPSBbJ25vdCddO1xuXG4gICAgLy8gaXMgY3VycmVudCBkZXZpY2UgaXBob25lP1xuICAgIC8vIHBhcmFtZXRlciBpcyBvcHRpb25hbFxuICAgIGlzLmlwaG9uZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIC8vIG9yaWdpbmFsIGlQaG9uZSBkb2Vzbid0IGhhdmUgdGhlIG9zIHBvcnRpb24gb2YgdGhlIFVBXG4gICAgICAgIHZhciBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvaXBob25lKD86Lis/b3MgKFxcZCspKT8vKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoICE9PSBudWxsICYmIGNvbXBhcmVWZXJzaW9uKG1hdGNoWzFdIHx8IDEsIHJhbmdlKTtcbiAgICB9O1xuICAgIC8vIGlwaG9uZSBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCAnYWxsJyBhbmQgJ2FueScgaW50ZXJmYWNlc1xuICAgIGlzLmlwaG9uZS5hcGkgPSBbJ25vdCddO1xuXG4gICAgLy8gaXMgY3VycmVudCBkZXZpY2UgaXBvZD9cbiAgICAvLyBwYXJhbWV0ZXIgaXMgb3B0aW9uYWxcbiAgICBpcy5pcG9kID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9pcG9kLis/b3MgKFxcZCspLyk7XG4gICAgICAgIHJldHVybiBtYXRjaCAhPT0gbnVsbCAmJiBjb21wYXJlVmVyc2lvbihtYXRjaFsxXSwgcmFuZ2UpO1xuICAgIH07XG4gICAgLy8gaXBvZCBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCAnYWxsJyBhbmQgJ2FueScgaW50ZXJmYWNlc1xuICAgIGlzLmlwb2QuYXBpID0gWydub3QnXTtcblxuICAgIC8vIGlzIGN1cnJlbnQgb3BlcmF0aW5nIHN5c3RlbSBsaW51eD9cbiAgICBpcy5saW51eCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gL2xpbnV4Ly50ZXN0KGFwcFZlcnNpb24pO1xuICAgIH07XG4gICAgLy8gbGludXggbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgJ2FsbCcgYW5kICdhbnknIGludGVyZmFjZXNcbiAgICBpcy5saW51eC5hcGkgPSBbJ25vdCddO1xuXG4gICAgLy8gaXMgY3VycmVudCBvcGVyYXRpbmcgc3lzdGVtIG1hYz9cbiAgICBpcy5tYWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIC9tYWMvLnRlc3QoYXBwVmVyc2lvbik7XG4gICAgfTtcbiAgICAvLyBtYWMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgJ2FsbCcgYW5kICdhbnknIGludGVyZmFjZXNcbiAgICBpcy5tYWMuYXBpID0gWydub3QnXTtcblxuICAgIC8vIGlzIGN1cnJlbnQgZGV2aWNlIG1vYmlsZT9cbiAgICBpcy5tb2JpbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzLmlwaG9uZSgpIHx8IGlzLmlwb2QoKSB8fCBpcy5hbmRyb2lkUGhvbmUoKSB8fCBpcy5ibGFja2JlcnJ5KCkgfHwgaXMud2luZG93c1Bob25lKCk7XG4gICAgfTtcbiAgICAvLyBtb2JpbGUgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgJ2FsbCcgYW5kICdhbnknIGludGVyZmFjZXNcbiAgICBpcy5tb2JpbGUuYXBpID0gWydub3QnXTtcblxuICAgIC8vIGlzIGN1cnJlbnQgc3RhdGUgb2ZmbGluZT9cbiAgICBpcy5vZmZsaW5lID0gbm90KGlzLm9ubGluZSk7XG4gICAgLy8gb2ZmbGluZSBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCAnYWxsJyBhbmQgJ2FueScgaW50ZXJmYWNlc1xuICAgIGlzLm9mZmxpbmUuYXBpID0gWydub3QnXTtcblxuICAgIC8vIGlzIGN1cnJlbnQgc3RhdGUgb25saW5lP1xuICAgIGlzLm9ubGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIW5hdmlnYXRvciB8fCBuYXZpZ2F0b3Iub25MaW5lID09PSB0cnVlO1xuICAgIH07XG4gICAgLy8gb25saW5lIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0ICdhbGwnIGFuZCAnYW55JyBpbnRlcmZhY2VzXG4gICAgaXMub25saW5lLmFwaSA9IFsnbm90J107XG5cbiAgICAvLyBpcyBjdXJyZW50IGJyb3dzZXIgb3BlcmE/XG4gICAgLy8gcGFyYW1ldGVyIGlzIG9wdGlvbmFsXG4gICAgaXMub3BlcmEgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goLyg/Ol5vcGVyYS4rP3ZlcnNpb258b3ByKVxcLyhcXGQrKS8pO1xuICAgICAgICByZXR1cm4gbWF0Y2ggIT09IG51bGwgJiYgY29tcGFyZVZlcnNpb24obWF0Y2hbMV0sIHJhbmdlKTtcbiAgICB9O1xuICAgIC8vIG9wZXJhIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0ICdhbGwnIGFuZCAnYW55JyBpbnRlcmZhY2VzXG4gICAgaXMub3BlcmEuYXBpID0gWydub3QnXTtcblxuICAgIC8vIGlzIGN1cnJlbnQgYnJvd3NlciBwaGFudG9tanM/XG4gICAgLy8gcGFyYW1ldGVyIGlzIG9wdGlvbmFsXG4gICAgaXMucGhhbnRvbSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvcGhhbnRvbWpzXFwvKFxcZCspLyk7XG4gICAgICAgIHJldHVybiBtYXRjaCAhPT0gbnVsbCAmJiBjb21wYXJlVmVyc2lvbihtYXRjaFsxXSwgcmFuZ2UpO1xuICAgIH07XG4gICAgLy8gcGhhbnRvbSBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCAnYWxsJyBhbmQgJ2FueScgaW50ZXJmYWNlc1xuICAgIGlzLnBoYW50b20uYXBpID0gWydub3QnXTtcblxuICAgIC8vIGlzIGN1cnJlbnQgYnJvd3NlciBzYWZhcmk/XG4gICAgLy8gcGFyYW1ldGVyIGlzIG9wdGlvbmFsXG4gICAgaXMuc2FmYXJpID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC92ZXJzaW9uXFwvKFxcZCspLis/c2FmYXJpLyk7XG4gICAgICAgIHJldHVybiBtYXRjaCAhPT0gbnVsbCAmJiBjb21wYXJlVmVyc2lvbihtYXRjaFsxXSwgcmFuZ2UpO1xuICAgIH07XG4gICAgLy8gc2FmYXJpIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0ICdhbGwnIGFuZCAnYW55JyBpbnRlcmZhY2VzXG4gICAgaXMuc2FmYXJpLmFwaSA9IFsnbm90J107XG5cbiAgICAvLyBpcyBjdXJyZW50IGRldmljZSB0YWJsZXQ/XG4gICAgaXMudGFibGV0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpcy5pcGFkKCkgfHwgaXMuYW5kcm9pZFRhYmxldCgpIHx8IGlzLndpbmRvd3NUYWJsZXQoKTtcbiAgICB9O1xuICAgIC8vIHRhYmxldCBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCAnYWxsJyBhbmQgJ2FueScgaW50ZXJmYWNlc1xuICAgIGlzLnRhYmxldC5hcGkgPSBbJ25vdCddO1xuXG4gICAgLy8gaXMgY3VycmVudCBkZXZpY2Ugc3VwcG9ydHMgdG91Y2g/XG4gICAgaXMudG91Y2hEZXZpY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhZG9jdW1lbnQgJiYgKCdvbnRvdWNoc3RhcnQnIGluIGZyZWVTZWxmIHx8XG4gICAgICAgICAgICAoJ0RvY3VtZW50VG91Y2gnIGluIGZyZWVTZWxmICYmIGRvY3VtZW50IGluc3RhbmNlb2YgRG9jdW1lbnRUb3VjaCkpO1xuICAgIH07XG4gICAgLy8gdG91Y2hEZXZpY2UgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgJ2FsbCcgYW5kICdhbnknIGludGVyZmFjZXNcbiAgICBpcy50b3VjaERldmljZS5hcGkgPSBbJ25vdCddO1xuXG4gICAgLy8gaXMgY3VycmVudCBvcGVyYXRpbmcgc3lzdGVtIHdpbmRvd3M/XG4gICAgaXMud2luZG93cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gL3dpbi8udGVzdChhcHBWZXJzaW9uKTtcbiAgICB9O1xuICAgIC8vIHdpbmRvd3MgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgJ2FsbCcgYW5kICdhbnknIGludGVyZmFjZXNcbiAgICBpcy53aW5kb3dzLmFwaSA9IFsnbm90J107XG5cbiAgICAvLyBpcyBjdXJyZW50IGRldmljZSB3aW5kb3dzIHBob25lP1xuICAgIGlzLndpbmRvd3NQaG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXMud2luZG93cygpICYmIC9waG9uZS8udGVzdCh1c2VyQWdlbnQpO1xuICAgIH07XG4gICAgLy8gd2luZG93c1Bob25lIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0ICdhbGwnIGFuZCAnYW55JyBpbnRlcmZhY2VzXG4gICAgaXMud2luZG93c1Bob25lLmFwaSA9IFsnbm90J107XG5cbiAgICAvLyBpcyBjdXJyZW50IGRldmljZSB3aW5kb3dzIHRhYmxldD9cbiAgICBpcy53aW5kb3dzVGFibGV0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpcy53aW5kb3dzKCkgJiYgaXMubm90LndpbmRvd3NQaG9uZSgpICYmIC90b3VjaC8udGVzdCh1c2VyQWdlbnQpO1xuICAgIH07XG4gICAgLy8gd2luZG93c1RhYmxldCBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCAnYWxsJyBhbmQgJ2FueScgaW50ZXJmYWNlc1xuICAgIGlzLndpbmRvd3NUYWJsZXQuYXBpID0gWydub3QnXTtcblxuICAgIC8vIE9iamVjdCBjaGVja3NcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgLy8gaGFzIGEgZ2l2ZW4gb2JqZWN0IGdvdCBwYXJhbWV0ZXJpemVkIGNvdW50IHByb3BlcnR5P1xuICAgIGlzLnByb3BlcnR5Q291bnQgPSBmdW5jdGlvbihvYmplY3QsIGNvdW50KSB7XG4gICAgICAgIGlmIChpcy5ub3Qub2JqZWN0KG9iamVjdCkgfHwgaXMubm90Lm51bWJlcihjb3VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgKytuID4gY291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4gPT09IGNvdW50O1xuICAgIH07XG4gICAgLy8gcHJvcGVydHlDb3VudCBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCAnYWxsJyBhbmQgJ2FueScgaW50ZXJmYWNlc1xuICAgIGlzLnByb3BlcnR5Q291bnQuYXBpID0gWydub3QnXTtcblxuICAgIC8vIGlzIGdpdmVuIG9iamVjdCBoYXMgcGFyYW1ldGVyaXplZCBwcm9wZXJ0eT9cbiAgICBpcy5wcm9wZXJ0eURlZmluZWQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBpcy5vYmplY3Qob2JqZWN0KSAmJiBpcy5zdHJpbmcocHJvcGVydHkpICYmIHByb3BlcnR5IGluIG9iamVjdDtcbiAgICB9O1xuICAgIC8vIHByb3BlcnR5RGVmaW5lZCBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCAnYWxsJyBhbmQgJ2FueScgaW50ZXJmYWNlc1xuICAgIGlzLnByb3BlcnR5RGVmaW5lZC5hcGkgPSBbJ25vdCddO1xuXG4gICAgLy8gQXJyYXkgY2hlY2tzXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgIC8vIGlzIGEgZ2l2ZW4gaXRlbSBpbiBhbiBhcnJheT9cbiAgICBpcy5pbkFycmF5ID0gZnVuY3Rpb24odmFsdWUsIGFycmF5KSB7XG4gICAgICAgIGlmIChpcy5ub3QuYXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIGluQXJyYXkgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgJ2FsbCcgYW5kICdhbnknIGludGVyZmFjZXNcbiAgICBpcy5pbkFycmF5LmFwaSA9IFsnbm90J107XG5cbiAgICAvLyBpcyBhIGdpdmVuIGFycmF5IHNvcnRlZD9cbiAgICBpcy5zb3J0ZWQgPSBmdW5jdGlvbihhcnJheSwgc2lnbikge1xuICAgICAgICBpZiAoaXMubm90LmFycmF5KGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmVkaWNhdGUgPSBjb21wYXJhdG9yW3NpZ25dIHx8IGNvbXBhcmF0b3JbJz49J107XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghcHJlZGljYXRlKGFycmF5W2ldLCBhcnJheVtpIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvLyBBUElcbiAgICAvLyBTZXQgJ25vdCcsICdhbGwnIGFuZCAnYW55JyBpbnRlcmZhY2VzIHRvIG1ldGhvZHMgYmFzZWQgb24gdGhlaXIgYXBpIHByb3BlcnR5XG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgIGZ1bmN0aW9uIHNldEludGVyZmFjZXMoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gaXM7XG4gICAgICAgIGZvciAodmFyIG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBvcHRpb24pICYmIGlzWydmdW5jdGlvbiddKG9wdGlvbnNbb3B0aW9uXSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJmYWNlcyA9IG9wdGlvbnNbb3B0aW9uXS5hcGkgfHwgWydub3QnLCAnYWxsJywgJ2FueSddO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJmYWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJmYWNlc1tpXSA9PT0gJ25vdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzLm5vdFtvcHRpb25dID0gbm90KGlzW29wdGlvbl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcmZhY2VzW2ldID09PSAnYWxsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXMuYWxsW29wdGlvbl0gPSBhbGwoaXNbb3B0aW9uXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyZmFjZXNbaV0gPT09ICdhbnknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcy5hbnlbb3B0aW9uXSA9IGFueShpc1tvcHRpb25dKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRJbnRlcmZhY2VzKCk7XG5cbiAgICAvLyBDb25maWd1cmF0aW9uIG1ldGhvZHNcbiAgICAvLyBJbnRlbnRpb25hbGx5IGFkZGVkIGFmdGVyIHNldEludGVyZmFjZXMgZnVuY3Rpb25cbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgLy8gY2hhbmdlIG5hbWVzcGFjZSBvZiBsaWJyYXJ5IHRvIHByZXZlbnQgbmFtZSBjb2xsaXNpb25zXG4gICAgLy8gdmFyIHByZWZlcnJlZE5hbWUgPSBpcy5zZXROYW1lc3BhY2UoKTtcbiAgICAvLyBwcmVmZXJyZWROYW1lLm9kZCgzKTtcbiAgICAvLyA9PiB0cnVlXG4gICAgaXMuc2V0TmFtZXNwYWNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJvb3QuaXMgPSBwcmV2aW91c0lzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLy8gc2V0IG9wdGlvbmFsIHJlZ2V4ZXMgdG8gbWV0aG9kc1xuICAgIGlzLnNldFJlZ2V4cCA9IGZ1bmN0aW9uKHJlZ2V4cCwgbmFtZSkge1xuICAgICAgICBmb3IgKHZhciByIGluIHJlZ2V4ZXMpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZ2V4ZXMsIHIpICYmIChuYW1lID09PSByKSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ZXNbcl0gPSByZWdleHA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGlzO1xufSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/is_js/is.js\n");

/***/ }),

/***/ "../../node_modules/jsonfile/index.js":
/*!**************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/jsonfile/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _fs\ntry {\n  _fs = __webpack_require__(/*! graceful-fs */ \"../../node_modules/graceful-fs/graceful-fs.js\")\n} catch (_) {\n  _fs = __webpack_require__(/*! fs */ \"fs\")\n}\n\nfunction readFile (file, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  // DO NOT USE 'passParsingErrors' THE NAME WILL CHANGE!!!, use 'throws' instead\n  if ('passParsingErrors' in options) {\n    shouldThrow = options.passParsingErrors\n  } else if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  fs.readFile(file, options, function (err, data) {\n    if (err) return callback(err)\n\n    data = stripBom(data)\n\n    var obj\n    try {\n      obj = JSON.parse(data, options ? options.reviver : null)\n    } catch (err2) {\n      if (shouldThrow) {\n        err2.message = file + ': ' + err2.message\n        return callback(err2)\n      } else {\n        return callback(null, null)\n      }\n    }\n\n    callback(null, obj)\n  })\n}\n\nfunction readFileSync (file, options) {\n  options = options || {}\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  // DO NOT USE 'passParsingErrors' THE NAME WILL CHANGE!!!, use 'throws' instead\n  if ('passParsingErrors' in options) {\n    shouldThrow = options.passParsingErrors\n  } else if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  var content = fs.readFileSync(file, options)\n  content = stripBom(content)\n\n  try {\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = file + ': ' + err.message\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nfunction writeFile (file, obj, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var spaces = typeof options === 'object' && options !== null\n    ? 'spaces' in options\n    ? options.spaces : this.spaces\n    : this.spaces\n\n  var str = ''\n  try {\n    str = JSON.stringify(obj, options ? options.replacer : null, spaces) + '\\n'\n  } catch (err) {\n    if (callback) return callback(err, null)\n  }\n\n  fs.writeFile(file, str, options, callback)\n}\n\nfunction writeFileSync (file, obj, options) {\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var spaces = typeof options === 'object' && options !== null\n    ? 'spaces' in options\n    ? options.spaces : this.spaces\n    : this.spaces\n\n  var str = JSON.stringify(obj, options.replacer, spaces) + '\\n'\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  content = content.replace(/^\\uFEFF/, '')\n  return content\n}\n\nvar jsonfile = {\n  spaces: null,\n  readFile: readFile,\n  readFileSync: readFileSync,\n  writeFile: writeFile,\n  writeFileSync: writeFileSync\n}\n\nmodule.exports = jsonfile\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL2pzb25maWxlL2luZGV4LmpzP2UwMGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLFFBQVEsbUJBQU8sQ0FBQyxrRUFBYTtBQUM3QixDQUFDO0FBQ0QsUUFBUSxtQkFBTyxDQUFDLGNBQUk7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvanNvbmZpbGUvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2ZzXG50cnkge1xuICBfZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG59IGNhdGNoIChfKSB7XG4gIF9mcyA9IHJlcXVpcmUoJ2ZzJylcbn1cblxuZnVuY3Rpb24gcmVhZEZpbGUgKGZpbGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PSBudWxsKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHtlbmNvZGluZzogb3B0aW9uc31cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBmcyA9IG9wdGlvbnMuZnMgfHwgX2ZzXG5cbiAgdmFyIHNob3VsZFRocm93ID0gdHJ1ZVxuICAvLyBETyBOT1QgVVNFICdwYXNzUGFyc2luZ0Vycm9ycycgVEhFIE5BTUUgV0lMTCBDSEFOR0UhISEsIHVzZSAndGhyb3dzJyBpbnN0ZWFkXG4gIGlmICgncGFzc1BhcnNpbmdFcnJvcnMnIGluIG9wdGlvbnMpIHtcbiAgICBzaG91bGRUaHJvdyA9IG9wdGlvbnMucGFzc1BhcnNpbmdFcnJvcnNcbiAgfSBlbHNlIGlmICgndGhyb3dzJyBpbiBvcHRpb25zKSB7XG4gICAgc2hvdWxkVGhyb3cgPSBvcHRpb25zLnRocm93c1xuICB9XG5cbiAgZnMucmVhZEZpbGUoZmlsZSwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG5cbiAgICBkYXRhID0gc3RyaXBCb20oZGF0YSlcblxuICAgIHZhciBvYmpcbiAgICB0cnkge1xuICAgICAgb2JqID0gSlNPTi5wYXJzZShkYXRhLCBvcHRpb25zID8gb3B0aW9ucy5yZXZpdmVyIDogbnVsbClcbiAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgICAgZXJyMi5tZXNzYWdlID0gZmlsZSArICc6ICcgKyBlcnIyLm1lc3NhZ2VcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycjIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCBvYmopXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlYWRGaWxlU3luYyAoZmlsZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHtlbmNvZGluZzogb3B0aW9uc31cbiAgfVxuXG4gIHZhciBmcyA9IG9wdGlvbnMuZnMgfHwgX2ZzXG5cbiAgdmFyIHNob3VsZFRocm93ID0gdHJ1ZVxuICAvLyBETyBOT1QgVVNFICdwYXNzUGFyc2luZ0Vycm9ycycgVEhFIE5BTUUgV0lMTCBDSEFOR0UhISEsIHVzZSAndGhyb3dzJyBpbnN0ZWFkXG4gIGlmICgncGFzc1BhcnNpbmdFcnJvcnMnIGluIG9wdGlvbnMpIHtcbiAgICBzaG91bGRUaHJvdyA9IG9wdGlvbnMucGFzc1BhcnNpbmdFcnJvcnNcbiAgfSBlbHNlIGlmICgndGhyb3dzJyBpbiBvcHRpb25zKSB7XG4gICAgc2hvdWxkVGhyb3cgPSBvcHRpb25zLnRocm93c1xuICB9XG5cbiAgdmFyIGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgb3B0aW9ucylcbiAgY29udGVudCA9IHN0cmlwQm9tKGNvbnRlbnQpXG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShjb250ZW50LCBvcHRpb25zLnJldml2ZXIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgZXJyLm1lc3NhZ2UgPSBmaWxlICsgJzogJyArIGVyci5tZXNzYWdlXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JpdGVGaWxlIChmaWxlLCBvYmosIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PSBudWxsKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICB2YXIgc3BhY2VzID0gdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGxcbiAgICA/ICdzcGFjZXMnIGluIG9wdGlvbnNcbiAgICA/IG9wdGlvbnMuc3BhY2VzIDogdGhpcy5zcGFjZXNcbiAgICA6IHRoaXMuc3BhY2VzXG5cbiAgdmFyIHN0ciA9ICcnXG4gIHRyeSB7XG4gICAgc3RyID0gSlNPTi5zdHJpbmdpZnkob2JqLCBvcHRpb25zID8gb3B0aW9ucy5yZXBsYWNlciA6IG51bGwsIHNwYWNlcykgKyAnXFxuJ1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoY2FsbGJhY2spIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpXG4gIH1cblxuICBmcy53cml0ZUZpbGUoZmlsZSwgc3RyLCBvcHRpb25zLCBjYWxsYmFjaylcbn1cblxuZnVuY3Rpb24gd3JpdGVGaWxlU3luYyAoZmlsZSwgb2JqLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBmcyA9IG9wdGlvbnMuZnMgfHwgX2ZzXG5cbiAgdmFyIHNwYWNlcyA9IHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9PSBudWxsXG4gICAgPyAnc3BhY2VzJyBpbiBvcHRpb25zXG4gICAgPyBvcHRpb25zLnNwYWNlcyA6IHRoaXMuc3BhY2VzXG4gICAgOiB0aGlzLnNwYWNlc1xuXG4gIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeShvYmosIG9wdGlvbnMucmVwbGFjZXIsIHNwYWNlcykgKyAnXFxuJ1xuICAvLyBub3Qgc3VyZSBpZiBmcy53cml0ZUZpbGVTeW5jIHJldHVybnMgYW55dGhpbmcsIGJ1dCBqdXN0IGluIGNhc2VcbiAgcmV0dXJuIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgc3RyLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdHJpcEJvbSAoY29udGVudCkge1xuICAvLyB3ZSBkbyB0aGlzIGJlY2F1c2UgSlNPTi5wYXJzZSB3b3VsZCBjb252ZXJ0IGl0IHRvIGEgdXRmOCBzdHJpbmcgaWYgZW5jb2Rpbmcgd2Fzbid0IHNwZWNpZmllZFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNvbnRlbnQpKSBjb250ZW50ID0gY29udGVudC50b1N0cmluZygndXRmOCcpXG4gIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoL15cXHVGRUZGLywgJycpXG4gIHJldHVybiBjb250ZW50XG59XG5cbnZhciBqc29uZmlsZSA9IHtcbiAgc3BhY2VzOiBudWxsLFxuICByZWFkRmlsZTogcmVhZEZpbGUsXG4gIHJlYWRGaWxlU3luYzogcmVhZEZpbGVTeW5jLFxuICB3cml0ZUZpbGU6IHdyaXRlRmlsZSxcbiAgd3JpdGVGaWxlU3luYzogd3JpdGVGaWxlU3luY1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGpzb25maWxlXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/jsonfile/index.js\n");

/***/ }),

/***/ "../../node_modules/node-gyp-build/index.js":
/*!********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/node-gyp-build/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fs = __webpack_require__(/*! fs */ \"fs\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar os = __webpack_require__(/*! os */ \"os\")\n\n// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'\nvar runtimeRequire =  true ? require : undefined // eslint-disable-line\n\nvar abi = process.versions.modules // TODO: support old node where this is undef\nvar runtime = isElectron() ? 'electron' : 'node'\nvar arch = os.arch()\nvar platform = os.platform()\n\nmodule.exports = load\n\nfunction load (dir) {\n  return runtimeRequire(load.path(dir))\n}\n\nload.path = function (dir) {\n  dir = path.resolve(dir || '.')\n\n  try {\n    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')\n    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']\n  } catch (err) {}\n\n  var release = getFirst(path.join(dir, 'build/Release'), matchBuild)\n  if (release) return release\n\n  var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)\n  if (debug) return debug\n\n  var prebuild = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchPrebuild)\n  if (prebuild) return prebuild\n\n  var napiRuntime = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchNapiRuntime)\n  if (napiRuntime) return napiRuntime\n\n  var napi = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchNapi)\n  if (napi) return napi\n\n  throw new Error('No native build was found for runtime=' + runtime + ' abi=' + abi + ' platform=' + platform + ' arch=' + arch)\n}\n\nfunction getFirst (dir, filter) {\n  try {\n    var files = fs.readdirSync(dir).filter(filter)\n    return files[0] && path.join(dir, files[0])\n  } catch (err) {\n    return null\n  }\n}\n\nfunction matchNapiRuntime (name) {\n  return name === runtime + '-napi.node'\n}\n\nfunction matchNapi (name) {\n  return name === 'node-napi.node'\n}\n\nfunction matchPrebuild (name) {\n  var parts = name.split('-')\n  return parts[0] === runtime && parts[1] === abi + '.node'\n}\n\nfunction matchBuild (name) {\n  return /\\.node$/.test(name)\n}\n\nfunction isElectron () {\n  if (process.versions && process.versions.electron) return true\n  if (process.env.ELECTRON_RUN_AS_NODE) return true\n  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL25vZGUtZ3lwLWJ1aWxkL2luZGV4LmpzP2Q3ZTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxtQkFBTyxDQUFDLGNBQUk7QUFDckIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFNBQVMsbUJBQU8sQ0FBQyxjQUFJOztBQUVyQjtBQUNBLHFCQUFxQixLQUF5QyxHQUFHLE9BQXVCLEdBQUcsU0FBTzs7QUFFbEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvbm9kZS1neXAtYnVpbGQvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxudmFyIG9zID0gcmVxdWlyZSgnb3MnKVxuXG4vLyBXb3JrYXJvdW5kIHRvIGZpeCB3ZWJwYWNrJ3MgYnVpbGQgd2FybmluZ3M6ICd0aGUgcmVxdWVzdCBvZiBhIGRlcGVuZGVuY3kgaXMgYW4gZXhwcmVzc2lvbidcbnZhciBydW50aW1lUmVxdWlyZSA9IHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fID09PSAnZnVuY3Rpb24nID8gX19ub25fd2VicGFja19yZXF1aXJlX18gOiByZXF1aXJlIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxudmFyIGFiaSA9IHByb2Nlc3MudmVyc2lvbnMubW9kdWxlcyAvLyBUT0RPOiBzdXBwb3J0IG9sZCBub2RlIHdoZXJlIHRoaXMgaXMgdW5kZWZcbnZhciBydW50aW1lID0gaXNFbGVjdHJvbigpID8gJ2VsZWN0cm9uJyA6ICdub2RlJ1xudmFyIGFyY2ggPSBvcy5hcmNoKClcbnZhciBwbGF0Zm9ybSA9IG9zLnBsYXRmb3JtKClcblxubW9kdWxlLmV4cG9ydHMgPSBsb2FkXG5cbmZ1bmN0aW9uIGxvYWQgKGRpcikge1xuICByZXR1cm4gcnVudGltZVJlcXVpcmUobG9hZC5wYXRoKGRpcikpXG59XG5cbmxvYWQucGF0aCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgZGlyID0gcGF0aC5yZXNvbHZlKGRpciB8fCAnLicpXG5cbiAgdHJ5IHtcbiAgICB2YXIgbmFtZSA9IHJ1bnRpbWVSZXF1aXJlKHBhdGguam9pbihkaXIsICdwYWNrYWdlLmpzb24nKSkubmFtZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJ18nKVxuICAgIGlmIChwcm9jZXNzLmVudltuYW1lICsgJ19QUkVCVUlMRCddKSBkaXIgPSBwcm9jZXNzLmVudltuYW1lICsgJ19QUkVCVUlMRCddXG4gIH0gY2F0Y2ggKGVycikge31cblxuICB2YXIgcmVsZWFzZSA9IGdldEZpcnN0KHBhdGguam9pbihkaXIsICdidWlsZC9SZWxlYXNlJyksIG1hdGNoQnVpbGQpXG4gIGlmIChyZWxlYXNlKSByZXR1cm4gcmVsZWFzZVxuXG4gIHZhciBkZWJ1ZyA9IGdldEZpcnN0KHBhdGguam9pbihkaXIsICdidWlsZC9EZWJ1ZycpLCBtYXRjaEJ1aWxkKVxuICBpZiAoZGVidWcpIHJldHVybiBkZWJ1Z1xuXG4gIHZhciBwcmVidWlsZCA9IGdldEZpcnN0KHBhdGguam9pbihkaXIsICdwcmVidWlsZHMvJyArIHBsYXRmb3JtICsgJy0nICsgYXJjaCksIG1hdGNoUHJlYnVpbGQpXG4gIGlmIChwcmVidWlsZCkgcmV0dXJuIHByZWJ1aWxkXG5cbiAgdmFyIG5hcGlSdW50aW1lID0gZ2V0Rmlyc3QocGF0aC5qb2luKGRpciwgJ3ByZWJ1aWxkcy8nICsgcGxhdGZvcm0gKyAnLScgKyBhcmNoKSwgbWF0Y2hOYXBpUnVudGltZSlcbiAgaWYgKG5hcGlSdW50aW1lKSByZXR1cm4gbmFwaVJ1bnRpbWVcblxuICB2YXIgbmFwaSA9IGdldEZpcnN0KHBhdGguam9pbihkaXIsICdwcmVidWlsZHMvJyArIHBsYXRmb3JtICsgJy0nICsgYXJjaCksIG1hdGNoTmFwaSlcbiAgaWYgKG5hcGkpIHJldHVybiBuYXBpXG5cbiAgdGhyb3cgbmV3IEVycm9yKCdObyBuYXRpdmUgYnVpbGQgd2FzIGZvdW5kIGZvciBydW50aW1lPScgKyBydW50aW1lICsgJyBhYmk9JyArIGFiaSArICcgcGxhdGZvcm09JyArIHBsYXRmb3JtICsgJyBhcmNoPScgKyBhcmNoKVxufVxuXG5mdW5jdGlvbiBnZXRGaXJzdCAoZGlyLCBmaWx0ZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZmlsZXMgPSBmcy5yZWFkZGlyU3luYyhkaXIpLmZpbHRlcihmaWx0ZXIpXG4gICAgcmV0dXJuIGZpbGVzWzBdICYmIHBhdGguam9pbihkaXIsIGZpbGVzWzBdKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoTmFwaVJ1bnRpbWUgKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUgPT09IHJ1bnRpbWUgKyAnLW5hcGkubm9kZSdcbn1cblxuZnVuY3Rpb24gbWF0Y2hOYXBpIChuYW1lKSB7XG4gIHJldHVybiBuYW1lID09PSAnbm9kZS1uYXBpLm5vZGUnXG59XG5cbmZ1bmN0aW9uIG1hdGNoUHJlYnVpbGQgKG5hbWUpIHtcbiAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLScpXG4gIHJldHVybiBwYXJ0c1swXSA9PT0gcnVudGltZSAmJiBwYXJ0c1sxXSA9PT0gYWJpICsgJy5ub2RlJ1xufVxuXG5mdW5jdGlvbiBtYXRjaEJ1aWxkIChuYW1lKSB7XG4gIHJldHVybiAvXFwubm9kZSQvLnRlc3QobmFtZSlcbn1cblxuZnVuY3Rpb24gaXNFbGVjdHJvbiAoKSB7XG4gIGlmIChwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24pIHJldHVybiB0cnVlXG4gIGlmIChwcm9jZXNzLmVudi5FTEVDVFJPTl9SVU5fQVNfTk9ERSkgcmV0dXJuIHRydWVcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcidcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/node-gyp-build/index.js\n");

/***/ }),

/***/ "../../node_modules/request-ip/dist/index.js":
/*!*********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/request-ip/dist/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar is = __webpack_require__(/*! is_js */ \"../../node_modules/is_js/is.js\");\n/**\n * Parse x-forwarded-for headers.\n *\n * @param {string} value - The value to be parsed.\n * @return {string|null} First known IP address, if any.\n */\n\n\nfunction getClientIpFromXForwardedFor(value) {\n  if (!is.existy(value)) {\n    return null;\n  }\n\n  if (is.not.string(value)) {\n    throw new TypeError(\"Expected a string, got \\\"\".concat(_typeof(value), \"\\\"\"));\n  } // x-forwarded-for may return multiple IP addresses in the format:\n  // \"client IP, proxy 1 IP, proxy 2 IP\"\n  // Therefore, the right-most IP address is the IP address of the most recent proxy\n  // and the left-most IP address is the IP address of the originating client.\n  // source: http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/x-forwarded-headers.html\n  // Azure Web App's also adds a port for some reason, so we'll only use the first part (the IP)\n\n\n  var forwardedIps = value.split(',').map(function (e) {\n    var ip = e.trim();\n\n    if (ip.includes(':')) {\n      var splitted = ip.split(':'); // make sure we only use this if it's ipv4 (ip:port)\n\n      if (splitted.length === 2) {\n        return splitted[0];\n      }\n    }\n\n    return ip;\n  }); // Sometimes IP addresses in this header can be 'unknown' (http://stackoverflow.com/a/11285650).\n  // Therefore taking the left-most IP address that is not unknown\n  // A Squid configuration directive can also set the value to \"unknown\" (http://www.squid-cache.org/Doc/config/forwarded_for/)\n\n  return forwardedIps.find(is.ip);\n}\n/**\n * Determine client IP address.\n *\n * @param req\n * @returns {string} ip - The IP address if known, defaulting to empty string if unknown.\n */\n\n\nfunction getClientIp(req) {\n  // Server is probably behind a proxy.\n  if (req.headers) {\n    // Standard headers used by Amazon EC2, Heroku, and others.\n    if (is.ip(req.headers['x-client-ip'])) {\n      return req.headers['x-client-ip'];\n    } // Load-balancers (AWS ELB) or proxies.\n\n\n    var xForwardedFor = getClientIpFromXForwardedFor(req.headers['x-forwarded-for']);\n\n    if (is.ip(xForwardedFor)) {\n      return xForwardedFor;\n    } // Cloudflare.\n    // @see https://support.cloudflare.com/hc/en-us/articles/200170986-How-does-Cloudflare-handle-HTTP-Request-headers-\n    // CF-Connecting-IP - applied to every request to the origin.\n\n\n    if (is.ip(req.headers['cf-connecting-ip'])) {\n      return req.headers['cf-connecting-ip'];\n    } // Fastly and Firebase hosting header (When forwared to cloud function)\n\n\n    if (is.ip(req.headers['fastly-client-ip'])) {\n      return req.headers['fastly-client-ip'];\n    } // Akamai and Cloudflare: True-Client-IP.\n\n\n    if (is.ip(req.headers['true-client-ip'])) {\n      return req.headers['true-client-ip'];\n    } // Default nginx proxy/fcgi; alternative to x-forwarded-for, used by some proxies.\n\n\n    if (is.ip(req.headers['x-real-ip'])) {\n      return req.headers['x-real-ip'];\n    } // (Rackspace LB and Riverbed's Stingray)\n    // http://www.rackspace.com/knowledge_center/article/controlling-access-to-linux-cloud-sites-based-on-the-client-ip-address\n    // https://splash.riverbed.com/docs/DOC-1926\n\n\n    if (is.ip(req.headers['x-cluster-client-ip'])) {\n      return req.headers['x-cluster-client-ip'];\n    }\n\n    if (is.ip(req.headers['x-forwarded'])) {\n      return req.headers['x-forwarded'];\n    }\n\n    if (is.ip(req.headers['forwarded-for'])) {\n      return req.headers['forwarded-for'];\n    }\n\n    if (is.ip(req.headers.forwarded)) {\n      return req.headers.forwarded;\n    }\n  } // Remote address checks.\n\n\n  if (is.existy(req.connection)) {\n    if (is.ip(req.connection.remoteAddress)) {\n      return req.connection.remoteAddress;\n    }\n\n    if (is.existy(req.connection.socket) && is.ip(req.connection.socket.remoteAddress)) {\n      return req.connection.socket.remoteAddress;\n    }\n  }\n\n  if (is.existy(req.socket) && is.ip(req.socket.remoteAddress)) {\n    return req.socket.remoteAddress;\n  }\n\n  if (is.existy(req.info) && is.ip(req.info.remoteAddress)) {\n    return req.info.remoteAddress;\n  } // AWS Api Gateway + Lambda\n\n\n  if (is.existy(req.requestContext) && is.existy(req.requestContext.identity) && is.ip(req.requestContext.identity.sourceIp)) {\n    return req.requestContext.identity.sourceIp;\n  }\n\n  return null;\n}\n/**\n * Expose request IP as a middleware.\n *\n * @param {object} [options] - Configuration.\n * @param {string} [options.attributeName] - Name of attribute to augment request object with.\n * @return {*}\n */\n\n\nfunction mw(options) {\n  // Defaults.\n  var configuration = is.not.existy(options) ? {} : options; // Validation.\n\n  if (is.not.object(configuration)) {\n    throw new TypeError('Options must be an object!');\n  }\n\n  var attributeName = configuration.attributeName || 'clientIp';\n  return function (req, res, next) {\n    var ip = getClientIp(req);\n    Object.defineProperty(req, attributeName, {\n      get: function get() {\n        return ip;\n      },\n      configurable: true\n    });\n    next();\n  };\n}\n\nmodule.exports = {\n  getClientIpFromXForwardedFor: getClientIpFromXForwardedFor,\n  getClientIp: getClientIp,\n  mw: mw\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3JlcXVlc3QtaXAvZGlzdC9pbmRleC5qcz9iMTAyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLHVCQUF1QiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRTdWLFNBQVMsbUJBQU8sQ0FBQyw2Q0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxZQUFZO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyxFQUFFO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EsS0FBSyw2QkFBNkI7OztBQUdsQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXOztBQUU1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9yZXF1ZXN0LWlwL2Rpc3QvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIGlzID0gcmVxdWlyZSgnaXNfanMnKTtcbi8qKlxuICogUGFyc2UgeC1mb3J3YXJkZWQtZm9yIGhlYWRlcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm4ge3N0cmluZ3xudWxsfSBGaXJzdCBrbm93biBJUCBhZGRyZXNzLCBpZiBhbnkuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDbGllbnRJcEZyb21YRm9yd2FyZGVkRm9yKHZhbHVlKSB7XG4gIGlmICghaXMuZXhpc3R5KHZhbHVlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGlzLm5vdC5zdHJpbmcodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nLCBnb3QgXFxcIlwiLmNvbmNhdChfdHlwZW9mKHZhbHVlKSwgXCJcXFwiXCIpKTtcbiAgfSAvLyB4LWZvcndhcmRlZC1mb3IgbWF5IHJldHVybiBtdWx0aXBsZSBJUCBhZGRyZXNzZXMgaW4gdGhlIGZvcm1hdDpcbiAgLy8gXCJjbGllbnQgSVAsIHByb3h5IDEgSVAsIHByb3h5IDIgSVBcIlxuICAvLyBUaGVyZWZvcmUsIHRoZSByaWdodC1tb3N0IElQIGFkZHJlc3MgaXMgdGhlIElQIGFkZHJlc3Mgb2YgdGhlIG1vc3QgcmVjZW50IHByb3h5XG4gIC8vIGFuZCB0aGUgbGVmdC1tb3N0IElQIGFkZHJlc3MgaXMgdGhlIElQIGFkZHJlc3Mgb2YgdGhlIG9yaWdpbmF0aW5nIGNsaWVudC5cbiAgLy8gc291cmNlOiBodHRwOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9lbGFzdGljbG9hZGJhbGFuY2luZy9sYXRlc3QvY2xhc3NpYy94LWZvcndhcmRlZC1oZWFkZXJzLmh0bWxcbiAgLy8gQXp1cmUgV2ViIEFwcCdzIGFsc28gYWRkcyBhIHBvcnQgZm9yIHNvbWUgcmVhc29uLCBzbyB3ZSdsbCBvbmx5IHVzZSB0aGUgZmlyc3QgcGFydCAodGhlIElQKVxuXG5cbiAgdmFyIGZvcndhcmRlZElwcyA9IHZhbHVlLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGlwID0gZS50cmltKCk7XG5cbiAgICBpZiAoaXAuaW5jbHVkZXMoJzonKSkge1xuICAgICAgdmFyIHNwbGl0dGVkID0gaXAuc3BsaXQoJzonKTsgLy8gbWFrZSBzdXJlIHdlIG9ubHkgdXNlIHRoaXMgaWYgaXQncyBpcHY0IChpcDpwb3J0KVxuXG4gICAgICBpZiAoc3BsaXR0ZWQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiBzcGxpdHRlZFswXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXA7XG4gIH0pOyAvLyBTb21ldGltZXMgSVAgYWRkcmVzc2VzIGluIHRoaXMgaGVhZGVyIGNhbiBiZSAndW5rbm93bicgKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExMjg1NjUwKS5cbiAgLy8gVGhlcmVmb3JlIHRha2luZyB0aGUgbGVmdC1tb3N0IElQIGFkZHJlc3MgdGhhdCBpcyBub3QgdW5rbm93blxuICAvLyBBIFNxdWlkIGNvbmZpZ3VyYXRpb24gZGlyZWN0aXZlIGNhbiBhbHNvIHNldCB0aGUgdmFsdWUgdG8gXCJ1bmtub3duXCIgKGh0dHA6Ly93d3cuc3F1aWQtY2FjaGUub3JnL0RvYy9jb25maWcvZm9yd2FyZGVkX2Zvci8pXG5cbiAgcmV0dXJuIGZvcndhcmRlZElwcy5maW5kKGlzLmlwKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lIGNsaWVudCBJUCBhZGRyZXNzLlxuICpcbiAqIEBwYXJhbSByZXFcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGlwIC0gVGhlIElQIGFkZHJlc3MgaWYga25vd24sIGRlZmF1bHRpbmcgdG8gZW1wdHkgc3RyaW5nIGlmIHVua25vd24uXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDbGllbnRJcChyZXEpIHtcbiAgLy8gU2VydmVyIGlzIHByb2JhYmx5IGJlaGluZCBhIHByb3h5LlxuICBpZiAocmVxLmhlYWRlcnMpIHtcbiAgICAvLyBTdGFuZGFyZCBoZWFkZXJzIHVzZWQgYnkgQW1hem9uIEVDMiwgSGVyb2t1LCBhbmQgb3RoZXJzLlxuICAgIGlmIChpcy5pcChyZXEuaGVhZGVyc1sneC1jbGllbnQtaXAnXSkpIHtcbiAgICAgIHJldHVybiByZXEuaGVhZGVyc1sneC1jbGllbnQtaXAnXTtcbiAgICB9IC8vIExvYWQtYmFsYW5jZXJzIChBV1MgRUxCKSBvciBwcm94aWVzLlxuXG5cbiAgICB2YXIgeEZvcndhcmRlZEZvciA9IGdldENsaWVudElwRnJvbVhGb3J3YXJkZWRGb3IocmVxLmhlYWRlcnNbJ3gtZm9yd2FyZGVkLWZvciddKTtcblxuICAgIGlmIChpcy5pcCh4Rm9yd2FyZGVkRm9yKSkge1xuICAgICAgcmV0dXJuIHhGb3J3YXJkZWRGb3I7XG4gICAgfSAvLyBDbG91ZGZsYXJlLlxuICAgIC8vIEBzZWUgaHR0cHM6Ly9zdXBwb3J0LmNsb3VkZmxhcmUuY29tL2hjL2VuLXVzL2FydGljbGVzLzIwMDE3MDk4Ni1Ib3ctZG9lcy1DbG91ZGZsYXJlLWhhbmRsZS1IVFRQLVJlcXVlc3QtaGVhZGVycy1cbiAgICAvLyBDRi1Db25uZWN0aW5nLUlQIC0gYXBwbGllZCB0byBldmVyeSByZXF1ZXN0IHRvIHRoZSBvcmlnaW4uXG5cblxuICAgIGlmIChpcy5pcChyZXEuaGVhZGVyc1snY2YtY29ubmVjdGluZy1pcCddKSkge1xuICAgICAgcmV0dXJuIHJlcS5oZWFkZXJzWydjZi1jb25uZWN0aW5nLWlwJ107XG4gICAgfSAvLyBGYXN0bHkgYW5kIEZpcmViYXNlIGhvc3RpbmcgaGVhZGVyIChXaGVuIGZvcndhcmVkIHRvIGNsb3VkIGZ1bmN0aW9uKVxuXG5cbiAgICBpZiAoaXMuaXAocmVxLmhlYWRlcnNbJ2Zhc3RseS1jbGllbnQtaXAnXSkpIHtcbiAgICAgIHJldHVybiByZXEuaGVhZGVyc1snZmFzdGx5LWNsaWVudC1pcCddO1xuICAgIH0gLy8gQWthbWFpIGFuZCBDbG91ZGZsYXJlOiBUcnVlLUNsaWVudC1JUC5cblxuXG4gICAgaWYgKGlzLmlwKHJlcS5oZWFkZXJzWyd0cnVlLWNsaWVudC1pcCddKSkge1xuICAgICAgcmV0dXJuIHJlcS5oZWFkZXJzWyd0cnVlLWNsaWVudC1pcCddO1xuICAgIH0gLy8gRGVmYXVsdCBuZ2lueCBwcm94eS9mY2dpOyBhbHRlcm5hdGl2ZSB0byB4LWZvcndhcmRlZC1mb3IsIHVzZWQgYnkgc29tZSBwcm94aWVzLlxuXG5cbiAgICBpZiAoaXMuaXAocmVxLmhlYWRlcnNbJ3gtcmVhbC1pcCddKSkge1xuICAgICAgcmV0dXJuIHJlcS5oZWFkZXJzWyd4LXJlYWwtaXAnXTtcbiAgICB9IC8vIChSYWNrc3BhY2UgTEIgYW5kIFJpdmVyYmVkJ3MgU3RpbmdyYXkpXG4gICAgLy8gaHR0cDovL3d3dy5yYWNrc3BhY2UuY29tL2tub3dsZWRnZV9jZW50ZXIvYXJ0aWNsZS9jb250cm9sbGluZy1hY2Nlc3MtdG8tbGludXgtY2xvdWQtc2l0ZXMtYmFzZWQtb24tdGhlLWNsaWVudC1pcC1hZGRyZXNzXG4gICAgLy8gaHR0cHM6Ly9zcGxhc2gucml2ZXJiZWQuY29tL2RvY3MvRE9DLTE5MjZcblxuXG4gICAgaWYgKGlzLmlwKHJlcS5oZWFkZXJzWyd4LWNsdXN0ZXItY2xpZW50LWlwJ10pKSB7XG4gICAgICByZXR1cm4gcmVxLmhlYWRlcnNbJ3gtY2x1c3Rlci1jbGllbnQtaXAnXTtcbiAgICB9XG5cbiAgICBpZiAoaXMuaXAocmVxLmhlYWRlcnNbJ3gtZm9yd2FyZGVkJ10pKSB7XG4gICAgICByZXR1cm4gcmVxLmhlYWRlcnNbJ3gtZm9yd2FyZGVkJ107XG4gICAgfVxuXG4gICAgaWYgKGlzLmlwKHJlcS5oZWFkZXJzWydmb3J3YXJkZWQtZm9yJ10pKSB7XG4gICAgICByZXR1cm4gcmVxLmhlYWRlcnNbJ2ZvcndhcmRlZC1mb3InXTtcbiAgICB9XG5cbiAgICBpZiAoaXMuaXAocmVxLmhlYWRlcnMuZm9yd2FyZGVkKSkge1xuICAgICAgcmV0dXJuIHJlcS5oZWFkZXJzLmZvcndhcmRlZDtcbiAgICB9XG4gIH0gLy8gUmVtb3RlIGFkZHJlc3MgY2hlY2tzLlxuXG5cbiAgaWYgKGlzLmV4aXN0eShyZXEuY29ubmVjdGlvbikpIHtcbiAgICBpZiAoaXMuaXAocmVxLmNvbm5lY3Rpb24ucmVtb3RlQWRkcmVzcykpIHtcbiAgICAgIHJldHVybiByZXEuY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzO1xuICAgIH1cblxuICAgIGlmIChpcy5leGlzdHkocmVxLmNvbm5lY3Rpb24uc29ja2V0KSAmJiBpcy5pcChyZXEuY29ubmVjdGlvbi5zb2NrZXQucmVtb3RlQWRkcmVzcykpIHtcbiAgICAgIHJldHVybiByZXEuY29ubmVjdGlvbi5zb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICB9XG4gIH1cblxuICBpZiAoaXMuZXhpc3R5KHJlcS5zb2NrZXQpICYmIGlzLmlwKHJlcS5zb2NrZXQucmVtb3RlQWRkcmVzcykpIHtcbiAgICByZXR1cm4gcmVxLnNvY2tldC5yZW1vdGVBZGRyZXNzO1xuICB9XG5cbiAgaWYgKGlzLmV4aXN0eShyZXEuaW5mbykgJiYgaXMuaXAocmVxLmluZm8ucmVtb3RlQWRkcmVzcykpIHtcbiAgICByZXR1cm4gcmVxLmluZm8ucmVtb3RlQWRkcmVzcztcbiAgfSAvLyBBV1MgQXBpIEdhdGV3YXkgKyBMYW1iZGFcblxuXG4gIGlmIChpcy5leGlzdHkocmVxLnJlcXVlc3RDb250ZXh0KSAmJiBpcy5leGlzdHkocmVxLnJlcXVlc3RDb250ZXh0LmlkZW50aXR5KSAmJiBpcy5pcChyZXEucmVxdWVzdENvbnRleHQuaWRlbnRpdHkuc291cmNlSXApKSB7XG4gICAgcmV0dXJuIHJlcS5yZXF1ZXN0Q29udGV4dC5pZGVudGl0eS5zb3VyY2VJcDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBFeHBvc2UgcmVxdWVzdCBJUCBhcyBhIG1pZGRsZXdhcmUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIENvbmZpZ3VyYXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXR0cmlidXRlTmFtZV0gLSBOYW1lIG9mIGF0dHJpYnV0ZSB0byBhdWdtZW50IHJlcXVlc3Qgb2JqZWN0IHdpdGguXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cblxuZnVuY3Rpb24gbXcob3B0aW9ucykge1xuICAvLyBEZWZhdWx0cy5cbiAgdmFyIGNvbmZpZ3VyYXRpb24gPSBpcy5ub3QuZXhpc3R5KG9wdGlvbnMpID8ge30gOiBvcHRpb25zOyAvLyBWYWxpZGF0aW9uLlxuXG4gIGlmIChpcy5ub3Qub2JqZWN0KGNvbmZpZ3VyYXRpb24pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCEnKTtcbiAgfVxuXG4gIHZhciBhdHRyaWJ1dGVOYW1lID0gY29uZmlndXJhdGlvbi5hdHRyaWJ1dGVOYW1lIHx8ICdjbGllbnRJcCc7XG4gIHJldHVybiBmdW5jdGlvbiAocmVxLCByZXMsIG5leHQpIHtcbiAgICB2YXIgaXAgPSBnZXRDbGllbnRJcChyZXEpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXEsIGF0dHJpYnV0ZU5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gaXA7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgbmV4dCgpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q2xpZW50SXBGcm9tWEZvcndhcmRlZEZvcjogZ2V0Q2xpZW50SXBGcm9tWEZvcndhcmRlZEZvcixcbiAgZ2V0Q2xpZW50SXA6IGdldENsaWVudElwLFxuICBtdzogbXdcbn07XG5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/request-ip/dist/index.js\n");

/***/ }),

/***/ "../../node_modules/universalify/index.js":
/*!******************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/universalify/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function () {\n    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)\n    else {\n      return new Promise((resolve, reject) => {\n        arguments[arguments.length] = (err, res) => {\n          if (err) return reject(err)\n          resolve(res)\n        }\n        arguments.length++\n        fn.apply(this, arguments)\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function () {\n    const cb = arguments[arguments.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, arguments)\n    else fn.apply(this, arguments).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3VuaXZlcnNhbGlmeS9pbmRleC5qcz9iYjc5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHLFdBQVcsaUJBQWlCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFdBQVcsaUJBQWlCO0FBQy9CIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy91bml2ZXJzYWxpZnkvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5mcm9tQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aF0gPSAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgICByZXNvbHZlKHJlcylcbiAgICAgICAgfVxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoKytcbiAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG4gIH0sICduYW1lJywgeyB2YWx1ZTogZm4ubmFtZSB9KVxufVxuXG5leHBvcnRzLmZyb21Qcm9taXNlID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGNiID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXVxuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgZWxzZSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4ociA9PiBjYihudWxsLCByKSwgY2IpXG4gIH0sICduYW1lJywgeyB2YWx1ZTogZm4ubmFtZSB9KVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/universalify/index.js\n");

/***/ }),

/***/ "../../node_modules/utf-8-validate/fallback.js":
/*!***********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/utf-8-validate/fallback.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nconst isValidUTF8 = (buf) => {\n  var len = buf.length;\n  var i = 0;\n\n  while (i < len) {\n    if (buf[i] < 0x80) {  // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {  // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0  // overlong\n      ) {\n        return false;\n      } else {\n        i += 2;\n      }\n    } else if ((buf[i] & 0xf0) === 0xe0) {  // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||  // overlong\n        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0     // surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      } else {\n        i += 3;\n      }\n    } else if ((buf[i] & 0xf8) === 0xf0) {  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||  // overlong\n        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4  // > U+10FFFF\n      ) {\n        return false;\n      } else {\n        i += 4;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = isValidUTF8;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3V0Zi04LXZhbGlkYXRlL2ZhbGxiYWNrLmpzP2Y1ZDEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLEtBQUsscUNBQXFDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSyxxQ0FBcUM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSyxxQ0FBcUM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3V0Zi04LXZhbGlkYXRlL2ZhbGxiYWNrLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGJ1ZmZlciBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTguXG4gKiBQb3J0ZWQgZnJvbSBodHRwczovL3d3dy5jbC5jYW0uYWMudWsvJTdFbWdrMjUvdWNzL3V0ZjhfY2hlY2suYyBieVxuICogTWFya3VzIEt1aG4uXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYGJ1ZmAgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgaXNWYWxpZFVURjggPSAoYnVmKSA9PiB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoYnVmW2ldIDwgMHg4MCkgeyAgLy8gMHh4eHh4eHhcbiAgICAgIGkrKztcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGUwKSA9PT0gMHhjMCkgeyAgLy8gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDEgPT09IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gJiAweGZlKSA9PT0gMHhjMCAgLy8gb3ZlcmxvbmdcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpICs9IDI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmMCkgPT09IDB4ZTApIHsgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAyID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgYnVmW2ldID09PSAweGUwICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4ODAgfHwgIC8vIG92ZXJsb25nXG4gICAgICAgIGJ1ZltpXSA9PT0gMHhlZCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweGEwICAgICAvLyBzdXJyb2dhdGUgKFUrRDgwMCAtIFUrREZGRilcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpICs9IDM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmOCkgPT09IDB4ZjApIHsgIC8vIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAzID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgM10gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICBidWZbaV0gPT09IDB4ZjAgJiYgKGJ1ZltpICsgMV0gJiAweGYwKSA9PT0gMHg4MCB8fCAgLy8gb3ZlcmxvbmdcbiAgICAgICAgYnVmW2ldID09PSAweGY0ICYmIGJ1ZltpICsgMV0gPiAweDhmIHx8IGJ1ZltpXSA+IDB4ZjQgIC8vID4gVSsxMEZGRkZcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpICs9IDQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNWYWxpZFVURjg7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/utf-8-validate/fallback.js\n");

/***/ }),

/***/ "../../node_modules/utf-8-validate/index.js":
/*!********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/utf-8-validate/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__dirname) {\n\ntry {\n  module.exports = __webpack_require__(/*! node-gyp-build */ \"../../node_modules/node-gyp-build/index.js\")(__dirname);\n} catch (e) {\n  module.exports = __webpack_require__(/*! ./fallback */ \"../../node_modules/utf-8-validate/fallback.js\");\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, \"../../node_modules/utf-8-validate\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3V0Zi04LXZhbGlkYXRlL2luZGV4LmpzPzVlMzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaURBQWE7O0FBRWI7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxrRUFBZ0I7QUFDM0MsQ0FBQztBQUNELG1CQUFtQixtQkFBTyxDQUFDLGlFQUFZO0FBQ3ZDIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy91dGYtOC12YWxpZGF0ZS9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudHJ5IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdub2RlLWd5cC1idWlsZCcpKF9fZGlybmFtZSk7XG59IGNhdGNoIChlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWxsYmFjaycpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/utf-8-validate/index.js\n");

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-node/index.js":
/*!************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/uuid/dist/esm-node/index.js ***!
  \************************************************************************/
/*! exports provided: v1, v3, v4, v5, NIL, version, validate, stringify, parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"../../node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"v1\", function() { return _v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ \"../../node_modules/uuid/dist/esm-node/v3.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"v3\", function() { return _v3_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ \"../../node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"v4\", function() { return _v4_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ \"../../node_modules/uuid/dist/esm-node/v5.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"v5\", function() { return _v5_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ \"../../node_modules/uuid/dist/esm-node/nil.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NIL\", function() { return _nil_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ \"../../node_modules/uuid/dist/esm-node/version.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return _version_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; });\n\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ \"../../node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"validate\", function() { return _validate_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; });\n\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ \"../../node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"stringify\", function() { return _stringify_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; });\n\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ \"../../node_modules/uuid/dist/esm-node/parse.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return _parse_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; });\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9pbmRleC5qcz9lNGEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDUTtBQUNFO0FBQ0UiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgYXMgdjEgfSBmcm9tICcuL3YxLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjMgfSBmcm9tICcuL3YzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjQgfSBmcm9tICcuL3Y0LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjUgfSBmcm9tICcuL3Y1LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTklMIH0gZnJvbSAnLi9uaWwuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmFsaWRhdGUgfSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXJzZSB9IGZyb20gJy4vcGFyc2UuanMnOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/uuid/dist/esm-node/index.js\n");

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-node/md5.js":
/*!**********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/uuid/dist/esm-node/md5.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default.a.createHash('md5').update(bytes).digest();\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (md5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9tZDUuanM/ZDg1NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLFNBQVMsNkNBQU07QUFDZjs7QUFFZSxrRUFBRyIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL21kNS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzLCAndXRmOCcpO1xuICB9XG5cbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdtZDUnKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZDU7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/uuid/dist/esm-node/md5.js\n");

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-node/nil.js":
/*!**********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/uuid/dist/esm-node/nil.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ('00000000-0000-0000-0000-000000000000');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9uaWwuanM/ZDdjOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFlLHFHQUFzQyIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL25pbC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0ICcwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDAnOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/uuid/dist/esm-node/nil.js\n");

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-node/parse.js":
/*!************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/uuid/dist/esm-node/parse.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"../../node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction parse(uuid) {\n  if (!Object(_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9wYXJzZS5qcz9mOGQ5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBcUM7O0FBRXJDO0FBQ0EsT0FBTyw0REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlLG9FQUFLIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcGFyc2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5cbmZ1bmN0aW9uIHBhcnNlKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICBsZXQgdjtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBQYXJzZSAjIyMjIyMjIy0uLi4uLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMCwgOCksIDE2KSkgPj4+IDI0O1xuICBhcnJbMV0gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsyXSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbM10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tIyMjIy0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzRdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDksIDEzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzVdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tIyMjIy0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls2XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxNCwgMTgpLCAxNikpID4+PiA4O1xuICBhcnJbN10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLSMjIyMtLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzhdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE5LCAyMyksIDE2KSkgPj4+IDg7XG4gIGFycls5XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tLi4uLi0jIyMjIyMjIyMjIyNcbiAgLy8gKFVzZSBcIi9cIiB0byBhdm9pZCAzMi1iaXQgdHJ1bmNhdGlvbiB3aGVuIGJpdC1zaGlmdGluZyBoaWdoLW9yZGVyIGJ5dGVzKVxuXG4gIGFyclsxMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMjQsIDM2KSwgMTYpKSAvIDB4MTAwMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTFdID0gdiAvIDB4MTAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzEyXSA9IHYgPj4+IDI0ICYgMHhmZjtcbiAgYXJyWzEzXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzE0XSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbMTVdID0gdiAmIDB4ZmY7XG4gIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/uuid/dist/esm-node/parse.js\n");

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-node/regex.js":
/*!************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/uuid/dist/esm-node/regex.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9yZWdleC5qcz80YmIyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQWUsNkVBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyx5Q0FBeUMiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9yZWdleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-node/rng.js":
/*!**********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/uuid/dist/esm-node/rng.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return rng; });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8 = new Uint8Array(16);\nfunction rng() {\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default.a.randomFillSync(rnds8);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9ybmcuanM/ZGQzNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUE0QjtBQUM1QjtBQUNlO0FBQ2YsU0FBUyw2Q0FBTTtBQUNmIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuY29uc3Qgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIHJldHVybiBjcnlwdG8ucmFuZG9tRmlsbFN5bmMocm5kczgpO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-node/sha1.js":
/*!***********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/uuid/dist/esm-node/sha1.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default.a.createHash('sha1').update(bytes).digest();\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zaGExLmpzPzQ3MzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxTQUFTLDZDQUFNO0FBQ2Y7O0FBRWUsbUVBQUkiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zaGExLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG5mdW5jdGlvbiBzaGExKGJ5dGVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzLCAndXRmOCcpO1xuICB9XG5cbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKGJ5dGVzKS5kaWdlc3QoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2hhMTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/uuid/dist/esm-node/sha1.js\n");

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-node/stringify.js":
/*!****************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/uuid/dist/esm-node/stringify.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"../../node_modules/uuid/dist/esm-node/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!Object(_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zdHJpbmdpZnkuanM/MGE0NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJnQkFBMmdCO0FBQzNnQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPLDREQUFRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVlLHdFQUFTIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5cbmNvbnN0IGJ5dGVUb0hleCA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICBjb25zdCB1dWlkID0gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpOyAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG5cbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gdXVpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-node/v1.js":
/*!*********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/uuid/dist/esm-node/v1.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"../../node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"../../node_modules/uuid/dist/esm-node/stringify.js\");\n\n // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || Object(_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(b);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92MS5qcz9iMGFkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUEyQjtBQUNZO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFjOzs7QUFHZDtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBOztBQUVBO0FBQ0Esd0RBQXdELCtDQUFHOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBLHVFQUF1RTtBQUN2RTs7QUFFQSwyRUFBMkU7O0FBRTNFLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QiwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QixtQ0FBbUM7O0FBRW5DLDZCQUE2Qjs7QUFFN0IsaUNBQWlDOztBQUVqQywyQkFBMkI7O0FBRTNCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUEsZ0JBQWdCLDZEQUFTO0FBQ3pCOztBQUVlLGlFQUFFIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjEuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnLi9zdHJpbmdpZnkuanMnOyAvLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbmxldCBfbm9kZUlkO1xuXG5sZXQgX2Nsb2Nrc2VxOyAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcblxuXG5sZXQgX2xhc3RNU2VjcyA9IDA7XG5sZXQgX2xhc3ROU2VjcyA9IDA7IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5cbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGxldCBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICBjb25zdCBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICBsZXQgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICBjb25zdCBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgbGV0IG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICBsZXQgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICBjb25zdCBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7IC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9IC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcblxuXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9IC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcblxuXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxOyAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcblxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDsgLy8gYHRpbWVfbG93YFxuXG4gIGNvbnN0IHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIGNvbnN0IHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgc3RyaW5naWZ5KGIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2MTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/uuid/dist/esm-node/v1.js\n");

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-node/v3.js":
/*!*********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/uuid/dist/esm-node/v3.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"../../node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"../../node_modules/uuid/dist/esm-node/md5.js\");\n\n\nconst v3 = Object(_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ __webpack_exports__[\"default\"] = (v3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92My5qcz8xYjFlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUEyQjtBQUNBO0FBQzNCLFdBQVcsdURBQUcsYUFBYSwrQ0FBRztBQUNmLGlFQUFFIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBtZDUgZnJvbSAnLi9tZDUuanMnO1xuY29uc3QgdjMgPSB2MzUoJ3YzJywgMHgzMCwgbWQ1KTtcbmV4cG9ydCBkZWZhdWx0IHYzOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/uuid/dist/esm-node/v3.js\n");

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-node/v35.js":
/*!**********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/uuid/dist/esm-node/v35.js ***!
  \**********************************************************************/
/*! exports provided: DNS, URL, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DNS\", function() { return DNS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"URL\", function() { return URL; });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stringify.js */ \"../../node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ \"../../node_modules/uuid/dist/esm-node/parse.js\");\n\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = Object(_parse_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return Object(_stringify_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92MzUuanM/ODE2MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXVDO0FBQ1I7O0FBRS9CO0FBQ0EsMENBQTBDOztBQUUxQzs7QUFFQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNBO0FBQ1E7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix5REFBSztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLDZEQUFTO0FBQ3BCLEdBQUc7OztBQUdIO0FBQ0EsNkJBQTZCO0FBQzdCLEdBQUcsZUFBZTs7O0FBR2xCO0FBQ0E7QUFDQTtBQUNBLEMiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92MzUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCBwYXJzZSBmcm9tICcuL3BhcnNlLmpzJztcblxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIGNvbnN0IGJ5dGVzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn1cblxuZXhwb3J0IGNvbnN0IEROUyA9ICc2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGNvbnN0IFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNwYWNlID0gcGFyc2UobmFtZXNwYWNlKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZXNwYWNlLmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTmFtZXNwYWNlIG11c3QgYmUgYXJyYXktbGlrZSAoMTYgaXRlcmFibGUgaW50ZWdlciB2YWx1ZXMsIDAtMjU1KScpO1xuICAgIH0gLy8gQ29tcHV0ZSBoYXNoIG9mIG5hbWVzcGFjZSBhbmQgdmFsdWUsIFBlciA0LjNcbiAgICAvLyBGdXR1cmU6IFVzZSBzcHJlYWQgc3ludGF4IHdoZW4gc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMsIGUuZy4gYGJ5dGVzID1cbiAgICAvLyBoYXNoZnVuYyhbLi4ubmFtZXNwYWNlLCAuLi4gdmFsdWVdKWBcblxuXG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYgKyB2YWx1ZS5sZW5ndGgpO1xuICAgIGJ5dGVzLnNldChuYW1lc3BhY2UpO1xuICAgIGJ5dGVzLnNldCh2YWx1ZSwgbmFtZXNwYWNlLmxlbmd0aCk7XG4gICAgYnl0ZXMgPSBoYXNoZnVuYyhieXRlcyk7XG4gICAgYnl0ZXNbNl0gPSBieXRlc1s2XSAmIDB4MGYgfCB2ZXJzaW9uO1xuICAgIGJ5dGVzWzhdID0gYnl0ZXNbOF0gJiAweDNmIHwgMHg4MDtcblxuICAgIGlmIChidWYpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgYnVmW29mZnNldCArIGldID0gYnl0ZXNbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ2lmeShieXRlcyk7XG4gIH0gLy8gRnVuY3Rpb24jbmFtZSBpcyBub3Qgc2V0dGFibGUgb24gc29tZSBwbGF0Zm9ybXMgKCMyNzApXG5cblxuICB0cnkge1xuICAgIGdlbmVyYXRlVVVJRC5uYW1lID0gbmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gIH0gY2F0Y2ggKGVycikge30gLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcblxuXG4gIGdlbmVyYXRlVVVJRC5ETlMgPSBETlM7XG4gIGdlbmVyYXRlVVVJRC5VUkwgPSBVUkw7XG4gIHJldHVybiBnZW5lcmF0ZVVVSUQ7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/uuid/dist/esm-node/v35.js\n");

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-node/v4.js":
/*!*********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/uuid/dist/esm-node/v4.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"../../node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"../../node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return Object(_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(rnds);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92NC5qcz8wY2VkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUEyQjtBQUNZOztBQUV2QztBQUNBO0FBQ0EsaURBQWlELCtDQUFHLElBQUk7O0FBRXhEO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLDZEQUFTO0FBQ2xCOztBQUVlLGlFQUFFIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdpZnkocm5kcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHY0OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-node/v5.js":
/*!*********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/uuid/dist/esm-node/v5.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"../../node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"../../node_modules/uuid/dist/esm-node/sha1.js\");\n\n\nconst v5 = Object(_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ __webpack_exports__[\"default\"] = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92NS5qcz83NDIzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUEyQjtBQUNFO0FBQzdCLFdBQVcsdURBQUcsYUFBYSxnREFBSTtBQUNoQixpRUFBRSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y1LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHYzNSBmcm9tICcuL3YzNS5qcyc7XG5pbXBvcnQgc2hhMSBmcm9tICcuL3NoYTEuanMnO1xuY29uc3QgdjUgPSB2MzUoJ3Y1JywgMHg1MCwgc2hhMSk7XG5leHBvcnQgZGVmYXVsdCB2NTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/uuid/dist/esm-node/v5.js\n");

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-node/validate.js":
/*!***************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/uuid/dist/esm-node/validate.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"../../node_modules/uuid/dist/esm-node/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92YWxpZGF0ZS5qcz8yZWI4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBK0I7O0FBRS9CO0FBQ0EscUNBQXFDLGlEQUFLO0FBQzFDOztBQUVlLHVFQUFRIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUkVHRVggZnJvbSAnLi9yZWdleC5qcyc7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBSRUdFWC50ZXN0KHV1aWQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "../../node_modules/uuid/dist/esm-node/version.js":
/*!**************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/uuid/dist/esm-node/version.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"../../node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction version(uuid) {\n  if (!Object(_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (version);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92ZXJzaW9uLmpzP2JmZTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFxQzs7QUFFckM7QUFDQSxPQUFPLDREQUFRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVlLHNFQUFPIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmVyc2lvbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuZnVuY3Rpb24gdmVyc2lvbih1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KHV1aWQuc3Vic3RyKDE0LCAxKSwgMTYpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2ZXJzaW9uOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/uuid/dist/esm-node/version.js\n");

/***/ }),

/***/ "../../node_modules/ws/index.js":
/*!********************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/ws/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst WebSocket = __webpack_require__(/*! ./lib/websocket */ \"../../node_modules/ws/lib/websocket.js\");\n\nWebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ \"../../node_modules/ws/lib/stream.js\");\nWebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ \"../../node_modules/ws/lib/websocket-server.js\");\nWebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ \"../../node_modules/ws/lib/receiver.js\");\nWebSocket.Sender = __webpack_require__(/*! ./lib/sender */ \"../../node_modules/ws/lib/sender.js\");\n\nmodule.exports = WebSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3dzL2luZGV4LmpzP2MxMDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsK0RBQWlCOztBQUUzQyxrQ0FBa0MsbUJBQU8sQ0FBQyx5REFBYztBQUN4RCxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBd0I7QUFDbkQscUJBQXFCLG1CQUFPLENBQUMsNkRBQWdCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLHlEQUFjOztBQUV6QyIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvd3MvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJy4vbGliL3dlYnNvY2tldCcpO1xuXG5XZWJTb2NrZXQuY3JlYXRlV2ViU29ja2V0U3RyZWFtID0gcmVxdWlyZSgnLi9saWIvc3RyZWFtJyk7XG5XZWJTb2NrZXQuU2VydmVyID0gcmVxdWlyZSgnLi9saWIvd2Vic29ja2V0LXNlcnZlcicpO1xuV2ViU29ja2V0LlJlY2VpdmVyID0gcmVxdWlyZSgnLi9saWIvcmVjZWl2ZXInKTtcbldlYlNvY2tldC5TZW5kZXIgPSByZXF1aXJlKCcuL2xpYi9zZW5kZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/ws/index.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/buffer-util.js":
/*!******************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/ws/lib/buffer-util.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"../../node_modules/ws/lib/constants.js\");\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) return target.slice(0, offset);\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n  for (let i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = Buffer.from(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\ntry {\n  const bufferUtil = __webpack_require__(/*! bufferutil */ \"../../node_modules/bufferutil/index.js\");\n  const bu = bufferUtil.BufferUtil || bufferUtil;\n\n  module.exports = {\n    concat,\n    mask(source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bu.mask(source, mask, output, offset, length);\n    },\n    toArrayBuffer,\n    toBuffer,\n    unmask(buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bu.unmask(buffer, mask);\n    }\n  };\n} catch (e) /* istanbul ignore next */ {\n  module.exports = {\n    concat,\n    mask: _mask,\n    toArrayBuffer,\n    toBuffer,\n    unmask: _unmask\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3dzL2xpYi9idWZmZXItdXRpbC5qcz80YjQwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLE9BQU8sZUFBZSxHQUFHLG1CQUFPLENBQUMsMkRBQWE7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsMERBQVk7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy93cy9saWIvYnVmZmVyLXV0aWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG4vKipcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiBidWZmZXJzIGludG8gYSBuZXcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGFycmF5IG9mIGJ1ZmZlcnMgdG8gY29uY2F0XG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGggVGhlIHRvdGFsIGxlbmd0aCBvZiBidWZmZXJzIGluIHRoZSBsaXN0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSByZXN1bHRpbmcgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWV9CVUZGRVI7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIGxpc3RbMF07XG5cbiAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICB0YXJnZXQuc2V0KGJ1Ziwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCB0b3RhbExlbmd0aCkgcmV0dXJuIHRhcmdldC5zbGljZSgwLCBvZmZzZXQpO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogTWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZSBUaGUgYnVmZmVyIHRvIG1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gbWFzay5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBzb3VyY2VbaV0gXiBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHVubWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF91bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gIC8vIFJlcXVpcmVkIHVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvOTAwNiBpcyByZXNvbHZlZC5cbiAgY29uc3QgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGJ1ZmZlcltpXSBePSBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYnVmZmVyIHRvIGFuIGBBcnJheUJ1ZmZlcmAuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBDb252ZXJ0ZWQgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmKSB7XG4gIGlmIChidWYuYnl0ZUxlbmd0aCA9PT0gYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJ1Zi5idWZmZXI7XG4gIH1cblxuICByZXR1cm4gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYuYnl0ZUxlbmd0aCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGRhdGFgIHRvIGEgYEJ1ZmZlcmAuXG4gKlxuICogQHBhcmFtIHsqfSBkYXRhIFRoZSBkYXRhIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGJ1ZmZlclxuICogQHRocm93cyB7VHlwZUVycm9yfVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b0J1ZmZlcihkYXRhKSB7XG4gIHRvQnVmZmVyLnJlYWRPbmx5ID0gdHJ1ZTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSByZXR1cm4gZGF0YTtcblxuICBsZXQgYnVmO1xuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgIHRvQnVmZmVyLnJlYWRPbmx5ID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gYnVmO1xufVxuXG50cnkge1xuICBjb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnYnVmZmVydXRpbCcpO1xuICBjb25zdCBidSA9IGJ1ZmZlclV0aWwuQnVmZmVyVXRpbCB8fCBidWZmZXJVdGlsO1xuXG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvbmNhdCxcbiAgICBtYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA8IDQ4KSBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgZWxzZSBidS5tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgfSxcbiAgICB0b0FycmF5QnVmZmVyLFxuICAgIHRvQnVmZmVyLFxuICAgIHVubWFzayhidWZmZXIsIG1hc2spIHtcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoIDwgMzIpIF91bm1hc2soYnVmZmVyLCBtYXNrKTtcbiAgICAgIGVsc2UgYnUudW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgfVxuICB9O1xufSBjYXRjaCAoZSkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge1xuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb25jYXQsXG4gICAgbWFzazogX21hc2ssXG4gICAgdG9BcnJheUJ1ZmZlcixcbiAgICB0b0J1ZmZlcixcbiAgICB1bm1hc2s6IF91bm1hc2tcbiAgfTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/buffer-util.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/constants.js":
/*!****************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/ws/lib/constants.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  EMPTY_BUFFER: Buffer.alloc(0),\n  NOOP: () => {}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3dzL2xpYi9jb25zdGFudHMuanM/YTIyZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy93cy9saWIvY29uc3RhbnRzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQklOQVJZX1RZUEVTOiBbJ25vZGVidWZmZXInLCAnYXJyYXlidWZmZXInLCAnZnJhZ21lbnRzJ10sXG4gIEdVSUQ6ICcyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTEnLFxuICBrU3RhdHVzQ29kZTogU3ltYm9sKCdzdGF0dXMtY29kZScpLFxuICBrV2ViU29ja2V0OiBTeW1ib2woJ3dlYnNvY2tldCcpLFxuICBFTVBUWV9CVUZGRVI6IEJ1ZmZlci5hbGxvYygwKSxcbiAgTk9PUDogKCkgPT4ge31cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/constants.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/event-target.js":
/*!*******************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/ws/lib/event-target.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Class representing an event.\n *\n * @private\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} target A reference to the target to which the event was dispatched\n   */\n  constructor(type, target) {\n    this.target = target;\n    this.type = type;\n  }\n}\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n * @private\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(data, target) {\n    super('message', target);\n\n    this.data = data;\n  }\n}\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n * @private\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {Number} code The status code explaining why the connection is being closed\n   * @param {String} reason A human-readable string explaining why the connection is closing\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(code, reason, target) {\n    super('close', target);\n\n    this.wasClean = target._closeFrameReceived && target._closeFrameSent;\n    this.reason = reason;\n    this.code = code;\n  }\n}\n\n/**\n * Class representing an open event.\n *\n * @extends Event\n * @private\n */\nclass OpenEvent extends Event {\n  /**\n   * Create a new `OpenEvent`.\n   *\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(target) {\n    super('open', target);\n  }\n}\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n * @private\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {Object} error The error that generated this event\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(error, target) {\n    super('error', target);\n\n    this.message = error.message;\n    this.error = error;\n  }\n}\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @param {Object} options An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} options.once A `Boolean`` indicating that the listener\n   *     should be invoked at most once after being added. If `true`, the\n   *     listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, listener, options) {\n    if (typeof listener !== 'function') return;\n\n    function onMessage(data) {\n      listener.call(this, new MessageEvent(data, this));\n    }\n\n    function onClose(code, message) {\n      listener.call(this, new CloseEvent(code, message, this));\n    }\n\n    function onError(error) {\n      listener.call(this, new ErrorEvent(error, this));\n    }\n\n    function onOpen() {\n      listener.call(this, new OpenEvent(this));\n    }\n\n    const method = options && options.once ? 'once' : 'on';\n\n    if (type === 'message') {\n      onMessage._listener = listener;\n      this[method](type, onMessage);\n    } else if (type === 'close') {\n      onClose._listener = listener;\n      this[method](type, onClose);\n    } else if (type === 'error') {\n      onError._listener = listener;\n      this[method](type, onError);\n    } else if (type === 'open') {\n      onOpen._listener = listener;\n      this[method](type, onOpen);\n    } else {\n      this[method](type, listener);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {Function} listener The listener to remove\n   * @public\n   */\n  removeEventListener(type, listener) {\n    const listeners = this.listeners(type);\n\n    for (let i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener || listeners[i]._listener === listener) {\n        this.removeListener(type, listeners[i]);\n      }\n    }\n  }\n};\n\nmodule.exports = EventTarget;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3dzL2xpYi9ldmVudC10YXJnZXQuanM/NjdlNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xELGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvd3MvbGliL2V2ZW50LXRhcmdldC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhcyBkaXNwYXRjaGVkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbWVzc2FnZSBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBNZXNzYWdlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyfEFycmF5QnVmZmVyfEJ1ZmZlcltdKX0gZGF0YSBUaGUgcmVjZWl2ZWQgZGF0YVxuICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhcyBkaXNwYXRjaGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhLCB0YXJnZXQpIHtcbiAgICBzdXBlcignbWVzc2FnZScsIHRhcmdldCk7XG5cbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY2xvc2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYENsb3NlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGUgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgYmVpbmcgY2xvc2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb24gQSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhcyBkaXNwYXRjaGVkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2RlLCByZWFzb24sIHRhcmdldCkge1xuICAgIHN1cGVyKCdjbG9zZScsIHRhcmdldCk7XG5cbiAgICB0aGlzLndhc0NsZWFuID0gdGFyZ2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgJiYgdGFyZ2V0Ll9jbG9zZUZyYW1lU2VudDtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIG9wZW4gZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIE9wZW5FdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgT3BlbkV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHRhcmdldCBBIHJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHRvIHdoaWNoIHRoZSBldmVudCB3YXMgZGlzcGF0Y2hlZFxuICAgKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgc3VwZXIoJ29wZW4nLCB0YXJnZXQpO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGVycm9yIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFcnJvckV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVycm9yIFRoZSBlcnJvciB0aGF0IGdlbmVyYXRlZCB0aGlzIGV2ZW50XG4gICAqIEBwYXJhbSB7V2ViU29ja2V0fSB0YXJnZXQgQSByZWZlcmVuY2UgdG8gdGhlIHRhcmdldCB0byB3aGljaCB0aGUgZXZlbnQgd2FzIGRpc3BhdGNoZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVycm9yLCB0YXJnZXQpIHtcbiAgICBzdXBlcignZXJyb3InLCB0YXJnZXQpO1xuXG4gICAgdGhpcy5tZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGVtdWxhdGluZyB0aGUgYEV2ZW50VGFyZ2V0YCBpbnRlcmZhY2UuIEl0J3Mgbm90XG4gKiBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEBtaXhpblxuICovXG5jb25zdCBFdmVudFRhcmdldCA9IHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gYWRkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXRcbiAgICogICAgIHRoZSBldmVudCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMub25jZSBBIGBCb29sZWFuYGAgaW5kaWNhdGluZyB0aGF0IHRoZSBsaXN0ZW5lclxuICAgKiAgICAgc2hvdWxkIGJlIGludm9rZWQgYXQgbW9zdCBvbmNlIGFmdGVyIGJlaW5nIGFkZGVkLiBJZiBgdHJ1ZWAsIHRoZVxuICAgKiAgICAgbGlzdGVuZXIgd291bGQgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIHdoZW4gaW52b2tlZC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHJldHVybjtcblxuICAgIGZ1bmN0aW9uIG9uTWVzc2FnZShkYXRhKSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIG5ldyBNZXNzYWdlRXZlbnQoZGF0YSwgdGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2xvc2UoY29kZSwgbWVzc2FnZSkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBuZXcgQ2xvc2VFdmVudChjb2RlLCBtZXNzYWdlLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBuZXcgRXJyb3JFdmVudChlcnJvciwgdGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgbmV3IE9wZW5FdmVudCh0aGlzKSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWV0aG9kID0gb3B0aW9ucyAmJiBvcHRpb25zLm9uY2UgPyAnb25jZScgOiAnb24nO1xuXG4gICAgaWYgKHR5cGUgPT09ICdtZXNzYWdlJykge1xuICAgICAgb25NZXNzYWdlLl9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgdGhpc1ttZXRob2RdKHR5cGUsIG9uTWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2xvc2UnKSB7XG4gICAgICBvbkNsb3NlLl9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgdGhpc1ttZXRob2RdKHR5cGUsIG9uQ2xvc2UpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgb25FcnJvci5fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgIHRoaXNbbWV0aG9kXSh0eXBlLCBvbkVycm9yKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGVuJykge1xuICAgICAgb25PcGVuLl9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgdGhpc1ttZXRob2RdKHR5cGUsIG9uT3Blbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbWV0aG9kXSh0eXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIHJlbW92ZVxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnModHlwZSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdGVuZXJzW2ldLl9saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/event-target.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/extension.js":
/*!****************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/ws/lib/extension.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n\n  if (header === undefined || header === '') return offers;\n\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\\t' */) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3dzL2xpYi9leHRlbnNpb24uanM/ZTgyMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyx3QkFBd0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxtQkFBbUI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTyw2QkFBNkI7QUFDcEM7QUFDQSxpRUFBaUUsRUFBRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsK0RBQStELEVBQUU7QUFDakU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLGlFQUFpRSxFQUFFO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsK0RBQStELEVBQUU7QUFDakU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsaUVBQWlFLEVBQUU7QUFDbkU7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpRUFBaUUsRUFBRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCwrREFBK0QsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxFQUFFLEdBQUcsRUFBRTtBQUMxRCwwQkFBMEI7QUFDMUIsZUFBZTtBQUNmO0FBQ0Esb0JBQW9CO0FBQ3BCLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGtCQUFrQiIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvd3MvbGliL2V4dGVuc2lvbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy9cbi8vIEFsbG93ZWQgdG9rZW4gY2hhcmFjdGVyczpcbi8vXG4vLyAnIScsICcjJywgJyQnLCAnJScsICcmJywgJycnLCAnKicsICcrJywgJy0nLFxuLy8gJy4nLCAwLTksIEEtWiwgJ14nLCAnXycsICdgJywgYS16LCAnfCcsICd+J1xuLy9cbi8vIHRva2VuQ2hhcnNbMzJdID09PSAwIC8vICcgJ1xuLy8gdG9rZW5DaGFyc1szM10gPT09IDEgLy8gJyEnXG4vLyB0b2tlbkNoYXJzWzM0XSA9PT0gMCAvLyAnXCInXG4vLyAuLi5cbi8vXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHRva2VuQ2hhcnMgPSBbXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDAgLSAxNVxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAxNiAtIDMxXG4gIDAsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDAsIDEsIDEsIDAsIC8vIDMyIC0gNDdcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gNDggLSA2M1xuICAwLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA2NCAtIDc5XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDEsIDEsIC8vIDgwIC0gOTVcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gOTYgLSAxMTFcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMSwgMCAvLyAxMTIgLSAxMjdcbl07XG5cbi8qKlxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxuICogcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdXNoKGRlc3QsIG5hbWUsIGVsZW0pIHtcbiAgaWYgKGRlc3RbbmFtZV0gPT09IHVuZGVmaW5lZCkgZGVzdFtuYW1lXSA9IFtlbGVtXTtcbiAgZWxzZSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgaW50byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGFyc2VkIG9iamVjdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3Qgb2ZmZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBpZiAoaGVhZGVyID09PSB1bmRlZmluZWQgfHwgaGVhZGVyID09PSAnJykgcmV0dXJuIG9mZmVycztcblxuICBsZXQgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IG11c3RVbmVzY2FwZSA9IGZhbHNlO1xuICBsZXQgaXNFc2NhcGluZyA9IGZhbHNlO1xuICBsZXQgaW5RdW90ZXMgPSBmYWxzZTtcbiAgbGV0IGV4dGVuc2lvbk5hbWU7XG4gIGxldCBwYXJhbU5hbWU7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKDsgaSA8IGhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBoZWFkZXIuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5IC8qICdcXHQnICovKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiAvKiAnOycgKi8gfHwgY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIG5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICBwdXNoKHBhcmFtcywgaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpLCB0cnVlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNkIC8qICc9JyAqLyAmJiBzdGFydCAhPT0gLTEgJiYgZW5kID09PSAtMSkge1xuICAgICAgICBwYXJhbU5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgdmFsdWUgb2YgYSBxdW90ZWQtc3RyaW5nIGFmdGVyIHVuZXNjYXBpbmcgbXVzdCBjb25mb3JtIHRvIHRoZVxuICAgICAgLy8gdG9rZW4gQUJORiwgc28gb25seSB0b2tlbiBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcbiAgICAgIC8vXG4gICAgICBpZiAoaXNFc2NhcGluZykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgZWxzZSBpZiAoIW11c3RVbmVzY2FwZSkgbXVzdFVuZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgaXNFc2NhcGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpblF1b3Rlcykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyIC8qICdcIicgKi8gJiYgc3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgaW5RdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NWMgLyogJ1xcJyAqLykge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgJiYgaGVhZGVyLmNoYXJDb2RlQXQoaSAtIDEpID09PSAweDNkKSB7XG4gICAgICAgIGluUXVvdGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQgIT09IC0xICYmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgICAgICAgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdmFsdWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgaW5RdW90ZXMpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgY29uc3QgdG9rZW4gPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBwdXNoKG9mZmVycywgdG9rZW4sIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdXNoKHBhcmFtcywgdG9rZW4sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbi5yZXBsYWNlKC9cXFxcL2csICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcbiAgICB9XG4gICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gb2ZmZXJzO1xufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBtYXAgb2YgZXh0ZW5zaW9ucyBhbmQgcGFyYW1ldGVycyB0byBmb3JtYXRcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpXG4gICAgLm1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlndXJhdGlvbnMpKSBjb25maWd1cmF0aW9ucyA9IFtjb25maWd1cmF0aW9uc107XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbnNcbiAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25dXG4gICAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBwYXJhbXNba107XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+ICh2ID09PSB0cnVlID8gayA6IGAke2t9PSR7dn1gKSlcbiAgICAgICAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJzsgJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcsICcpO1xuICAgIH0pXG4gICAgLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/extension.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/limiter.js":
/*!**************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/ws/lib/limiter.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} concurrency The maximum number of jobs allowed to run\n   *     concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\n\nmodule.exports = Limiter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3dzL2xpYi9saW1pdGVyLmpzP2QzZWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvd3MvbGliL2xpbWl0ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGtEb25lID0gU3ltYm9sKCdrRG9uZScpO1xuY29uc3Qga1J1biA9IFN5bWJvbCgna1J1bicpO1xuXG4vKipcbiAqIEEgdmVyeSBzaW1wbGUgam9iIHF1ZXVlIHdpdGggYWRqdXN0YWJsZSBjb25jdXJyZW5jeS4gQWRhcHRlZCBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU1RSTUwvYXN5bmMtbGltaXRlclxuICovXG5jbGFzcyBMaW1pdGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYExpbWl0ZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29uY3VycmVuY3kgVGhlIG1heGltdW0gbnVtYmVyIG9mIGpvYnMgYWxsb3dlZCB0byBydW5cbiAgICogICAgIGNvbmN1cnJlbnRseVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uY3VycmVuY3kpIHtcbiAgICB0aGlzW2tEb25lXSA9ICgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZy0tO1xuICAgICAgdGhpc1trUnVuXSgpO1xuICAgIH07XG4gICAgdGhpcy5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5IHx8IEluZmluaXR5O1xuICAgIHRoaXMuam9icyA9IFtdO1xuICAgIHRoaXMucGVuZGluZyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGpvYiB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZChqb2IpIHtcbiAgICB0aGlzLmpvYnMucHVzaChqb2IpO1xuICAgIHRoaXNba1J1bl0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgam9iIGZyb20gdGhlIHF1ZXVlIGFuZCBydW5zIGl0IGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW2tSdW5dKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmcgPT09IHRoaXMuY29uY3VycmVuY3kpIHJldHVybjtcblxuICAgIGlmICh0aGlzLmpvYnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBqb2IgPSB0aGlzLmpvYnMuc2hpZnQoKTtcblxuICAgICAgdGhpcy5wZW5kaW5nKys7XG4gICAgICBqb2IodGhpc1trRG9uZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbWl0ZXI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/limiter.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/permessage-deflate.js":
/*!*************************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/ws/lib/permessage-deflate.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"../../node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"../../node_modules/ws/lib/limiter.js\");\nconst { kStatusCode, NOOP } = __webpack_require__(/*! ./constants */ \"../../node_modules/ws/lib/constants.js\");\n\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling\n   *     of server context takeover\n   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge\n   *     disabling of client context takeover\n   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the\n   *     use of a custom server window size\n   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support\n   *     for, or request, a custom client window size\n   * @param {Object} options.zlibDeflateOptions Options to pass to zlib on deflate\n   * @param {Object} options.zlibInflateOptions Options to pass to zlib on inflate\n   * @param {Number} options.threshold Size (in bytes) below which messages\n   *     should not be compressed\n   * @param {Number} options.concurrencyLimit The number of concurrent calls to\n   *     zlib\n   * @param {Boolean} isServer Create the instance in either server or client\n   *     mode\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n\n      this._deflate.close();\n      this._deflate = null;\n\n      if (callback) {\n        callback(\n          new Error(\n            'The deflate stream was closed while data was being processed'\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      //\n      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the\n      // `zlib.DeflateRaw` instance is closed while data is being processed.\n      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong\n      // time due to an abnormal WebSocket closure.\n      //\n      this._deflate.on('error', NOOP);\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) data = data.slice(0, data.length - 4);\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.close();\n        this._deflate = null;\n      } else {\n        this._deflate[kTotalLength] = 0;\n        this._deflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3dzL2xpYi9wZXJtZXNzYWdlLWRlZmxhdGUuanM/Yjc3NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCLG1CQUFtQixtQkFBTyxDQUFDLCtEQUFlO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLHVEQUFXO0FBQ25DLE9BQU8sb0JBQW9CLEdBQUcsbUJBQU8sQ0FBQywyREFBYTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNu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QUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy93cy9saWIvcGVybWVzc2FnZS1kZWZsYXRlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuXG5jb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgTGltaXRlciA9IHJlcXVpcmUoJy4vbGltaXRlcicpO1xuY29uc3QgeyBrU3RhdHVzQ29kZSwgTk9PUCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3QgVFJBSUxFUiA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweGZmLCAweGZmXSk7XG5jb25zdCBrUGVyTWVzc2FnZURlZmxhdGUgPSBTeW1ib2woJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qga1RvdGFsTGVuZ3RoID0gU3ltYm9sKCd0b3RhbC1sZW5ndGgnKTtcbmNvbnN0IGtDYWxsYmFjayA9IFN5bWJvbCgnY2FsbGJhY2snKTtcbmNvbnN0IGtCdWZmZXJzID0gU3ltYm9sKCdidWZmZXJzJyk7XG5jb25zdCBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG5cbi8vXG4vLyBXZSBsaW1pdCB6bGliIGNvbmN1cnJlbmN5LCB3aGljaCBwcmV2ZW50cyBzZXZlcmUgbWVtb3J5IGZyYWdtZW50YXRpb25cbi8vIGFzIGRvY3VtZW50ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84ODcxI2lzc3VlY29tbWVudC0yNTA5MTU5MTNcbi8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTIwMlxuLy9cbi8vIEludGVudGlvbmFsbHkgZ2xvYmFsOyBpdCdzIHRoZSBnbG9iYWwgdGhyZWFkIHBvb2wgdGhhdCdzIGFuIGlzc3VlLlxuLy9cbmxldCB6bGliTGltaXRlcjtcblxuLyoqXG4gKiBwZXJtZXNzYWdlLWRlZmxhdGUgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFBlck1lc3NhZ2VEZWZsYXRlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQZXJNZXNzYWdlRGVmbGF0ZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciBSZXF1ZXN0L2FjY2VwdCBkaXNhYmxpbmdcbiAgICogICAgIG9mIHNlcnZlciBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciBBZHZlcnRpc2UvYWNrbm93bGVkZ2VcbiAgICogICAgIGRpc2FibGluZyBvZiBjbGllbnQgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IG9wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cyBSZXF1ZXN0L2NvbmZpcm0gdGhlXG4gICAqICAgICB1c2Ugb2YgYSBjdXN0b20gc2VydmVyIHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzIEFkdmVydGlzZSBzdXBwb3J0XG4gICAqICAgICBmb3IsIG9yIHJlcXVlc3QsIGEgY3VzdG9tIGNsaWVudCB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb24gZGVmbGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb24gaW5mbGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy50aHJlc2hvbGQgU2l6ZSAoaW4gYnl0ZXMpIGJlbG93IHdoaWNoIG1lc3NhZ2VzXG4gICAqICAgICBzaG91bGQgbm90IGJlIGNvbXByZXNzZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuY29uY3VycmVuY3lMaW1pdCBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgY2FsbHMgdG9cbiAgICogICAgIHpsaWJcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1NlcnZlciBDcmVhdGUgdGhlIGluc3RhbmNlIGluIGVpdGhlciBzZXJ2ZXIgb3IgY2xpZW50XG4gICAqICAgICBtb2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhQYXlsb2FkIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX3RocmVzaG9sZCA9XG4gICAgICB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgOiAxMDI0O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFpc1NlcnZlcjtcbiAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcblxuICAgIHRoaXMucGFyYW1zID0gbnVsbDtcblxuICAgIGlmICghemxpYkxpbWl0ZXIpIHtcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID1cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdFxuICAgICAgICAgIDogMTA7XG4gICAgICB6bGliTGltaXRlciA9IG5ldyBMaW1pdGVyKGNvbmN1cnJlbmN5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZXh0ZW5zaW9uTmFtZSgpIHtcbiAgICByZXR1cm4gJ3Blcm1lc3NhZ2UtZGVmbGF0ZSc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBFeHRlbnNpb24gcGFyYW1ldGVyc1xuICAgKiBAcHVibGljXG4gICAqL1xuICBvZmZlcigpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09IG51bGwpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIvcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFjY2VwdChjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zID0gdGhpcy5ub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgdGhpcy5wYXJhbXMgPSB0aGlzLl9pc1NlcnZlclxuICAgICAgPyB0aGlzLmFjY2VwdEFzU2VydmVyKGNvbmZpZ3VyYXRpb25zKVxuICAgICAgOiB0aGlzLmFjY2VwdEFzQ2xpZW50KGNvbmZpZ3VyYXRpb25zKTtcblxuICAgIHJldHVybiB0aGlzLnBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbGwgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGV4dGVuc2lvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5faW5mbGF0ZSkge1xuICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQnXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAgQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gb2ZmZXJzIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNTZXJ2ZXIob2ZmZXJzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMuX29wdGlvbnM7XG4gICAgY29uc3QgYWNjZXB0ZWQgPSBvZmZlcnMuZmluZCgocGFyYW1zKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcikgfHxcbiAgICAgICAgKHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzICYmXG4gICAgICAgICAgKG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPiBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cykpKSB8fFxuICAgICAgICAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAhcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGlmICghYWNjZXB0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9uZSBvZiB0aGUgZXh0ZW5zaW9uIG9mZmVycyBjYW4gYmUgYWNjZXB0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0cy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9IG9wdHMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9PT0gdHJ1ZSB8fFxuICAgICAgb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZVxuICAgICkge1xuICAgICAgZGVsZXRlIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY2VwdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCB0aGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSByZXNwb25zZSBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNDbGllbnQocmVzcG9uc2UpIHtcbiAgICBjb25zdCBwYXJhbXMgPSByZXNwb25zZVswXTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBwYXJhbWV0ZXIgXCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclwiJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG4gICAgICAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVbmV4cGVjdGVkIG9yIGludmFsaWQgcGFyYW1ldGVyIFwiY2xpZW50X21heF93aW5kb3dfYml0c1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgb2ZmZXJzL3Jlc3BvbnNlIHdpdGggbm9ybWFsaXplZCBwYXJhbWV0ZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucy5mb3JFYWNoKChwYXJhbXMpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJhbWV0ZXIgXCIke2tleX1cIiBtdXN0IGhhdmUgb25seSBhIHNpbmdsZSB2YWx1ZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnY2xpZW50X21heF93aW5kb3dfYml0cycpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInIHx8XG4gICAgICAgICAga2V5ID09PSAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbWV0ZXIgXCIke2tleX1cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fZGVjb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnY2xpZW50JyA6ICdzZXJ2ZXInO1xuXG4gICAgaWYgKCF0aGlzLl9pbmZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2luZmxhdGUgPSB6bGliLmNyZWF0ZUluZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tQZXJNZXNzYWdlRGVmbGF0ZV0gPSB0aGlzO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdlcnJvcicsIGluZmxhdGVPbkVycm9yKTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbmZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2luZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgaWYgKGZpbikgdGhpcy5faW5mbGF0ZS53cml0ZShUUkFJTEVSKTtcblxuICAgIHRoaXMuX2luZmxhdGUuZmx1c2goKCkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gdGhpcy5faW5mbGF0ZVtrRXJyb3JdO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdzZXJ2ZXInIDogJ2NsaWVudCc7XG5cbiAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZSA9IHpsaWIuY3JlYXRlRGVmbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgIC8vXG4gICAgICAvLyBBbiBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCwgb25seSBvbiBOb2RlLmpzIDwgMTAuMC4wLCBpZiB0aGVcbiAgICAgIC8vIGB6bGliLkRlZmxhdGVSYXdgIGluc3RhbmNlIGlzIGNsb3NlZCB3aGlsZSBkYXRhIGlzIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBgUGVyTWVzc2FnZURlZmxhdGUjY2xlYW51cCgpYCBpcyBjYWxsZWQgYXQgdGhlIHdyb25nXG4gICAgICAvLyB0aW1lIGR1ZSB0byBhbiBhYm5vcm1hbCBXZWJTb2NrZXQgY2xvc3VyZS5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9kZWZsYXRlLm9uKCdlcnJvcicsIE5PT1ApO1xuICAgICAgdGhpcy5fZGVmbGF0ZS5vbignZGF0YScsIGRlZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5fZGVmbGF0ZS53cml0ZShkYXRhKTtcbiAgICB0aGlzLl9kZWZsYXRlLmZsdXNoKHpsaWIuWl9TWU5DX0ZMVVNILCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIGRlZmxhdGUgc3RyZWFtIHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAvL1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmIChmaW4pIGRhdGEgPSBkYXRhLnNsaWNlKDAsIGRhdGEubGVuZ3RoIC0gNCk7XG5cbiAgICAgIC8vXG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIGFnYWluIGluXG4gICAgICAvLyBgUGVyTWVzc2FnZURlZmxhdGUjY2xlYW51cCgpYC5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBudWxsO1xuXG4gICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGVyTWVzc2FnZURlZmxhdGU7XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5EZWZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG5cbiAgaWYgKFxuICAgIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZCA8IDEgfHxcbiAgICB0aGlzW2tUb3RhbExlbmd0aF0gPD0gdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkXG4gICkge1xuICAgIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXNba0Vycm9yXSA9IG5ldyBSYW5nZUVycm9yKCdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyk7XG4gIHRoaXNba0Vycm9yXVtrU3RhdHVzQ29kZV0gPSAxMDA5O1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XG4gIHRoaXMucmVzZXQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25FcnJvcihlcnIpIHtcbiAgLy9cbiAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGBabGliI2Nsb3NlKClgIGFzIHRoZSBoYW5kbGUgaXMgYXV0b21hdGljYWxseVxuICAvLyBjbG9zZWQgd2hlbiBhbiBlcnJvciBpcyBlbWl0dGVkLlxuICAvL1xuICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX2luZmxhdGUgPSBudWxsO1xuICBlcnJba1N0YXR1c0NvZGVdID0gMTAwNztcbiAgdGhpc1trQ2FsbGJhY2tdKGVycik7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/permessage-deflate.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/receiver.js":
/*!***************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/ws/lib/receiver.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../../node_modules/ws/lib/permessage-deflate.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"../../node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"../../node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"../../node_modules/ws/lib/validation.js\");\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends stream.Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {String} binaryType The type for binary data\n   * @param {Object} extensions An object containing the negotiated extensions\n   * @param {Boolean} isServer Specifies whether to operate in client or server\n   *     mode\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor(binaryType, extensions, isServer, maxPayload) {\n    super();\n\n    this._binaryType = binaryType || BINARY_TYPES[0];\n    this[kWebSocket] = undefined;\n    this._extensions = extensions || {};\n    this._isServer = !!isServer;\n    this._maxPayload = maxPayload | 0;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = buf.slice(n);\n      return buf.slice(0, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = buf.slice(n);\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          // `INFLATING`\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    cb(err);\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this._loop = false;\n      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this._loop = false;\n      return error(RangeError, 'RSV1 must be clear', true, 1002);\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\n      }\n\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(RangeError, 'invalid opcode 0', true, 1002);\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(RangeError, 'FIN must be set', true, 1002);\n      }\n\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002\n        );\n      }\n    } else {\n      this._loop = false;\n      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        this._loop = false;\n        return error(RangeError, 'MASK must be set', true, 1002);\n      }\n    } else if (this._masked) {\n      this._loop = false;\n      return error(RangeError, 'MASK must be clear', true, 1002);\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009\n      );\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(RangeError, 'Max payload size exceeded', false, 1009);\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n      if (this._masked) unmask(data, this._mask);\n    }\n\n    if (this._opcode > 0x07) return this.controlMessage(data);\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its lenght is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    return this.dataMessage();\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(\n            error(RangeError, 'Max payload size exceeded', false, 1009)\n          );\n        }\n\n        this._fragments.push(buf);\n      }\n\n      const er = this.dataMessage();\n      if (er) return cb(er);\n\n      this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        let data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.emit('message', data);\n      } else {\n        const buf = concat(fragments, messageLength);\n\n        if (!isValidUTF8(buf)) {\n          this._loop = false;\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n        }\n\n        this.emit('message', buf.toString());\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      this._loop = false;\n\n      if (data.length === 0) {\n        this.emit('conclude', 1005, '');\n        this.end();\n      } else if (data.length === 1) {\n        return error(RangeError, 'invalid payload length 1', true, 1002);\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          return error(RangeError, `invalid status code ${code}`, true, 1002);\n        }\n\n        const buf = data.slice(2);\n\n        if (!isValidUTF8(buf)) {\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n        }\n\n        this.emit('conclude', code, buf.toString());\n        this.end();\n      }\n    } else if (this._opcode === 0x09) {\n      this.emit('ping', data);\n    } else {\n      this.emit('pong', data);\n    }\n\n    this._state = GET_INFO;\n  }\n}\n\nmodule.exports = Receiver;\n\n/**\n * Builds an error object.\n *\n * @param {(Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @return {(Error|RangeError)} The error\n * @private\n */\nfunction error(ErrorCtor, message, prefix, statusCode) {\n  const err = new ErrorCtor(\n    prefix ? `Invalid WebSocket frame: ${message}` : message\n  );\n\n  Error.captureStackTrace(err, error);\n  err[kStatusCode] = statusCode;\n  return err;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3dzL2xpYi9yZWNlaXZlci5qcz83Y2IxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLE9BQU8sV0FBVyxHQUFHLG1CQUFPLENBQUMsc0JBQVE7O0FBRXJDLDBCQUEwQixtQkFBTyxDQUFDLDZFQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLG1CQUFPLENBQUMsMkRBQWE7QUFDekIsT0FBTyxnQ0FBZ0MsR0FBRyxtQkFBTyxDQUFDLCtEQUFlO0FBQ2pFLE9BQU8saUNBQWlDLEdBQUcsbUJBQU8sQ0FBQyw2REFBYzs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFdyaXRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXRcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBjb25jYXQsIHRvQXJyYXlCdWZmZXIsIHVubWFzayB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSwgaXNWYWxpZFVURjggfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG5jb25zdCBHRVRfSU5GTyA9IDA7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfMTYgPSAxO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzY0ID0gMjtcbmNvbnN0IEdFVF9NQVNLID0gMztcbmNvbnN0IEdFVF9EQVRBID0gNDtcbmNvbnN0IElORkxBVElORyA9IDU7XG5cbi8qKlxuICogSHlCaSBSZWNlaXZlciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBzdHJlYW0uV3JpdGFibGVcbiAqL1xuY2xhc3MgUmVjZWl2ZXIgZXh0ZW5kcyBXcml0YWJsZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVjZWl2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBiaW5hcnlUeXBlIFRoZSB0eXBlIGZvciBiaW5hcnkgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNTZXJ2ZXIgU3BlY2lmaWVzIHdoZXRoZXIgdG8gb3BlcmF0ZSBpbiBjbGllbnQgb3Igc2VydmVyXG4gICAqICAgICBtb2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhQYXlsb2FkIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKGJpbmFyeVR5cGUsIGV4dGVuc2lvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBiaW5hcnlUeXBlIHx8IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zIHx8IHt9O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFpc1NlcnZlcjtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gbWF4UGF5bG9hZCB8IDA7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbiAgICB0aGlzLl9idWZmZXJzID0gW107XG5cbiAgICB0aGlzLl9jb21wcmVzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWFzayA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICB0aGlzLl9tYXNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9maW4gPSBmYWxzZTtcbiAgICB0aGlzLl9vcGNvZGUgPSAwO1xuXG4gICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcblxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgYFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBUaGUgY2h1bmsgb2YgZGF0YSB0byB3cml0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgVGhlIGNoYXJhY3RlciBlbmNvZGluZyBvZiBgY2h1bmtgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDggJiYgdGhpcy5fc3RhdGUgPT0gR0VUX0lORk8pIHJldHVybiBjYigpO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3VtZXMgYG5gIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29uc3VtZVxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBjb25zdW1lZCBieXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3VtZShuKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBuO1xuXG4gICAgaWYgKG4gPT09IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSByZXR1cm4gdGhpcy5fYnVmZmVycy5zaGlmdCgpO1xuXG4gICAgaWYgKG4gPCB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDAsIG4pO1xuICAgIH1cblxuICAgIGNvbnN0IGRzdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcblxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XG4gICAgICBjb25zdCBvZmZzZXQgPSBkc3QubGVuZ3RoIC0gbjtcblxuICAgICAgaWYgKG4gPj0gYnVmLmxlbmd0aCkge1xuICAgICAgICBkc3Quc2V0KHRoaXMuX2J1ZmZlcnMuc2hpZnQoKSwgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRzdC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIG4pLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLl9idWZmZXJzWzBdID0gYnVmLnNsaWNlKG4pO1xuICAgICAgfVxuXG4gICAgICBuIC09IGJ1Zi5sZW5ndGg7XG4gICAgfSB3aGlsZSAobiA+IDApO1xuXG4gICAgcmV0dXJuIGRzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIHBhcnNpbmcgbG9vcC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXJ0TG9vcChjYikge1xuICAgIGxldCBlcnI7XG4gICAgdGhpcy5fbG9vcCA9IHRydWU7XG5cbiAgICBkbyB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIGNhc2UgR0VUX0lORk86XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXRJbmZvKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzE2OlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0UGF5bG9hZExlbmd0aDE2KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzY0OlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0UGF5bG9hZExlbmd0aDY0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX01BU0s6XG4gICAgICAgICAgdGhpcy5nZXRNYXNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX0RBVEE6XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXREYXRhKGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBgSU5GTEFUSU5HYFxuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSB3aGlsZSAodGhpcy5fbG9vcCk7XG5cbiAgICBjYihlcnIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBmaXJzdCB0d28gYnl0ZXMgb2YgYSBmcmFtZS5cbiAgICpcbiAgICogQHJldHVybiB7KFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SW5mbygpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoMik7XG5cbiAgICBpZiAoKGJ1ZlswXSAmIDB4MzApICE9PSAweDAwKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgJ1JTVjIgYW5kIFJTVjMgbXVzdCBiZSBjbGVhcicsIHRydWUsIDEwMDIpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXByZXNzZWQgPSAoYnVmWzBdICYgMHg0MCkgPT09IDB4NDA7XG5cbiAgICBpZiAoY29tcHJlc3NlZCAmJiAhdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsICdSU1YxIG11c3QgYmUgY2xlYXInLCB0cnVlLCAxMDAyKTtcbiAgICB9XG5cbiAgICB0aGlzLl9maW4gPSAoYnVmWzBdICYgMHg4MCkgPT09IDB4ODA7XG4gICAgdGhpcy5fb3Bjb2RlID0gYnVmWzBdICYgMHgwZjtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gYnVmWzFdICYgMHg3ZjtcblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDApIHtcbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsICdSU1YxIG11c3QgYmUgY2xlYXInLCB0cnVlLCAxMDAyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9mcmFnbWVudGVkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsICdpbnZhbGlkIG9wY29kZSAwJywgdHJ1ZSwgMTAwMik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29wY29kZSA9IHRoaXMuX2ZyYWdtZW50ZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDEgfHwgdGhpcy5fb3Bjb2RlID09PSAweDAyKSB7XG4gICAgICBpZiAodGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCwgdHJ1ZSwgMTAwMik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvbXByZXNzZWQgPSBjb21wcmVzc2VkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNyAmJiB0aGlzLl9vcGNvZGUgPCAweDBiKSB7XG4gICAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnRklOIG11c3QgYmUgc2V0JywgdHJ1ZSwgMTAwMik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsICdSU1YxIG11c3QgYmUgY2xlYXInLCB0cnVlLCAxMDAyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPiAweDdkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgcGF5bG9hZCBsZW5ndGggJHt0aGlzLl9wYXlsb2FkTGVuZ3RofWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCwgdHJ1ZSwgMTAwMik7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9maW4gJiYgIXRoaXMuX2ZyYWdtZW50ZWQpIHRoaXMuX2ZyYWdtZW50ZWQgPSB0aGlzLl9vcGNvZGU7XG4gICAgdGhpcy5fbWFza2VkID0gKGJ1ZlsxXSAmIDB4ODApID09PSAweDgwO1xuXG4gICAgaWYgKHRoaXMuX2lzU2VydmVyKSB7XG4gICAgICBpZiAoIXRoaXMuX21hc2tlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnTUFTSyBtdXN0IGJlIHNldCcsIHRydWUsIDEwMDIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fbWFza2VkKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgJ01BU0sgbXVzdCBiZSBjbGVhcicsIHRydWUsIDEwMDIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjYpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzE2O1xuICAgIGVsc2UgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNykgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ7XG4gICAgZWxzZSByZXR1cm4gdGhpcy5oYXZlTGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNysxNikuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGgxNigpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gdGhpcy5jb25zdW1lKDIpLnJlYWRVSW50MTZCRSgwKTtcbiAgICByZXR1cm4gdGhpcy5oYXZlTGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNys2NCkuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGg2NCgpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoOCk7XG4gICAgY29uc3QgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyIGluIEphdmFTY3JpcHQgaXMgMl41MyAtIDEuIEFuIGVycm9yIGlzIHJldHVybmVkXG4gICAgLy8gaWYgcGF5bG9hZCBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoaXMgbnVtYmVyLlxuICAgIC8vXG4gICAgaWYgKG51bSA+IE1hdGgucG93KDIsIDUzIC0gMzIpIC0gMSkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgV2ViU29ja2V0IGZyYW1lOiBwYXlsb2FkIGxlbmd0aCA+IDJeNTMgLSAxJyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIDEwMDlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IG51bSAqIE1hdGgucG93KDIsIDMyKSArIGJ1Zi5yZWFkVUludDMyQkUoNCk7XG4gICAgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBheWxvYWQgbGVuZ3RoIGhhcyBiZWVuIHJlYWQuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhdmVMZW5ndGgoKSB7XG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggJiYgdGhpcy5fb3Bjb2RlIDwgMHgwOCkge1xuICAgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoICs9IHRoaXMuX3BheWxvYWRMZW5ndGg7XG4gICAgICBpZiAodGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsIGZhbHNlLCAxMDA5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbWFza2VkKSB0aGlzLl9zdGF0ZSA9IEdFVF9NQVNLO1xuICAgIGVsc2UgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBtYXNrIGJ5dGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TWFzaygpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDQpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXNrID0gdGhpcy5jb25zdW1lKDQpO1xuICAgIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgZGF0YSBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RGF0YShjYikge1xuICAgIGxldCBkYXRhID0gRU1QVFlfQlVGRkVSO1xuXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgdGhpcy5fcGF5bG9hZExlbmd0aCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IHRoaXMuY29uc3VtZSh0aGlzLl9wYXlsb2FkTGVuZ3RoKTtcbiAgICAgIGlmICh0aGlzLl9tYXNrZWQpIHVubWFzayhkYXRhLCB0aGlzLl9tYXNrKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNykgcmV0dXJuIHRoaXMuY29udHJvbE1lc3NhZ2UoZGF0YSk7XG5cbiAgICBpZiAodGhpcy5fY29tcHJlc3NlZCkge1xuICAgICAgdGhpcy5fc3RhdGUgPSBJTkZMQVRJTkc7XG4gICAgICB0aGlzLmRlY29tcHJlc3MoZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgbWVzc2FnZSBpcyBub3QgY29tcHJlc3NlZCBzbyBpdHMgbGVuZ2h0IGlzIHRoZSBzdW0gb2YgdGhlIHBheWxvYWRcbiAgICAgIC8vIGxlbmd0aCBvZiBhbGwgZnJhZ21lbnRzLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGg7XG4gICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhTWVzc2FnZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3NlcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgY2IpIHtcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG5cbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5kZWNvbXByZXNzKGRhdGEsIHRoaXMuX2ZpbiwgKGVyciwgYnVmKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgaWYgKGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5fbWVzc2FnZUxlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gY2IoXG4gICAgICAgICAgICBlcnJvcihSYW5nZUVycm9yLCAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsIGZhbHNlLCAxMDA5KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChidWYpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlciA9IHRoaXMuZGF0YU1lc3NhZ2UoKTtcbiAgICAgIGlmIChlcikgcmV0dXJuIGNiKGVyKTtcblxuICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBkYXRhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEByZXR1cm4geyhFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkYXRhTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5fZmluKSB7XG4gICAgICBjb25zdCBtZXNzYWdlTGVuZ3RoID0gdGhpcy5fbWVzc2FnZUxlbmd0aDtcbiAgICAgIGNvbnN0IGZyYWdtZW50cyA9IHRoaXMuX2ZyYWdtZW50cztcblxuICAgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgICAgdGhpcy5fZnJhZ21lbnRlZCA9IDA7XG4gICAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMikge1xuICAgICAgICBsZXQgZGF0YTtcblxuICAgICAgICBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ25vZGVidWZmZXInKSB7XG4gICAgICAgICAgZGF0YSA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgICBkYXRhID0gdG9BcnJheUJ1ZmZlcihjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YSA9IGZyYWdtZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYnVmID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBlcnJvcihFcnJvciwgJ2ludmFsaWQgVVRGLTggc2VxdWVuY2UnLCB0cnVlLCAxMDA3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1Zi50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBjb250cm9sIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gaGFuZGxlXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnRyb2xNZXNzYWdlKGRhdGEpIHtcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA4KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG5cbiAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgMTAwNSwgJycpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgJ2ludmFsaWQgcGF5bG9hZCBsZW5ndGggMScsIHRydWUsIDEwMDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGRhdGEucmVhZFVJbnQxNkJFKDApO1xuXG4gICAgICAgIGlmICghaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgYGludmFsaWQgc3RhdHVzIGNvZGUgJHtjb2RlfWAsIHRydWUsIDEwMDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmID0gZGF0YS5zbGljZSgyKTtcblxuICAgICAgICBpZiAoIWlzVmFsaWRVVEY4KGJ1ZikpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoRXJyb3IsICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJywgdHJ1ZSwgMTAwNyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgY29kZSwgYnVmLnRvU3RyaW5nKCkpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA5KSB7XG4gICAgICB0aGlzLmVtaXQoJ3BpbmcnLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdwb25nJywgZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xuXG4vKipcbiAqIEJ1aWxkcyBhbiBlcnJvciBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsoRXJyb3J8UmFuZ2VFcnJvcil9IEVycm9yQ3RvciBUaGUgZXJyb3IgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZpeCBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gYWRkIGEgZGVmYXVsdCBwcmVmaXggdG9cbiAqICAgICBgbWVzc2FnZWBcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNDb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3IpfSBUaGUgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVycm9yKEVycm9yQ3RvciwgbWVzc2FnZSwgcHJlZml4LCBzdGF0dXNDb2RlKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvckN0b3IoXG4gICAgcHJlZml4ID8gYEludmFsaWQgV2ViU29ja2V0IGZyYW1lOiAke21lc3NhZ2V9YCA6IG1lc3NhZ2VcbiAgKTtcblxuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIGVycm9yKTtcbiAgZXJyW2tTdGF0dXNDb2RlXSA9IHN0YXR1c0NvZGU7XG4gIHJldHVybiBlcnI7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/receiver.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/sender.js":
/*!*************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/ws/lib/sender.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../../node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"../../node_modules/ws/lib/constants.js\");\nconst { isValidStatusCode } = __webpack_require__(/*! ./validation */ \"../../node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"../../node_modules/ws/lib/buffer-util.js\");\n\nconst mask = Buffer.alloc(4);\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {net.Socket} socket The connection socket\n   * @param {Object} extensions An object containing the negotiated extensions\n   */\n  constructor(socket, extensions) {\n    this._extensions = extensions || {};\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n  static frame(data, options) {\n    const merge = options.mask && options.readOnly;\n    let offset = options.mask ? 6 : 2;\n    let payloadLength = data.length;\n\n    if (data.length >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (data.length > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(data.length, 2);\n    } else if (payloadLength === 127) {\n      target.writeUInt32BE(0, 2);\n      target.writeUInt32BE(data.length, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    randomFillSync(mask, 0, 4);\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, data.length);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, data.length);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {(Number|undefined)} code The status code component of the body\n   * @param {String} data The message component of the body\n   * @param {Boolean} mask Specifies whether or not to mask the message\n   * @param {Function} cb Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || data === '') {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n      buf.write(data, 2);\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doClose, buf, mask, cb]);\n    } else {\n      this.doClose(buf, mask, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @private\n   */\n  doClose(data, mask, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x08,\n        mask,\n        readOnly: false\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (buf.length > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPing(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a ping message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n  doPing(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x09,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (buf.length > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPong(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a pong message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n  doPong(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x0a,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const buf = toBuffer(data);\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate) {\n        rsv1 = buf.length >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        fin: options.fin,\n        rsv1,\n        opcode,\n        mask: options.mask,\n        readOnly: toBuffer.readOnly\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);\n      } else {\n        this.dispatch(buf, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(buf, {\n          fin: options.fin,\n          rsv1: false,\n          opcode,\n          mask: options.mask,\n          readOnly: toBuffer.readOnly\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} compress Specifies whether or not to compress `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @param {Function} cb Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += data.length;\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        if (typeof cb === 'function') cb(err);\n\n        for (let i = 0; i < this._queue.length; i++) {\n          const callback = this._queue[i][4];\n\n          if (typeof callback === 'function') callback(err);\n        }\n\n        return;\n      }\n\n      this._bufferedBytes -= data.length;\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[1].length;\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[1].length;\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} cb Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3dzL2xpYi9zZW5kZXIuanM/ZjQ2ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixPQUFPLGlCQUFpQixHQUFHLG1CQUFPLENBQUMsc0JBQVE7O0FBRTNDLDBCQUEwQixtQkFBTyxDQUFDLDZFQUFzQjtBQUN4RCxPQUFPLGVBQWUsR0FBRyxtQkFBTyxDQUFDLDJEQUFhO0FBQzlDLE9BQU8sb0JBQW9CLEdBQUcsbUJBQU8sQ0FBQyw2REFBYztBQUNwRCxPQUFPLDRCQUE0QixHQUFHLG1CQUFPLENBQUMsK0RBQWU7O0FBRTdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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aWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9zZW5kZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgcmFuZG9tRmlsbFN5bmMgfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCB7IEVNUFRZX0JVRkZFUiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgaXNWYWxpZFN0YXR1c0NvZGUgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuY29uc3QgeyBtYXNrOiBhcHBseU1hc2ssIHRvQnVmZmVyIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5cbmNvbnN0IG1hc2sgPSBCdWZmZXIuYWxsb2MoNCk7XG5cbi8qKlxuICogSHlCaSBTZW5kZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFNlbmRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU2VuZGVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge25ldC5Tb2NrZXR9IHNvY2tldCBUaGUgY29ubmVjdGlvbiBzb2NrZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWQgZXh0ZW5zaW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Ioc29ja2V0LCBleHRlbnNpb25zKSB7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG4gICAgdGhpcy5fY29tcHJlc3MgPSBmYWxzZTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2RlZmxhdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGEgcGllY2Ugb2YgZGF0YSBhY2NvcmRpbmcgdG8gdGhlIEh5QmkgV2ViU29ja2V0IHByb3RvY29sLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSB0byBmcmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMucmVhZE9ubHkgU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZSBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlIEZJTiBiaXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLm1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5yc3YxIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlIFJTVjEgYml0XG4gICAqIEByZXR1cm4ge0J1ZmZlcltdfSBUaGUgZnJhbWVkIGRhdGEgYXMgYSBsaXN0IG9mIGBCdWZmZXJgIGluc3RhbmNlc1xuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZnJhbWUoZGF0YSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG1lcmdlID0gb3B0aW9ucy5tYXNrICYmIG9wdGlvbnMucmVhZE9ubHk7XG4gICAgbGV0IG9mZnNldCA9IG9wdGlvbnMubWFzayA/IDYgOiAyO1xuICAgIGxldCBwYXlsb2FkTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPj0gNjU1MzYpIHtcbiAgICAgIG9mZnNldCArPSA4O1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNztcbiAgICB9IGVsc2UgaWYgKGRhdGEubGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjY7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lcmdlID8gZGF0YS5sZW5ndGggKyBvZmZzZXQgOiBvZmZzZXQpO1xuXG4gICAgdGFyZ2V0WzBdID0gb3B0aW9ucy5maW4gPyBvcHRpb25zLm9wY29kZSB8IDB4ODAgOiBvcHRpb25zLm9wY29kZTtcbiAgICBpZiAob3B0aW9ucy5yc3YxKSB0YXJnZXRbMF0gfD0gMHg0MDtcblxuICAgIHRhcmdldFsxXSA9IHBheWxvYWRMZW5ndGg7XG5cbiAgICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICB0YXJnZXQud3JpdGVVSW50MTZCRShkYXRhLmxlbmd0aCwgMik7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjcpIHtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQzMkJFKDAsIDIpO1xuICAgICAgdGFyZ2V0LndyaXRlVUludDMyQkUoZGF0YS5sZW5ndGgsIDYpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5tYXNrKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICByYW5kb21GaWxsU3luYyhtYXNrLCAwLCA0KTtcblxuICAgIHRhcmdldFsxXSB8PSAweDgwO1xuICAgIHRhcmdldFtvZmZzZXQgLSA0XSA9IG1hc2tbMF07XG4gICAgdGFyZ2V0W29mZnNldCAtIDNdID0gbWFza1sxXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMl0gPSBtYXNrWzJdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAxXSA9IG1hc2tbM107XG5cbiAgICBpZiAobWVyZ2UpIHtcbiAgICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCB0YXJnZXQsIG9mZnNldCwgZGF0YS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIFt0YXJnZXRdO1xuICAgIH1cblxuICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCk7XG4gICAgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgY2xvc2UgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsoTnVtYmVyfHVuZGVmaW5lZCl9IGNvZGUgVGhlIHN0YXR1cyBjb2RlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSBUaGUgbWVzc2FnZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIHRoZSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ1ZjtcblxuICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJ1ZiA9IEVNUFRZX0JVRkZFUjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJyB8fCAhaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSB2YWxpZCBlcnJvciBjb2RlIG51bWJlcicpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8IGRhdGEgPT09ICcnKSB7XG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMik7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG5cbiAgICAgIGlmIChsZW5ndGggPiAxMjMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBtZXNzYWdlIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjMgYnl0ZXMnKTtcbiAgICAgIH1cblxuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIgKyBsZW5ndGgpO1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG4gICAgICBidWYud3JpdGUoZGF0YSwgMik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRvQ2xvc2UsIGJ1ZiwgbWFzaywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb0Nsb3NlKGJ1ZiwgbWFzaywgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYW5kIHNlbmRzIGEgY2xvc2UgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkb0Nsb3NlKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgdGhpcy5zZW5kRnJhbWUoXG4gICAgICBTZW5kZXIuZnJhbWUoZGF0YSwge1xuICAgICAgICBmaW46IHRydWUsXG4gICAgICAgIHJzdjE6IGZhbHNlLFxuICAgICAgICBvcGNvZGU6IDB4MDgsXG4gICAgICAgIG1hc2ssXG4gICAgICAgIHJlYWRPbmx5OiBmYWxzZVxuICAgICAgfSksXG4gICAgICBjYlxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwaW5nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGNvbnN0IGJ1ZiA9IHRvQnVmZmVyKGRhdGEpO1xuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZG9QaW5nLCBidWYsIG1hc2ssIHRvQnVmZmVyLnJlYWRPbmx5LCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvUGluZyhidWYsIG1hc2ssIHRvQnVmZmVyLnJlYWRPbmx5LCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZyYW1lcyBhbmQgc2VuZHMgYSBwaW5nIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlYWRPbmx5IFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmUgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRvUGluZyhkYXRhLCBtYXNrLCByZWFkT25seSwgY2IpIHtcbiAgICB0aGlzLnNlbmRGcmFtZShcbiAgICAgIFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgIGZpbjogdHJ1ZSxcbiAgICAgICAgcnN2MTogZmFsc2UsXG4gICAgICAgIG9wY29kZTogMHgwOSxcbiAgICAgICAgbWFzayxcbiAgICAgICAgcmVhZE9ubHlcbiAgICAgIH0pLFxuICAgICAgY2JcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcG9uZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBvbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBjb25zdCBidWYgPSB0b0J1ZmZlcihkYXRhKTtcblxuICAgIGlmIChidWYubGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRvUG9uZywgYnVmLCBtYXNrLCB0b0J1ZmZlci5yZWFkT25seSwgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb1BvbmcoYnVmLCBtYXNrLCB0b0J1ZmZlci5yZWFkT25seSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYW5kIHNlbmRzIGEgcG9uZyBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSByZWFkT25seSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkb1BvbmcoZGF0YSwgbWFzaywgcmVhZE9ubHksIGNiKSB7XG4gICAgdGhpcy5zZW5kRnJhbWUoXG4gICAgICBTZW5kZXIuZnJhbWUoZGF0YSwge1xuICAgICAgICBmaW46IHRydWUsXG4gICAgICAgIHJzdjE6IGZhbHNlLFxuICAgICAgICBvcGNvZGU6IDB4MGEsXG4gICAgICAgIG1hc2ssXG4gICAgICAgIHJlYWRPbmx5XG4gICAgICB9KSxcbiAgICAgIGNiXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGRhdGEgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmNvbXByZXNzIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzcyBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmJpbmFyeSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5IG9yIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmZpbiBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5tYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgY29uc3QgYnVmID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuICAgIGxldCBvcGNvZGUgPSBvcHRpb25zLmJpbmFyeSA/IDIgOiAxO1xuICAgIGxldCByc3YxID0gb3B0aW9ucy5jb21wcmVzcztcblxuICAgIGlmICh0aGlzLl9maXJzdEZyYWdtZW50KSB7XG4gICAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gZmFsc2U7XG4gICAgICBpZiAocnN2MSAmJiBwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICByc3YxID0gYnVmLmxlbmd0aCA+PSBwZXJNZXNzYWdlRGVmbGF0ZS5fdGhyZXNob2xkO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29tcHJlc3MgPSByc3YxO1xuICAgIH0gZWxzZSB7XG4gICAgICByc3YxID0gZmFsc2U7XG4gICAgICBvcGNvZGUgPSAwO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZpbikgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG5cbiAgICBpZiAocGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIGZpbjogb3B0aW9ucy5maW4sXG4gICAgICAgIHJzdjEsXG4gICAgICAgIG9wY29kZSxcbiAgICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxuICAgICAgICByZWFkT25seTogdG9CdWZmZXIucmVhZE9ubHlcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBidWYsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaChidWYsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFxuICAgICAgICBTZW5kZXIuZnJhbWUoYnVmLCB7XG4gICAgICAgICAgZmluOiBvcHRpb25zLmZpbixcbiAgICAgICAgICByc3YxOiBmYWxzZSxcbiAgICAgICAgICBvcGNvZGUsXG4gICAgICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxuICAgICAgICAgIHJlYWRPbmx5OiB0b0J1ZmZlci5yZWFkT25seVxuICAgICAgICB9KSxcbiAgICAgICAgY2JcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYSBkYXRhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBjb21wcmVzcyBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3MgYGRhdGFgXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5yZWFkT25seSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5maW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGUgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMubWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnJzdjEgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGUgUlNWMSBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc3BhdGNoKGRhdGEsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xuICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gZGF0YS5sZW5ndGg7XG4gICAgdGhpcy5fZGVmbGF0aW5nID0gdHJ1ZTtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5jb21wcmVzcyhkYXRhLCBvcHRpb25zLmZpbiwgKF8sIGJ1ZikgPT4ge1xuICAgICAgaWYgKHRoaXMuX3NvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgc29ja2V0IHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgY29tcHJlc3NlZCdcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSBjYihlcnIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX3F1ZXVlW2ldWzRdO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBkYXRhLmxlbmd0aDtcbiAgICAgIHRoaXMuX2RlZmxhdGluZyA9IGZhbHNlO1xuICAgICAgb3B0aW9ucy5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHF1ZXVlZCBzZW5kIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXF1ZXVlKCkge1xuICAgIHdoaWxlICghdGhpcy5fZGVmbGF0aW5nICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcblxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBwYXJhbXNbMV0ubGVuZ3RoO1xuICAgICAgUmVmbGVjdC5hcHBseShwYXJhbXNbMF0sIHRoaXMsIHBhcmFtcy5zbGljZSgxKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc2VuZCBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBTZW5kIG9wZXJhdGlvbiBwYXJhbWV0ZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW5xdWV1ZShwYXJhbXMpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IHBhcmFtc1sxXS5sZW5ndGg7XG4gICAgdGhpcy5fcXVldWUucHVzaChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGZyYW1lIHRvIHNlbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRGcmFtZShsaXN0LCBjYikge1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy5fc29ja2V0LmNvcmsoKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzFdLCBjYik7XG4gICAgICB0aGlzLl9zb2NrZXQudW5jb3JrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdLCBjYik7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/sender.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/stream.js":
/*!*************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/ws/lib/stream.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {stream.Duplex} The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} options The options for the `Duplex` constructor\n * @return {stream.Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let resumeOnReceiverDrain = true;\n\n  function receiverOnDrain() {\n    if (resumeOnReceiverDrain) ws._socket.resume();\n  }\n\n  if (ws.readyState === ws.CONNECTING) {\n    ws.once('open', function open() {\n      ws._receiver.removeAllListeners('drain');\n      ws._receiver.on('drain', receiverOnDrain);\n    });\n  } else {\n    ws._receiver.removeAllListeners('drain');\n    ws._receiver.on('drain', receiverOnDrain);\n  }\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg) {\n    if (!duplex.push(msg)) {\n      resumeOnReceiverDrain = false;\n      ws._socket.pause();\n    }\n  });\n\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n    ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {\n      resumeOnReceiverDrain = true;\n      if (!ws._receiver._writableState.needDrain) ws._socket.resume();\n    }\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3dzL2xpYi9zdHJlYW0uanM/YmU3YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixPQUFPLFNBQVMsR0FBRyxtQkFBTyxDQUFDLHNCQUFROztBQUVuQztBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvd3MvbGliL3N0cmVhbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKipcbiAqIEVtaXRzIHRoZSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYSBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtzdHJlYW0uRHVwbGV4fSBUaGUgc3RyZWFtLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FbmQoKSB7XG4gIGlmICghdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FcnJvcihlcnIpIHtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcbiAgICAvLyBEbyBub3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yLlxuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogV3JhcHMgYSBgV2ViU29ja2V0YCBpbiBhIGR1cGxleCBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdzIFRoZSBgV2ViU29ja2V0YCB0byB3cmFwXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIGBEdXBsZXhgIGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJuIHtzdHJlYW0uRHVwbGV4fSBUaGUgZHVwbGV4IHN0cmVhbVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXRTdHJlYW0od3MsIG9wdGlvbnMpIHtcbiAgbGV0IHJlc3VtZU9uUmVjZWl2ZXJEcmFpbiA9IHRydWU7XG5cbiAgZnVuY3Rpb24gcmVjZWl2ZXJPbkRyYWluKCkge1xuICAgIGlmIChyZXN1bWVPblJlY2VpdmVyRHJhaW4pIHdzLl9zb2NrZXQucmVzdW1lKCk7XG4gIH1cblxuICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgd3MuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygnZHJhaW4nKTtcbiAgICAgIHdzLl9yZWNlaXZlci5vbignZHJhaW4nLCByZWNlaXZlck9uRHJhaW4pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHdzLl9yZWNlaXZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RyYWluJyk7XG4gICAgd3MuX3JlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gIH1cblxuICBjb25zdCBkdXBsZXggPSBuZXcgRHVwbGV4KHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGF1dG9EZXN0cm95OiBmYWxzZSxcbiAgICBlbWl0Q2xvc2U6IGZhbHNlLFxuICAgIG9iamVjdE1vZGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlT2JqZWN0TW9kZTogZmFsc2VcbiAgfSk7XG5cbiAgd3Mub24oJ21lc3NhZ2UnLCBmdW5jdGlvbiBtZXNzYWdlKG1zZykge1xuICAgIGlmICghZHVwbGV4LnB1c2gobXNnKSkge1xuICAgICAgcmVzdW1lT25SZWNlaXZlckRyYWluID0gZmFsc2U7XG4gICAgICB3cy5fc29ja2V0LnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICB3cy5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICBkdXBsZXguZGVzdHJveShlcnIpO1xuICB9KTtcblxuICB3cy5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICBkdXBsZXgucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgZHVwbGV4Ll9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ0xPU0VEKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIGR1cGxleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuXG4gICAgd3Mub25jZSgnZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuXG4gICAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIGlmICghY2FsbGVkKSBjYWxsYmFjayhlcnIpO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIGR1cGxleCk7XG4gICAgfSk7XG4gICAgd3MudGVybWluYXRlKCk7XG4gIH07XG5cbiAgZHVwbGV4Ll9maW5hbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll9maW5hbChjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIGBfc29ja2V0YCBwcm9wZXJ0eSBpcyBgbnVsbGAgaXQgbWVhbnMgdGhhdCBgd3NgIGlzIGFcbiAgICAvLyBjbGllbnQgd2Vic29ja2V0IGFuZCB0aGUgaGFuZHNoYWtlIGZhaWxlZC4gSW4gZmFjdCwgd2hlbiB0aGlzIGhhcHBlbnMsIGFcbiAgICAvLyBzb2NrZXQgaXMgbmV2ZXIgYXNzaWduZWQgdG8gdGhlIHdlYnNvY2tldC4gV2FpdCBmb3IgdGhlIGAnZXJyb3InYCBldmVudFxuICAgIC8vIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoZSB3ZWJzb2NrZXQuXG4gICAgaWYgKHdzLl9zb2NrZXQgPT09IG51bGwpIHJldHVybjtcblxuICAgIGlmICh3cy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgaWYgKGR1cGxleC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSBkdXBsZXguZGVzdHJveSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cy5fc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgLy8gYGR1cGxleGAgaXMgbm90IGRlc3Ryb3llZCBoZXJlIGJlY2F1c2UgdGhlIGAnZW5kJ2AgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBlbWl0dGVkIG9uIGBkdXBsZXhgIGFmdGVyIHRoaXMgYCdmaW5pc2gnYCBldmVudC4gVGhlIEVPRiBzaWduYWxpbmdcbiAgICAgICAgLy8gYG51bGxgIGNodW5rIGlzLCBpbiBmYWN0LCBwdXNoZWQgd2hlbiB0aGUgd2Vic29ja2V0IGVtaXRzIGAnY2xvc2UnYC5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgICAgd3MuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgZHVwbGV4Ll9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5PUEVOICYmICFyZXN1bWVPblJlY2VpdmVyRHJhaW4pIHtcbiAgICAgIHJlc3VtZU9uUmVjZWl2ZXJEcmFpbiA9IHRydWU7XG4gICAgICBpZiAoIXdzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pIHdzLl9zb2NrZXQucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIGR1cGxleC5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdzLnNlbmQoY2h1bmssIGNhbGxiYWNrKTtcbiAgfTtcblxuICBkdXBsZXgub24oJ2VuZCcsIGR1cGxleE9uRW5kKTtcbiAgZHVwbGV4Lm9uKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xuICByZXR1cm4gZHVwbGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVdlYlNvY2tldFN0cmVhbTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/stream.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/validation.js":
/*!*****************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/ws/lib/validation.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\ntry {\n  const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"../../node_modules/utf-8-validate/index.js\");\n\n  exports.isValidUTF8 =\n    typeof isValidUTF8 === 'object'\n      ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0\n      : isValidUTF8;\n} catch (e) /* istanbul ignore next */ {\n  exports.isValidUTF8 = () => true;\n}\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nexports.isValidStatusCode = (code) => {\n  return (\n    (code >= 1000 &&\n      code <= 1014 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3dzL2xpYi92YWxpZGF0aW9uLmpzP2Y4Y2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxrRUFBZ0I7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi92YWxpZGF0aW9uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG50cnkge1xuICBjb25zdCBpc1ZhbGlkVVRGOCA9IHJlcXVpcmUoJ3V0Zi04LXZhbGlkYXRlJyk7XG5cbiAgZXhwb3J0cy5pc1ZhbGlkVVRGOCA9XG4gICAgdHlwZW9mIGlzVmFsaWRVVEY4ID09PSAnb2JqZWN0J1xuICAgICAgPyBpc1ZhbGlkVVRGOC5WYWxpZGF0aW9uLmlzVmFsaWRVVEY4IC8vIHV0Zi04LXZhbGlkYXRlQDwzLjAuMFxuICAgICAgOiBpc1ZhbGlkVVRGODtcbn0gY2F0Y2ggKGUpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHtcbiAgZXhwb3J0cy5pc1ZhbGlkVVRGOCA9ICgpID0+IHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhdHVzIGNvZGUgaXMgYWxsb3dlZCBpbiBhIGNsb3NlIGZyYW1lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBzdGF0dXMgY29kZSBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydHMuaXNWYWxpZFN0YXR1c0NvZGUgPSAoY29kZSkgPT4ge1xuICByZXR1cm4gKFxuICAgIChjb2RlID49IDEwMDAgJiZcbiAgICAgIGNvZGUgPD0gMTAxNCAmJlxuICAgICAgY29kZSAhPT0gMTAwNCAmJlxuICAgICAgY29kZSAhPT0gMTAwNSAmJlxuICAgICAgY29kZSAhPT0gMTAwNikgfHxcbiAgICAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSlcbiAgKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/validation.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/websocket-server.js":
/*!***********************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/ws/lib/websocket-server.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { createServer, STATUS_CODES } = __webpack_require__(/*! http */ \"http\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../../node_modules/ws/lib/permessage-deflate.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"../../node_modules/ws/lib/websocket.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"../../node_modules/ws/lib/extension.js\");\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"../../node_modules/ws/lib/constants.js\");\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} options.backlog The maximum length of the queue of pending\n   *     connections\n   * @param {Boolean} options.clientTracking Specifies whether or not to track\n   *     clients\n   * @param {Function} options.handleProtocols A hook to handle protocols\n   * @param {String} options.host The hostname where to bind the server\n   * @param {Number} options.maxPayload The maximum allowed message size\n   * @param {Boolean} options.noServer Enable no server mode\n   * @param {String} options.path Accept only connections matching this path\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable\n   *     permessage-deflate\n   * @param {Number} options.port The port where to bind the server\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\n   * @param {Function} options.verifyClient A hook to reject connections\n   * @param {Function} callback A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      ...options\n    };\n\n    if (options.port == null && !options.server && !options.noServer) {\n      throw new TypeError(\n        'One of the \"port\", \"server\", or \"noServer\" options must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = createServer((req, res) => {\n        const body = STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, (ws) => {\n            this.emit('connection', ws, req);\n          });\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) this.clients = new Set();\n    this.options = options;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Close the server.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  close(cb) {\n    if (cb) this.once('close', cb);\n\n    //\n    // Terminate all associated clients.\n    //\n    if (this.clients) {\n      for (const client of this.clients) client.terminate();\n    }\n\n    const server = this._server;\n\n    if (server) {\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // Close the http server if it was internally created.\n      //\n      if (this.options.port != null) {\n        server.close(() => this.emit('close'));\n        return;\n      }\n    }\n\n    process.nextTick(emitClose, this);\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key =\n      req.headers['sec-websocket-key'] !== undefined\n        ? req.headers['sec-websocket-key'].trim()\n        : false;\n    const version = +req.headers['sec-websocket-version'];\n    const extensions = {};\n\n    if (\n      req.method !== 'GET' ||\n      req.headers.upgrade.toLowerCase() !== 'websocket' ||\n      !key ||\n      !keyRegex.test(key) ||\n      (version !== 8 && version !== 13) ||\n      !this.shouldHandle(req)\n    ) {\n      return abortHandshake(socket, 400);\n    }\n\n    if (this.options.perMessageDeflate) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = parse(req.headers['sec-websocket-extensions']);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.connection.authorized || req.connection.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(key, extensions, req, socket, head, cb);\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(key, extensions, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Object} extensions The accepted extensions\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(key, extensions, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new WebSocket(null);\n    let protocol = req.headers['sec-websocket-protocol'];\n\n    if (protocol) {\n      protocol = protocol.trim().split(/ *, */);\n\n      //\n      // Optionally call external protocol selection handler.\n      //\n      if (this.options.handleProtocols) {\n        protocol = this.options.handleProtocols(protocol, req);\n      } else {\n        protocol = protocol[0];\n      }\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws.protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, this.options.maxPayload);\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => this.clients.delete(ws));\n    }\n\n    cb(ws);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server.emit('close');\n}\n\n/**\n * Handle premature socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  if (socket.writable) {\n    message = message || STATUS_CODES[code];\n    headers = {\n      Connection: 'close',\n      'Content-Type': 'text/html',\n      'Content-Length': Buffer.byteLength(message),\n      ...headers\n    };\n\n    socket.write(\n      `HTTP/1.1 ${code} ${STATUS_CODES[code]}\\r\\n` +\n        Object.keys(headers)\n          .map((h) => `${h}: ${headers[h]}`)\n          .join('\\r\\n') +\n        '\\r\\n\\r\\n' +\n        message\n    );\n  }\n\n  socket.removeListener('error', socketOnError);\n  socket.destroy();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQtc2VydmVyLmpzP2MzYjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIscUJBQXFCLG1CQUFPLENBQUMsc0JBQVE7QUFDckMsT0FBTyxhQUFhLEdBQUcsbUJBQU8sQ0FBQyxzQkFBUTtBQUN2QyxPQUFPLDZCQUE2QixHQUFHLG1CQUFPLENBQUMsa0JBQU07O0FBRXJELDBCQUEwQixtQkFBTyxDQUFDLDZFQUFzQjtBQUN4RCxrQkFBa0IsbUJBQU8sQ0FBQywyREFBYTtBQUN2QyxPQUFPLGdCQUFnQixHQUFHLG1CQUFPLENBQUMsMkRBQWE7QUFDL0MsT0FBTyxtQkFBbUIsR0FBRyxtQkFBTyxDQUFDLDJEQUFhOztBQUVsRCxpQ0FBaUMsR0FBRzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEIsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVB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O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LXNlcnZlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCB7IGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgeyBjcmVhdGVTZXJ2ZXIsIFNUQVRVU19DT0RFUyB9ID0gcmVxdWlyZSgnaHR0cCcpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuY29uc3QgeyBmb3JtYXQsIHBhcnNlIH0gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgeyBHVUlELCBrV2ViU29ja2V0IH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBrZXlSZWdleCA9IC9eWysvMC05QS1aYS16XXsyMn09PSQvO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldCBzZXJ2ZXIuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldFNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgV2ViU29ja2V0U2VydmVyYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmJhY2tsb2cgVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBxdWV1ZSBvZiBwZW5kaW5nXG4gICAqICAgICBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuY2xpZW50VHJhY2tpbmcgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHRyYWNrXG4gICAqICAgICBjbGllbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzIEEgaG9vayB0byBoYW5kbGUgcHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmhvc3QgVGhlIGhvc3RuYW1lIHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5tYXhQYXlsb2FkIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5ub1NlcnZlciBFbmFibGUgbm8gc2VydmVyIG1vZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMucGF0aCBBY2NlcHQgb25seSBjb25uZWN0aW9ucyBtYXRjaGluZyB0aGlzIHBhdGhcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlIEVuYWJsZS9kaXNhYmxlXG4gICAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucG9ydCBUaGUgcG9ydCB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtodHRwLlNlcnZlcn0gb3B0aW9ucy5zZXJ2ZXIgQSBwcmUtY3JlYXRlZCBIVFRQL1Mgc2VydmVyIHRvIHVzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnZlcmlmeUNsaWVudCBBIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEEgbGlzdGVuZXIgZm9yIHRoZSBgbGlzdGVuaW5nYCBldmVudFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBzdXBlcigpO1xuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxuICAgICAgY2xpZW50VHJhY2tpbmc6IHRydWUsXG4gICAgICB2ZXJpZnlDbGllbnQ6IG51bGwsXG4gICAgICBub1NlcnZlcjogZmFsc2UsXG4gICAgICBiYWNrbG9nOiBudWxsLCAvLyB1c2UgZGVmYXVsdCAoNTExIGFzIGltcGxlbWVudGVkIGluIG5ldC5qcylcbiAgICAgIHNlcnZlcjogbnVsbCxcbiAgICAgIGhvc3Q6IG51bGwsXG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgcG9ydDogbnVsbCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMucG9ydCA9PSBudWxsICYmICFvcHRpb25zLnNlcnZlciAmJiAhb3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ09uZSBvZiB0aGUgXCJwb3J0XCIsIFwic2VydmVyXCIsIG9yIFwibm9TZXJ2ZXJcIiBvcHRpb25zIG11c3QgYmUgc3BlY2lmaWVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IGNyZWF0ZVNlcnZlcigocmVxLCByZXMpID0+IHtcbiAgICAgICAgY29uc3QgYm9keSA9IFNUQVRVU19DT0RFU1s0MjZdO1xuXG4gICAgICAgIHJlcy53cml0ZUhlYWQoNDI2LCB7XG4gICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogYm9keS5sZW5ndGgsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLmVuZChib2R5KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2VydmVyLmxpc3RlbihcbiAgICAgICAgb3B0aW9ucy5wb3J0LFxuICAgICAgICBvcHRpb25zLmhvc3QsXG4gICAgICAgIG9wdGlvbnMuYmFja2xvZyxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNlcnZlcikge1xuICAgICAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gYWRkTGlzdGVuZXJzKHRoaXMuX3NlcnZlciwge1xuICAgICAgICBsaXN0ZW5pbmc6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdsaXN0ZW5pbmcnKSxcbiAgICAgICAgZXJyb3I6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpLFxuICAgICAgICB1cGdyYWRlOiAocmVxLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsICh3cykgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0aW9uJywgd3MsIHJlcSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlID09PSB0cnVlKSBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XG4gICAgaWYgKG9wdGlvbnMuY2xpZW50VHJhY2tpbmcpIHRoaXMuY2xpZW50cyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJvdW5kIGFkZHJlc3MsIHRoZSBhZGRyZXNzIGZhbWlseSBuYW1lLCBhbmQgcG9ydCBvZiB0aGUgc2VydmVyXG4gICAqIGFzIHJlcG9ydGVkIGJ5IHRoZSBvcGVyYXRpbmcgc3lzdGVtIGlmIGxpc3RlbmluZyBvbiBhbiBJUCBzb2NrZXQuXG4gICAqIElmIHRoZSBzZXJ2ZXIgaXMgbGlzdGVuaW5nIG9uIGEgcGlwZSBvciBVTklYIGRvbWFpbiBzb2NrZXQsIHRoZSBuYW1lIGlzXG4gICAqIHJldHVybmVkIGFzIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoT2JqZWN0fFN0cmluZ3xudWxsKX0gVGhlIGFkZHJlc3Mgb2YgdGhlIHNlcnZlclxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRyZXNzKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubm9TZXJ2ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlcnZlciBpcyBvcGVyYXRpbmcgaW4gXCJub1NlcnZlclwiIG1vZGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3NlcnZlcikgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuX3NlcnZlci5hZGRyZXNzKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2UgdGhlIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY2IpIHtcbiAgICBpZiAoY2IpIHRoaXMub25jZSgnY2xvc2UnLCBjYik7XG5cbiAgICAvL1xuICAgIC8vIFRlcm1pbmF0ZSBhbGwgYXNzb2NpYXRlZCBjbGllbnRzLlxuICAgIC8vXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgZm9yIChjb25zdCBjbGllbnQgb2YgdGhpcy5jbGllbnRzKSBjbGllbnQudGVybWluYXRlKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyID0gdGhpcy5fc2VydmVyO1xuXG4gICAgaWYgKHNlcnZlcikge1xuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuXG4gICAgICAvL1xuICAgICAgLy8gQ2xvc2UgdGhlIGh0dHAgc2VydmVyIGlmIGl0IHdhcyBpbnRlcm5hbGx5IGNyZWF0ZWQuXG4gICAgICAvL1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgICAgc2VydmVyLmNsb3NlKCgpID0+IHRoaXMuZW1pdCgnY2xvc2UnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogU2VlIGlmIGEgZ2l2ZW4gcmVxdWVzdCBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGlzIHNlcnZlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFJlcXVlc3Qgb2JqZWN0IHRvIGluc3BlY3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSByZXF1ZXN0IGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2hvdWxkSGFuZGxlKHJlcSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMucGF0aCkge1xuICAgICAgY29uc3QgaW5kZXggPSByZXEudXJsLmluZGV4T2YoJz8nKTtcbiAgICAgIGNvbnN0IHBhdGhuYW1lID0gaW5kZXggIT09IC0xID8gcmVxLnVybC5zbGljZSgwLCBpbmRleCkgOiByZXEudXJsO1xuXG4gICAgICBpZiAocGF0aG5hbWUgIT09IHRoaXMub3B0aW9ucy5wYXRoKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGEgSFRUUCBVcGdyYWRlIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAgICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBoYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIGNvbnN0IGtleSA9XG4gICAgICByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J10udHJpbSgpXG4gICAgICAgIDogZmFsc2U7XG4gICAgY29uc3QgdmVyc2lvbiA9ICtyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC12ZXJzaW9uJ107XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgaWYgKFxuICAgICAgcmVxLm1ldGhvZCAhPT0gJ0dFVCcgfHxcbiAgICAgIHJlcS5oZWFkZXJzLnVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcgfHxcbiAgICAgICFrZXkgfHxcbiAgICAgICFrZXlSZWdleC50ZXN0KGtleSkgfHxcbiAgICAgICh2ZXJzaW9uICE9PSA4ICYmIHZlcnNpb24gIT09IDEzKSB8fFxuICAgICAgIXRoaXMuc2hvdWxkSGFuZGxlKHJlcSlcbiAgICApIHtcbiAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXG4gICAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgdGhpcy5vcHRpb25zLm1heFBheWxvYWRcbiAgICAgICk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9mZmVycyA9IHBhcnNlKHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXSk7XG5cbiAgICAgICAgaWYgKG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgY2xpZW50IHZlcmlmaWNhdGlvbiBoYW5kbGVyLlxuICAgIC8vXG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIG9yaWdpbjpcbiAgICAgICAgICByZXEuaGVhZGVyc1tgJHt2ZXJzaW9uID09PSA4ID8gJ3NlYy13ZWJzb2NrZXQtb3JpZ2luJyA6ICdvcmlnaW4nfWBdLFxuICAgICAgICBzZWN1cmU6ICEhKHJlcS5jb25uZWN0aW9uLmF1dGhvcml6ZWQgfHwgcmVxLmNvbm5lY3Rpb24uZW5jcnlwdGVkKSxcbiAgICAgICAgcmVxXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvLCAodmVyaWZpZWQsIGNvZGUsIG1lc3NhZ2UsIGhlYWRlcnMpID0+IHtcbiAgICAgICAgICBpZiAoIXZlcmlmaWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlIHx8IDQwMSwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoa2V5LCBleHRlbnNpb25zLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoa2V5LCBleHRlbnNpb25zLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZ3JhZGUgdGhlIGNvbm5lY3Rpb24gdG8gV2ViU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSB2YWx1ZSBvZiB0aGUgYFNlYy1XZWJTb2NrZXQtS2V5YCBoZWFkZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIGFjY2VwdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge25ldC5Tb2NrZXR9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSBzb2NrZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbXBsZXRlVXBncmFkZShrZXksIGV4dGVuc2lvbnMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIC8vXG4gICAgLy8gRGVzdHJveSB0aGUgc29ja2V0IGlmIHRoZSBjbGllbnQgaGFzIGFscmVhZHkgc2VudCBhIEZJTiBwYWNrZXQuXG4gICAgLy9cbiAgICBpZiAoIXNvY2tldC5yZWFkYWJsZSB8fCAhc29ja2V0LndyaXRhYmxlKSByZXR1cm4gc29ja2V0LmRlc3Ryb3koKTtcblxuICAgIGlmIChzb2NrZXRba1dlYlNvY2tldF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3NlcnZlci5oYW5kbGVVcGdyYWRlKCkgd2FzIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lICcgK1xuICAgICAgICAgICdzb2NrZXQsIHBvc3NpYmx5IGR1ZSB0byBhIG1pc2NvbmZpZ3VyYXRpb24nXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBjb25zdCBoZWFkZXJzID0gW1xuICAgICAgJ0hUVFAvMS4xIDEwMSBTd2l0Y2hpbmcgUHJvdG9jb2xzJyxcbiAgICAgICdVcGdyYWRlOiB3ZWJzb2NrZXQnLFxuICAgICAgJ0Nvbm5lY3Rpb246IFVwZ3JhZGUnLFxuICAgICAgYFNlYy1XZWJTb2NrZXQtQWNjZXB0OiAke2RpZ2VzdH1gXG4gICAgXTtcblxuICAgIGNvbnN0IHdzID0gbmV3IFdlYlNvY2tldChudWxsKTtcbiAgICBsZXQgcHJvdG9jb2wgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuXG4gICAgaWYgKHByb3RvY29sKSB7XG4gICAgICBwcm90b2NvbCA9IHByb3RvY29sLnRyaW0oKS5zcGxpdCgvICosICovKTtcblxuICAgICAgLy9cbiAgICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBwcm90b2NvbCBzZWxlY3Rpb24gaGFuZGxlci5cbiAgICAgIC8vXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29scykge1xuICAgICAgICBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHMocHJvdG9jb2wsIHJlcSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm90b2NvbCA9IHByb3RvY29sWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvdG9jb2wpIHtcbiAgICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LVByb3RvY29sOiAke3Byb3RvY29sfWApO1xuICAgICAgICB3cy5wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLnBhcmFtcztcbiAgICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0KHtcbiAgICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBbcGFyYW1zXVxuICAgICAgfSk7XG4gICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uczogJHt2YWx1ZX1gKTtcbiAgICAgIHdzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IGV4dGVybmFsIG1vZGlmaWNhdGlvbi9pbnNwZWN0aW9uIG9mIGhhbmRzaGFrZSBoZWFkZXJzLlxuICAgIC8vXG4gICAgdGhpcy5lbWl0KCdoZWFkZXJzJywgaGVhZGVycywgcmVxKTtcblxuICAgIHNvY2tldC53cml0ZShoZWFkZXJzLmNvbmNhdCgnXFxyXFxuJykuam9pbignXFxyXFxuJykpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHdzLnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkKTtcblxuICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgIHRoaXMuY2xpZW50cy5hZGQod3MpO1xuICAgICAgd3Mub24oJ2Nsb3NlJywgKCkgPT4gdGhpcy5jbGllbnRzLmRlbGV0ZSh3cykpO1xuICAgIH1cblxuICAgIGNiKHdzKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNlcnZlcjtcblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXJzIG9uIGFuIGBFdmVudEVtaXR0ZXJgIHVzaW5nIGEgbWFwIG9mIDxldmVudCwgbGlzdGVuZXI+XG4gKiBwYWlycy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IG1hcCBUaGUgbGlzdGVuZXJzIHRvIGFkZFxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlbW92ZSB0aGUgYWRkZWQgbGlzdGVuZXJzIHdoZW4gY2FsbGVkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcnMoc2VydmVyLCBtYXApIHtcbiAgZm9yIChjb25zdCBldmVudCBvZiBPYmplY3Qua2V5cyhtYXApKSBzZXJ2ZXIub24oZXZlbnQsIG1hcFtldmVudF0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBPYmplY3Qua2V5cyhtYXApKSB7XG4gICAgICBzZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIG1hcFtldmVudF0pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBFbWl0IGEgYCdjbG9zZSdgIGV2ZW50IG9uIGFuIGBFdmVudEVtaXR0ZXJgLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBzZXJ2ZXIgVGhlIGV2ZW50IGVtaXR0ZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVtaXRDbG9zZShzZXJ2ZXIpIHtcbiAgc2VydmVyLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbi8qKlxuICogSGFuZGxlIHByZW1hdHVyZSBzb2NrZXQgZXJyb3JzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIHRoaXMuZGVzdHJveSgpO1xufVxuXG4vKipcbiAqIENsb3NlIHRoZSBjb25uZWN0aW9uIHdoZW4gcHJlY29uZGl0aW9ucyBhcmUgbm90IGZ1bGZpbGxlZC5cbiAqXG4gKiBAcGFyYW0ge25ldC5Tb2NrZXR9IHNvY2tldCBUaGUgc29ja2V0IG9mIHRoZSB1cGdyYWRlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc10gQWRkaXRpb25hbCBIVFRQIHJlc3BvbnNlIGhlYWRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykge1xuICBpZiAoc29ja2V0LndyaXRhYmxlKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgU1RBVFVTX0NPREVTW2NvZGVdO1xuICAgIGhlYWRlcnMgPSB7XG4gICAgICBDb25uZWN0aW9uOiAnY2xvc2UnLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L2h0bWwnLFxuICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogQnVmZmVyLmJ5dGVMZW5ndGgobWVzc2FnZSksXG4gICAgICAuLi5oZWFkZXJzXG4gICAgfTtcblxuICAgIHNvY2tldC53cml0ZShcbiAgICAgIGBIVFRQLzEuMSAke2NvZGV9ICR7U1RBVFVTX0NPREVTW2NvZGVdfVxcclxcbmAgK1xuICAgICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgICAgIC5tYXAoKGgpID0+IGAke2h9OiAke2hlYWRlcnNbaF19YClcbiAgICAgICAgICAuam9pbignXFxyXFxuJykgK1xuICAgICAgICAnXFxyXFxuXFxyXFxuJyArXG4gICAgICAgIG1lc3NhZ2VcbiAgICApO1xuICB9XG5cbiAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuICBzb2NrZXQuZGVzdHJveSgpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/websocket-server.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/websocket.js":
/*!****************************************************************!*\
  !*** /Users/sri/Dev/INQ/gsgo/node_modules/ws/lib/websocket.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../../node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"../../node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"../../node_modules/ws/lib/sender.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"../../node_modules/ws/lib/constants.js\");\nconst { addEventListener, removeEventListener } = __webpack_require__(/*! ./event-target */ \"../../node_modules/ws/lib/event-target.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"../../node_modules/ws/lib/extension.js\");\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"../../node_modules/ws/lib/buffer-util.js\");\n\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|url.URL)} address The URL to which to connect\n   * @param {(String|String[])} protocols The subprotocols\n   * @param {Object} options Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this.readyState = WebSocket.CONNECTING;\n    this.protocol = '';\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = '';\n    this._closeTimer = null;\n    this._closeCode = 1006;\n    this._extensions = {};\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (Array.isArray(protocols)) {\n        protocols = protocols.join(', ');\n      } else if (typeof protocols === 'object' && protocols !== null) {\n        options = protocols;\n        protocols = undefined;\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n\n  get CONNECTING() {\n    return WebSocket.CONNECTING;\n  }\n  get CLOSING() {\n    return WebSocket.CLOSING;\n  }\n  get CLOSED() {\n    return WebSocket.CLOSED;\n  }\n  get OPEN() {\n    return WebSocket.OPEN;\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Number} maxPayload The maximum allowed message size\n   * @private\n   */\n  setSocket(socket, head, maxPayload) {\n    const receiver = new Receiver(\n      this._binaryType,\n      this._extensions,\n      this._isServer,\n      maxPayload\n    );\n\n    this._sender = new Sender(socket, this._extensions);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this.readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this.readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this.readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} code Status code explaining why the connection is closing\n   * @param {String} data A string explaining why the connection is closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();\n      return;\n    }\n\n    this.readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n      if (this._closeFrameReceived) this._socket.end();\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this.readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\nreadyStates.forEach((readyState, i) => {\n  WebSocket[readyState] = i;\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    /**\n     * Return the listener of the event.\n     *\n     * @return {(Function|undefined)} The event listener or `undefined`\n     * @public\n     */\n    get() {\n      const listeners = this.listeners(method);\n      for (let i = 0; i < listeners.length; i++) {\n        if (listeners[i]._listener) return listeners[i]._listener;\n      }\n\n      return undefined;\n    },\n    /**\n     * Add a listener for the event.\n     *\n     * @param {Function} listener The listener to add\n     * @public\n     */\n    set(listener) {\n      const listeners = this.listeners(method);\n      for (let i = 0; i < listeners.length; i++) {\n        //\n        // Remove only the listeners added via `addEventListener`.\n        //\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n      }\n      this.addEventListener(method, listener);\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|url.URL)} address The URL to which to connect\n * @param {String} protocols The subprotocols\n * @param {Object} options Connection options\n * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable\n *     permessage-deflate\n * @param {Number} options.handshakeTimeout Timeout in milliseconds for the\n *     handshake request\n * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version`\n *     header\n * @param {String} options.origin Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {Number} options.maxPayload The maximum allowed message size\n * @param {Boolean} options.followRedirects Whether or not to follow redirects\n * @param {Number} options.maxRedirects The maximum number of redirects allowed\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: undefined,\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket.url = address.href;\n  } else {\n    parsedUrl = new URL(address);\n    websocket.url = address;\n  }\n\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n\n  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {\n    throw new Error(`Invalid URL: ${websocket.url}`);\n  }\n\n  const isSecure =\n    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const get = isSecure ? https.get : http.get;\n  let perMessageDeflate;\n\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket',\n    ...opts.headers\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols) {\n    opts.headers['Sec-WebSocket-Protocol'] = protocols;\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req = (websocket._req = get(opts));\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (websocket._req.aborted) return;\n\n    req = websocket._req = null;\n    websocket.readyState = WebSocket.CLOSING;\n    websocket.emit('error', err);\n    websocket.emitClose();\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      const addr = new URL(location, address);\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    const protList = (protocols || '').split(/, */);\n    let protError;\n\n    if (!protocols && serverProt) {\n      protError = 'Server sent a subprotocol but none was requested';\n    } else if (protocols && !serverProt) {\n      protError = 'Server sent no subprotocol';\n    } else if (serverProt && !protList.includes(serverProt)) {\n      protError = 'Server sent an invalid subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket.protocol = serverProt;\n\n    if (perMessageDeflate) {\n      try {\n        const extensions = parse(res.headers['sec-websocket-extensions']);\n\n        if (extensions[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n          websocket._extensions[\n            PerMessageDeflate.extensionName\n          ] = perMessageDeflate;\n        }\n      } catch (err) {\n        abortHandshake(\n          websocket,\n          socket,\n          'Invalid Sec-WebSocket-Extensions header'\n        );\n        return;\n      }\n    }\n\n    websocket.setSocket(socket, head, opts.maxPayload);\n  });\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the\n *     socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket.readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} data The data to send\n * @param {Function} cb Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    cb(err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {String} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n  websocket._socket.resume();\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  this[kWebSocket]._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n\n  websocket.readyState = WebSocket.CLOSING;\n  websocket._closeCode = err[kStatusCode];\n  websocket.emit('error', err);\n  websocket._socket.destroy();\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message\n * @private\n */\nfunction receiverOnMessage(data) {\n  this[kWebSocket].emit('message', data);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('end', socketOnEnd);\n\n  websocket.readyState = WebSocket.CLOSING;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk and emitted synchronously in a single\n  // `'data'` event.\n  //\n  websocket._socket.read();\n  websocket._receiver.end();\n\n  this.removeListener('data', socketOnData);\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket.readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket.readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3NyaS9EZXYvSU5RL2dzZ28vbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQuanM/MmZjMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixxQkFBcUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNyQyxjQUFjLG1CQUFPLENBQUMsb0JBQU87QUFDN0IsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsT0FBTywwQkFBMEIsR0FBRyxtQkFBTyxDQUFDLHNCQUFRO0FBQ3BELE9BQU8sTUFBTSxHQUFHLG1CQUFPLENBQUMsZ0JBQUs7O0FBRTdCLDBCQUEwQixtQkFBTyxDQUFDLDZFQUFzQjtBQUN4RCxpQkFBaUIsbUJBQU8sQ0FBQyx5REFBWTtBQUNyQyxlQUFlLG1CQUFPLENBQUMscURBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUcsbUJBQU8sQ0FBQywyREFBYTtBQUN6QixPQUFPLHdDQUF3QyxHQUFHLG1CQUFPLENBQUMsaUVBQWdCO0FBQzFFLE9BQU8sZ0JBQWdCLEdBQUcsbUJBQU8sQ0FBQywyREFBYTtBQUMvQyxPQUFPLFdBQVcsR0FBRyxtQkFBTyxDQUFDLCtEQUFlOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFD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IiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgeyByYW5kb21CeXRlcywgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlcicpO1xuY29uc3QgU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXInKTtcbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVIsXG4gIEdVSUQsXG4gIGtTdGF0dXNDb2RlLFxuICBrV2ViU29ja2V0LFxuICBOT09QXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi9ldmVudC10YXJnZXQnKTtcbmNvbnN0IHsgZm9ybWF0LCBwYXJzZSB9ID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IHsgdG9CdWZmZXIgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcblxuY29uc3QgcmVhZHlTdGF0ZXMgPSBbJ0NPTk5FQ1RJTkcnLCAnT1BFTicsICdDTE9TSU5HJywgJ0NMT1NFRCddO1xuY29uc3QgcHJvdG9jb2xWZXJzaW9ucyA9IFs4LCAxM107XG5jb25zdCBjbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBXZWJTb2NrZXRgLlxuICAgKlxuICAgKiBAcGFyYW0geyhTdHJpbmd8dXJsLlVSTCl9IGFkZHJlc3MgVGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XG4gICAqIEBwYXJhbSB7KFN0cmluZ3xTdHJpbmdbXSl9IHByb3RvY29scyBUaGUgc3VicHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DT05ORUNUSU5HO1xuICAgIHRoaXMucHJvdG9jb2wgPSAnJztcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZU1lc3NhZ2UgPSAnJztcbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9jbG9zZUNvZGUgPSAxMDA2O1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLl9yZWNlaXZlciA9IG51bGw7XG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcbiAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuXG4gICAgaWYgKGFkZHJlc3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWRpcmVjdHMgPSAwO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgICAgIHByb3RvY29scyA9IHByb3RvY29scy5qb2luKCcsICcpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnb2JqZWN0JyAmJiBwcm90b2NvbHMgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHByb3RvY29scztcbiAgICAgICAgcHJvdG9jb2xzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpbml0QXNDbGllbnQodGhpcywgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXNTZXJ2ZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGdldCBDT05ORUNUSU5HKCkge1xuICAgIHJldHVybiBXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgfVxuICBnZXQgQ0xPU0lORygpIHtcbiAgICByZXR1cm4gV2ViU29ja2V0LkNMT1NJTkc7XG4gIH1cbiAgZ2V0IENMT1NFRCgpIHtcbiAgICByZXR1cm4gV2ViU29ja2V0LkNMT1NFRDtcbiAgfVxuICBnZXQgT1BFTigpIHtcbiAgICByZXR1cm4gV2ViU29ja2V0Lk9QRU47XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBkZXZpYXRlcyBmcm9tIHRoZSBXSEFUV0cgaW50ZXJmYWNlIHNpbmNlIHdzIGRvZXNuJ3Qgc3VwcG9ydCB0aGVcbiAgICogcmVxdWlyZWQgZGVmYXVsdCBcImJsb2JcIiB0eXBlIChpbnN0ZWFkIHdlIGRlZmluZSBhIGN1c3RvbSBcIm5vZGVidWZmZXJcIlxuICAgKiB0eXBlKS5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBiaW5hcnlUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9iaW5hcnlUeXBlO1xuICB9XG5cbiAgc2V0IGJpbmFyeVR5cGUodHlwZSkge1xuICAgIGlmICghQklOQVJZX1RZUEVTLmluY2x1ZGVzKHR5cGUpKSByZXR1cm47XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcblxuICAgIC8vXG4gICAgLy8gQWxsb3cgdG8gY2hhbmdlIGBiaW5hcnlUeXBlYCBvbiB0aGUgZmx5LlxuICAgIC8vXG4gICAgaWYgKHRoaXMuX3JlY2VpdmVyKSB0aGlzLl9yZWNlaXZlci5fYmluYXJ5VHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBidWZmZXJlZEFtb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkQW1vdW50O1xuXG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5sZW5ndGggKyB0aGlzLl9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBleHRlbnNpb25zKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9leHRlbnNpb25zKS5qb2luKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIHRoZSBzb2NrZXQgYW5kIHRoZSBpbnRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bmV0LlNvY2tldH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFBheWxvYWQgVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIHNpemVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFNvY2tldChzb2NrZXQsIGhlYWQsIG1heFBheWxvYWQpIHtcbiAgICBjb25zdCByZWNlaXZlciA9IG5ldyBSZWNlaXZlcihcbiAgICAgIHRoaXMuX2JpbmFyeVR5cGUsXG4gICAgICB0aGlzLl9leHRlbnNpb25zLFxuICAgICAgdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBtYXhQYXlsb2FkXG4gICAgKTtcblxuICAgIHRoaXMuX3NlbmRlciA9IG5ldyBTZW5kZXIoc29ja2V0LCB0aGlzLl9leHRlbnNpb25zKTtcbiAgICB0aGlzLl9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHJlY2VpdmVyW2tXZWJTb2NrZXRdID0gdGhpcztcbiAgICBzb2NrZXRba1dlYlNvY2tldF0gPSB0aGlzO1xuXG4gICAgcmVjZWl2ZXIub24oJ2NvbmNsdWRlJywgcmVjZWl2ZXJPbkNvbmNsdWRlKTtcbiAgICByZWNlaXZlci5vbignZHJhaW4nLCByZWNlaXZlck9uRHJhaW4pO1xuICAgIHJlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25FcnJvcik7XG4gICAgcmVjZWl2ZXIub24oJ21lc3NhZ2UnLCByZWNlaXZlck9uTWVzc2FnZSk7XG4gICAgcmVjZWl2ZXIub24oJ3BpbmcnLCByZWNlaXZlck9uUGluZyk7XG4gICAgcmVjZWl2ZXIub24oJ3BvbmcnLCByZWNlaXZlck9uUG9uZyk7XG5cbiAgICBzb2NrZXQuc2V0VGltZW91dCgwKTtcbiAgICBzb2NrZXQuc2V0Tm9EZWxheSgpO1xuXG4gICAgaWYgKGhlYWQubGVuZ3RoID4gMCkgc29ja2V0LnVuc2hpZnQoaGVhZCk7XG5cbiAgICBzb2NrZXQub24oJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XG4gICAgc29ja2V0Lm9uKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgICBzb2NrZXQub24oJ2VuZCcsIHNvY2tldE9uRW5kKTtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuT1BFTjtcbiAgICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbWl0Q2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLmNsZWFudXAoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWNlaXZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSBjbG9zaW5nIGhhbmRzaGFrZS5cbiAgICpcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tK1xuICAgKiAgICAgLSAtIC18d3MuY2xvc2UoKXwtLT58Y2xvc2UgZnJhbWV8LS0+fHdzLmNsb3NlKCl8LSAtIC1cbiAgICogICAgfCAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tKyAgICAgfFxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgICAgICAgfFxuICAgKiBDTE9TSU5HICB8d3MuY2xvc2UoKXw8LS18Y2xvc2UgZnJhbWV8PC0tKy0tLS0tKyAgICAgICBDTE9TSU5HXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICB8XG4gICAqICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLSsgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLT58ZmlufCAtIC0gLSAtXG4gICAqICAgIHwgICAgICAgICArLS0tKyAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLStcbiAgICogICAgIC0gLSAtIC0gLXxmaW58PC0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICogICAgICAgICAgICAgICstLS0rXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgQSBzdHJpbmcgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TSU5HKSB7XG4gICAgICBpZiAodGhpcy5fY2xvc2VGcmFtZVNlbnQgJiYgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkKSB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5fc2VuZGVyLmNsb3NlKGNvZGUsIGRhdGEsICF0aGlzLl9pc1NlcnZlciwgKGVycikgPT4ge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgaGFuZGxlZCBieSB0aGUgYCdlcnJvcidgIGxpc3RlbmVyIG9uIHRoZSBzb2NrZXQuIFdlIG9ubHlcbiAgICAgIC8vIHdhbnQgdG8ga25vdyBpZiB0aGUgY2xvc2UgZnJhbWUgaGFzIGJlZW4gc2VudCBoZXJlLlxuICAgICAgLy9cbiAgICAgIGlmIChlcnIpIHJldHVybjtcblxuICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCkgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgIH0pO1xuXG4gICAgLy9cbiAgICAvLyBTcGVjaWZ5IGEgdGltZW91dCBmb3IgdGhlIGNsb3NpbmcgaGFuZHNoYWtlIHRvIGNvbXBsZXRlLlxuICAgIC8vXG4gICAgdGhpcy5fY2xvc2VUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveS5iaW5kKHRoaXMuX3NvY2tldCksXG4gICAgICBjbG9zZVRpbWVvdXRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwaW5nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBpbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwaW5nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBpbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgcG9uZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBwb25nIGlzIHNlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBkYXRhO1xuICAgICAgZGF0YSA9IG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBtYXNrO1xuICAgICAgbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWFzayA9PT0gdW5kZWZpbmVkKSBtYXNrID0gIXRoaXMuX2lzU2VydmVyO1xuICAgIHRoaXMuX3NlbmRlci5wb25nKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBtYXNrLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmNvbXByZXNzIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5iaW5hcnkgU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeSBvciB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5maW4gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZSBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMubWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiBkYXRhIGlzIHdyaXR0ZW4gb3V0XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgYmluYXJ5OiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycsXG4gICAgICBtYXNrOiAhdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBjb21wcmVzczogdHJ1ZSxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fc2VuZGVyLnNlbmQoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG9wdHMsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjaWJseSBjbG9zZSB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdGVybWluYXRlKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59XG5cbnJlYWR5U3RhdGVzLmZvckVhY2goKHJlYWR5U3RhdGUsIGkpID0+IHtcbiAgV2ViU29ja2V0W3JlYWR5U3RhdGVdID0gaTtcbn0pO1xuXG4vL1xuLy8gQWRkIHRoZSBgb25vcGVuYCwgYG9uZXJyb3JgLCBgb25jbG9zZWAsIGFuZCBgb25tZXNzYWdlYCBhdHRyaWJ1dGVzLlxuLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjdGhlLXdlYnNvY2tldC1pbnRlcmZhY2Vcbi8vXG5bJ29wZW4nLCAnZXJyb3InLCAnY2xvc2UnLCAnbWVzc2FnZSddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgYG9uJHttZXRob2R9YCwge1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbGlzdGVuZXIgb2YgdGhlIGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7KEZ1bmN0aW9ufHVuZGVmaW5lZCl9IFRoZSBldmVudCBsaXN0ZW5lciBvciBgdW5kZWZpbmVkYFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyhtZXRob2QpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5fbGlzdGVuZXIpIHJldHVybiBsaXN0ZW5lcnNbaV0uX2xpc3RlbmVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgZm9yIHRoZSBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBhZGRcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2V0KGxpc3RlbmVyKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyhtZXRob2QpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gUmVtb3ZlIG9ubHkgdGhlIGxpc3RlbmVycyBhZGRlZCB2aWEgYGFkZEV2ZW50TGlzdGVuZXJgLlxuICAgICAgICAvL1xuICAgICAgICBpZiAobGlzdGVuZXJzW2ldLl9saXN0ZW5lcikgdGhpcy5yZW1vdmVMaXN0ZW5lcihtZXRob2QsIGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5XZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuV2ViU29ja2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIFdlYlNvY2tldCBjbGllbnQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgY2xpZW50IHRvIGluaXRpYWxpemVcbiAqIEBwYXJhbSB7KFN0cmluZ3x1cmwuVVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgRW5hYmxlL2Rpc2FibGVcbiAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmhhbmRzaGFrZVRpbWVvdXQgVGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZVxuICogICAgIGhhbmRzaGFrZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wcm90b2NvbFZlcnNpb24gVmFsdWUgb2YgdGhlIGBTZWMtV2ViU29ja2V0LVZlcnNpb25gXG4gKiAgICAgaGVhZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5vcmlnaW4gVmFsdWUgb2YgdGhlIGBPcmlnaW5gIG9yXG4gKiAgICAgYFNlYy1XZWJTb2NrZXQtT3JpZ2luYCBoZWFkZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm1heFBheWxvYWQgVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIHNpemVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHMgV2hldGhlciBvciBub3QgdG8gZm9sbG93IHJlZGlyZWN0c1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMubWF4UmVkaXJlY3RzIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZWRpcmVjdHMgYWxsb3dlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgcHJvdG9jb2xWZXJzaW9uOiBwcm90b2NvbFZlcnNpb25zWzFdLFxuICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0cnVlLFxuICAgIGZvbGxvd1JlZGlyZWN0czogZmFsc2UsXG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcbiAgICAuLi5vcHRpb25zLFxuICAgIGNyZWF0ZUNvbm5lY3Rpb246IHVuZGVmaW5lZCxcbiAgICBzb2NrZXRQYXRoOiB1bmRlZmluZWQsXG4gICAgaG9zdG5hbWU6IHVuZGVmaW5lZCxcbiAgICBwcm90b2NvbDogdW5kZWZpbmVkLFxuICAgIHRpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICBtZXRob2Q6IHVuZGVmaW5lZCxcbiAgICBob3N0OiB1bmRlZmluZWQsXG4gICAgcGF0aDogdW5kZWZpbmVkLFxuICAgIHBvcnQ6IHVuZGVmaW5lZFxuICB9O1xuXG4gIGlmICghcHJvdG9jb2xWZXJzaW9ucy5pbmNsdWRlcyhvcHRzLnByb3RvY29sVmVyc2lvbikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgIGBVbnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uOiAke29wdHMucHJvdG9jb2xWZXJzaW9ufSBgICtcbiAgICAgICAgYChzdXBwb3J0ZWQgdmVyc2lvbnM6ICR7cHJvdG9jb2xWZXJzaW9ucy5qb2luKCcsICcpfSlgXG4gICAgKTtcbiAgfVxuXG4gIGxldCBwYXJzZWRVcmw7XG5cbiAgaWYgKGFkZHJlc3MgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBwYXJzZWRVcmwgPSBhZGRyZXNzO1xuICAgIHdlYnNvY2tldC51cmwgPSBhZGRyZXNzLmhyZWY7XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkVXJsID0gbmV3IFVSTChhZGRyZXNzKTtcbiAgICB3ZWJzb2NrZXQudXJsID0gYWRkcmVzcztcbiAgfVxuXG4gIGNvbnN0IGlzVW5peFNvY2tldCA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzK3VuaXg6JztcblxuICBpZiAoIXBhcnNlZFVybC5ob3N0ICYmICghaXNVbml4U29ja2V0IHx8ICFwYXJzZWRVcmwucGF0aG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFVSTDogJHt3ZWJzb2NrZXQudXJsfWApO1xuICB9XG5cbiAgY29uc3QgaXNTZWN1cmUgPVxuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzczonIHx8IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gIGNvbnN0IGRlZmF1bHRQb3J0ID0gaXNTZWN1cmUgPyA0NDMgOiA4MDtcbiAgY29uc3Qga2V5ID0gcmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgY29uc3QgZ2V0ID0gaXNTZWN1cmUgPyBodHRwcy5nZXQgOiBodHRwLmdldDtcbiAgbGV0IHBlck1lc3NhZ2VEZWZsYXRlO1xuXG4gIG9wdHMuY3JlYXRlQ29ubmVjdGlvbiA9IGlzU2VjdXJlID8gdGxzQ29ubmVjdCA6IG5ldENvbm5lY3Q7XG4gIG9wdHMuZGVmYXVsdFBvcnQgPSBvcHRzLmRlZmF1bHRQb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRzLnBvcnQgPSBwYXJzZWRVcmwucG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5ob3N0ID0gcGFyc2VkVXJsLmhvc3RuYW1lLnN0YXJ0c1dpdGgoJ1snKVxuICAgID8gcGFyc2VkVXJsLmhvc3RuYW1lLnNsaWNlKDEsIC0xKVxuICAgIDogcGFyc2VkVXJsLmhvc3RuYW1lO1xuICBvcHRzLmhlYWRlcnMgPSB7XG4gICAgJ1NlYy1XZWJTb2NrZXQtVmVyc2lvbic6IG9wdHMucHJvdG9jb2xWZXJzaW9uLFxuICAgICdTZWMtV2ViU29ja2V0LUtleSc6IGtleSxcbiAgICBDb25uZWN0aW9uOiAnVXBncmFkZScsXG4gICAgVXBncmFkZTogJ3dlYnNvY2tldCcsXG4gICAgLi4ub3B0cy5oZWFkZXJzXG4gIH07XG4gIG9wdHMucGF0aCA9IHBhcnNlZFVybC5wYXRobmFtZSArIHBhcnNlZFVybC5zZWFyY2g7XG4gIG9wdHMudGltZW91dCA9IG9wdHMuaGFuZHNoYWtlVGltZW91dDtcblxuICBpZiAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSAhPT0gdHJ1ZSA/IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgOiB7fSxcbiAgICAgIGZhbHNlLFxuICAgICAgb3B0cy5tYXhQYXlsb2FkXG4gICAgKTtcbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyddID0gZm9ybWF0KHtcbiAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogcGVyTWVzc2FnZURlZmxhdGUub2ZmZXIoKVxuICAgIH0pO1xuICB9XG4gIGlmIChwcm90b2NvbHMpIHtcbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnXSA9IHByb3RvY29scztcbiAgfVxuICBpZiAob3B0cy5vcmlnaW4pIHtcbiAgICBpZiAob3B0cy5wcm90b2NvbFZlcnNpb24gPCAxMykge1xuICAgICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LU9yaWdpbiddID0gb3B0cy5vcmlnaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMuaGVhZGVycy5PcmlnaW4gPSBvcHRzLm9yaWdpbjtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcnNlZFVybC51c2VybmFtZSB8fCBwYXJzZWRVcmwucGFzc3dvcmQpIHtcbiAgICBvcHRzLmF1dGggPSBgJHtwYXJzZWRVcmwudXNlcm5hbWV9OiR7cGFyc2VkVXJsLnBhc3N3b3JkfWA7XG4gIH1cblxuICBpZiAoaXNVbml4U29ja2V0KSB7XG4gICAgY29uc3QgcGFydHMgPSBvcHRzLnBhdGguc3BsaXQoJzonKTtcblxuICAgIG9wdHMuc29ja2V0UGF0aCA9IHBhcnRzWzBdO1xuICAgIG9wdHMucGF0aCA9IHBhcnRzWzFdO1xuICB9XG5cbiAgbGV0IHJlcSA9ICh3ZWJzb2NrZXQuX3JlcSA9IGdldChvcHRzKSk7XG5cbiAgaWYgKG9wdHMudGltZW91dCkge1xuICAgIHJlcS5vbigndGltZW91dCcsICgpID0+IHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnT3BlbmluZyBoYW5kc2hha2UgaGFzIHRpbWVkIG91dCcpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVxLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICBpZiAod2Vic29ja2V0Ll9yZXEuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSBudWxsO1xuICAgIHdlYnNvY2tldC5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG4gIH0pO1xuXG4gIHJlcS5vbigncmVzcG9uc2UnLCAocmVzKSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSByZXMuaGVhZGVycy5sb2NhdGlvbjtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XG5cbiAgICBpZiAoXG4gICAgICBsb2NhdGlvbiAmJlxuICAgICAgb3B0cy5mb2xsb3dSZWRpcmVjdHMgJiZcbiAgICAgIHN0YXR1c0NvZGUgPj0gMzAwICYmXG4gICAgICBzdGF0dXNDb2RlIDwgNDAwXG4gICAgKSB7XG4gICAgICBpZiAoKyt3ZWJzb2NrZXQuX3JlZGlyZWN0cyA+IG9wdHMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnTWF4aW11bSByZWRpcmVjdHMgZXhjZWVkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXEuYWJvcnQoKTtcblxuICAgICAgY29uc3QgYWRkciA9IG5ldyBVUkwobG9jYXRpb24sIGFkZHJlc3MpO1xuXG4gICAgICBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoIXdlYnNvY2tldC5lbWl0KCd1bmV4cGVjdGVkLXJlc3BvbnNlJywgcmVxLCByZXMpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShcbiAgICAgICAgd2Vic29ja2V0LFxuICAgICAgICByZXEsXG4gICAgICAgIGBVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZTogJHtyZXMuc3RhdHVzQ29kZX1gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmVxLm9uKCd1cGdyYWRlJywgKHJlcywgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgd2Vic29ja2V0LmVtaXQoJ3VwZ3JhZGUnLCByZXMpO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgdXNlciBtYXkgaGF2ZSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24gZnJvbSBhIGxpc3RlbmVyIG9mIHRoZSBgdXBncmFkZWBcbiAgICAvLyBldmVudC5cbiAgICAvL1xuICAgIGlmICh3ZWJzb2NrZXQucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHJldHVybjtcblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcblxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBpZiAocmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtYWNjZXB0J10gIT09IGRpZ2VzdCkge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcnZlclByb3QgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGNvbnN0IHByb3RMaXN0ID0gKHByb3RvY29scyB8fCAnJykuc3BsaXQoLywgKi8pO1xuICAgIGxldCBwcm90RXJyb3I7XG5cbiAgICBpZiAoIXByb3RvY29scyAmJiBzZXJ2ZXJQcm90KSB7XG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYSBzdWJwcm90b2NvbCBidXQgbm9uZSB3YXMgcmVxdWVzdGVkJztcbiAgICB9IGVsc2UgaWYgKHByb3RvY29scyAmJiAhc2VydmVyUHJvdCkge1xuICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IG5vIHN1YnByb3RvY29sJztcbiAgICB9IGVsc2UgaWYgKHNlcnZlclByb3QgJiYgIXByb3RMaXN0LmluY2x1ZGVzKHNlcnZlclByb3QpKSB7XG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYW4gaW52YWxpZCBzdWJwcm90b2NvbCc7XG4gICAgfVxuXG4gICAgaWYgKHByb3RFcnJvcikge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIHByb3RFcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNlcnZlclByb3QpIHdlYnNvY2tldC5wcm90b2NvbCA9IHNlcnZlclByb3Q7XG5cbiAgICBpZiAocGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBwYXJzZShyZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ10pO1xuXG4gICAgICAgIGlmIChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuYWNjZXB0KGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIHdlYnNvY2tldC5fZXh0ZW5zaW9uc1tcbiAgICAgICAgICAgIFBlck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVcbiAgICAgICAgICBdID0gcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBhYm9ydEhhbmRzaGFrZShcbiAgICAgICAgICB3ZWJzb2NrZXQsXG4gICAgICAgICAgc29ja2V0LFxuICAgICAgICAgICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQuc2V0U29ja2V0KHNvY2tldCwgaGVhZCwgb3B0cy5tYXhQYXlsb2FkKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYG5ldC5Tb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtuZXQuU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbmV0Q29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IG9wdGlvbnMuc29ja2V0UGF0aDtcbiAgcmV0dXJuIG5ldC5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGB0bHMuVExTU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7dGxzLlRMU1NvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRsc0Nvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCFvcHRpb25zLnNlcnZlcm5hbWUgJiYgb3B0aW9ucy5zZXJ2ZXJuYW1lICE9PSAnJykge1xuICAgIG9wdGlvbnMuc2VydmVybmFtZSA9IG9wdGlvbnMuaG9zdDtcbiAgfVxuXG4gIHJldHVybiB0bHMuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBBYm9ydCB0aGUgaGFuZHNoYWtlIGFuZCBlbWl0IGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsoaHR0cC5DbGllbnRSZXF1ZXN0fG5ldC5Tb2NrZXQpfSBzdHJlYW0gVGhlIHJlcXVlc3QgdG8gYWJvcnQgb3IgdGhlXG4gKiAgICAgc29ja2V0IHRvIGRlc3Ryb3lcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHN0cmVhbSwgbWVzc2FnZSkge1xuICB3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZSk7XG5cbiAgaWYgKHN0cmVhbS5zZXRIZWFkZXIpIHtcbiAgICBzdHJlYW0uYWJvcnQoKTtcbiAgICBzdHJlYW0ub25jZSgnYWJvcnQnLCB3ZWJzb2NrZXQuZW1pdENsb3NlLmJpbmQod2Vic29ja2V0KSk7XG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpO1xuICAgIHN0cmVhbS5vbmNlKCdlcnJvcicsIHdlYnNvY2tldC5lbWl0LmJpbmQod2Vic29ja2V0LCAnZXJyb3InKSk7XG4gICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgd2Vic29ja2V0LmVtaXRDbG9zZS5iaW5kKHdlYnNvY2tldCkpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGNhc2VzIHdoZXJlIHRoZSBgcGluZygpYCwgYHBvbmcoKWAsIG9yIGBzZW5kKClgIG1ldGhvZHMgYXJlIGNhbGxlZFxuICogd2hlbiB0aGUgYHJlYWR5U3RhdGVgIGF0dHJpYnV0ZSBpcyBgQ0xPU0lOR2Agb3IgYENMT1NFRGAuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNlbmRBZnRlckNsb3NlKHdlYnNvY2tldCwgZGF0YSwgY2IpIHtcbiAgaWYgKGRhdGEpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0b0J1ZmZlcihkYXRhKS5sZW5ndGg7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBgX2J1ZmZlcmVkQW1vdW50YCBwcm9wZXJ0eSBpcyB1c2VkIG9ubHkgd2hlbiB0aGUgcGVlciBpcyBhIGNsaWVudCBhbmRcbiAgICAvLyB0aGUgb3BlbmluZyBoYW5kc2hha2UgZmFpbHMuIFVuZGVyIHRoZXNlIGNpcmN1bXN0YW5jZXMsIGluIGZhY3QsIHRoZVxuICAgIC8vIGBzZXRTb2NrZXQoKWAgbWV0aG9kIGlzIG5vdCBjYWxsZWQsIHNvIHRoZSBgX3NvY2tldGAgYW5kIGBfc2VuZGVyYFxuICAgIC8vIHByb3BlcnRpZXMgYXJlIHNldCB0byBgbnVsbGAuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0Ll9zb2NrZXQpIHdlYnNvY2tldC5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzICs9IGxlbmd0aDtcbiAgICBlbHNlIHdlYnNvY2tldC5fYnVmZmVyZWRBbW91bnQgKz0gbGVuZ3RoO1xuICB9XG5cbiAgaWYgKGNiKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgYFdlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAke3dlYnNvY2tldC5yZWFkeVN0YXRlfSBgICtcbiAgICAgICAgYCgke3JlYWR5U3RhdGVzW3dlYnNvY2tldC5yZWFkeVN0YXRlXX0pYFxuICAgICk7XG4gICAgY2IoZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2NvbmNsdWRlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uIFRoZSByZWFzb24gZm9yIGNsb3NpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Db25jbHVkZShjb2RlLCByZWFzb24pIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHdlYnNvY2tldC5fc29ja2V0LnJlc3VtZSgpO1xuXG4gIHdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkID0gdHJ1ZTtcbiAgd2Vic29ja2V0Ll9jbG9zZU1lc3NhZ2UgPSByZWFzb247XG4gIHdlYnNvY2tldC5fY2xvc2VDb2RlID0gY29kZTtcblxuICBpZiAoY29kZSA9PT0gMTAwNSkgd2Vic29ja2V0LmNsb3NlKCk7XG4gIGVsc2Ugd2Vic29ja2V0LmNsb3NlKGNvZGUsIHJlYXNvbik7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZHJhaW4nYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRHJhaW4oKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uX3NvY2tldC5yZXN1bWUoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFJhbmdlRXJyb3J8RXJyb3IpfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25FcnJvcihlcnIpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG5cbiAgd2Vic29ja2V0LnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgd2Vic29ja2V0Ll9jbG9zZUNvZGUgPSBlcnJba1N0YXR1c0NvZGVdO1xuICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB3ZWJzb2NrZXQuX3NvY2tldC5kZXN0cm95KCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZmluaXNoJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkZpbmlzaCgpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0Q2xvc2UoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdtZXNzYWdlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcnxBcnJheUJ1ZmZlcnxCdWZmZXJbXSl9IGRhdGEgVGhlIG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25NZXNzYWdlKGRhdGEpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncGluZydgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwaW5nIGZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uUGluZyhkYXRhKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0LnBvbmcoZGF0YSwgIXdlYnNvY2tldC5faXNTZXJ2ZXIsIE5PT1ApO1xuICB3ZWJzb2NrZXQuZW1pdCgncGluZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BvbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcG9uZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBvbmcoZGF0YSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ3BvbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBuZXQuU29ja2V0YCBgJ2Nsb3NlJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25DbG9zZSgpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBzb2NrZXRPbkVuZCk7XG5cbiAgd2Vic29ja2V0LnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuICAvL1xuICAvLyBUaGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGhhdmUgYmVlbiByZWNlaXZlZCBvciB0aGUgYCdlbmQnYCBldmVudCBlbWl0dGVkLFxuICAvLyBmb3IgZXhhbXBsZSwgaWYgdGhlIHNvY2tldCB3YXMgZGVzdHJveWVkIGR1ZSB0byBhbiBlcnJvci4gRW5zdXJlIHRoYXQgdGhlXG4gIC8vIGByZWNlaXZlcmAgc3RyZWFtIGlzIGNsb3NlZCBhZnRlciB3cml0aW5nIGFueSByZW1haW5pbmcgYnVmZmVyZWQgZGF0YSB0b1xuICAvLyBpdC4gSWYgdGhlIHJlYWRhYmxlIHNpZGUgb2YgdGhlIHNvY2tldCBpcyBpbiBmbG93aW5nIG1vZGUgdGhlbiB0aGVyZSBpcyBub1xuICAvLyBidWZmZXJlZCBkYXRhIGFzIGV2ZXJ5dGhpbmcgaGFzIGJlZW4gYWxyZWFkeSB3cml0dGVuIGFuZCBgcmVhZGFibGUucmVhZCgpYFxuICAvLyB3aWxsIHJldHVybiBgbnVsbGAuIElmIGluc3RlYWQsIHRoZSBzb2NrZXQgaXMgcGF1c2VkLCBhbnkgcG9zc2libGUgYnVmZmVyZWRcbiAgLy8gZGF0YSB3aWxsIGJlIHJlYWQgYXMgYSBzaW5nbGUgY2h1bmsgYW5kIGVtaXR0ZWQgc3luY2hyb25vdXNseSBpbiBhIHNpbmdsZVxuICAvLyBgJ2RhdGEnYCBldmVudC5cbiAgLy9cbiAgd2Vic29ja2V0Ll9zb2NrZXQucmVhZCgpO1xuICB3ZWJzb2NrZXQuX3JlY2VpdmVyLmVuZCgpO1xuXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xuXG4gIGNsZWFyVGltZW91dCh3ZWJzb2NrZXQuX2Nsb3NlVGltZXIpO1xuXG4gIGlmIChcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkIHx8XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWRcbiAgKSB7XG4gICAgd2Vic29ja2V0LmVtaXRDbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkZpbmlzaCk7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZmluaXNoJywgcmVjZWl2ZXJPbkZpbmlzaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBuZXQuU29ja2V0YCBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkRhdGEoY2h1bmspIHtcbiAgaWYgKCF0aGlzW2tXZWJTb2NrZXRdLl9yZWNlaXZlci53cml0ZShjaHVuaykpIHtcbiAgICB0aGlzLnBhdXNlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBuZXQuU29ja2V0YCBgJ2VuZCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRW5kKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG4gIHRoaXMuZW5kKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgbmV0LlNvY2tldGAgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcbiAgdGhpcy5vbignZXJyb3InLCBOT09QKTtcblxuICBpZiAod2Vic29ja2V0KSB7XG4gICAgd2Vic29ja2V0LnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/websocket.js\n");

/***/ }),

/***/ "./src/class-netpacket.js":
/*!********************************!*\
  !*** ./src/class-netpacket.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable @typescript-eslint/no-use-before-define */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/* eslint-disable lines-between-class-members */\n\n/*//////////////////////////////// ABOUT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\n\n  NetPacket objects are sent between the browser and server as part of the\n  URSYS messaging system. NetMessages do not need addresses.\n\n  This NetPacket declaration is SHARED in both node and browser javascript\n  codebases.\n\n  FEATURES\n\n  * handles asynchronous transactions\n  * works in both node and browser contexts\n  * has an \"offline mode\" to suppress network messages without erroring\n\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ * //////////////////////////////////////*/\n/// DEPENDENCIES //////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nconst PROMPTS = __webpack_require__(/*! ./util/prompts */ \"./src/util/prompts.js\"); /// DEBUG MESSAGES ////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nconst DBG = {\n  send: false,\n  transact: false,\n  setup: false\n};\nconst PR = PROMPTS.makeStyleFormatter('PKT');\nconst ERR = ':ERR:';\nconst PERR = ERR + PR;\nconst ERR_NOT_NETMESG = `${PERR}obj does not seem to be a NetPacket`;\nconst ERR_BAD_PROP = `${PERR}property argument must be a string`;\nconst ERR_ERR_BAD_CSTR = `${PERR}constructor args are string, object`;\nconst ERR_BAD_SOCKET = `${PERR}sender object must implement send()`;\nconst ERR_DUPE_TRANS = `${PERR}this packet transaction is already registered!`;\nconst ERR_NO_GLOB_UADDR = `${PERR}packet sending attempted before UADDR is set!`;\nconst ERR_UNKNOWN_TYPE = `${PERR}packet type is unknown:`;\nconst ERR_NOT_PACKET = `${PERR}passed object is not a NetPacket`;\nconst ERR_UNKNOWN_RMODE = `${PERR}packet routine mode is unknown:`; /// CONSTANTS /////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst M_INIT = 'init';\nconst M_ONLINE = 'online';\nconst M_STANDALONE = 'offline';\nconst M_CLOSED = 'closed';\nconst M_ERROR = 'error';\nconst VALID_CHANNELS = ['LOCAL', 'NET', 'STATE']; // * is all channels in list\n/// DECLARATIONS //////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nlet m_id_counter = 0;\nlet m_id_prefix = 'PKT';\nlet m_transactions = {};\nlet m_netsocket = null;\nlet m_group_id = null;\nlet m_mode = M_INIT; /// ENUMS /////////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst PACKET_TYPES = ['msend', // a 'send' message returns no data\n'msig', // a 'signal' message is a send that calls all handlers everywhere\n'mcall', // a 'call' message returns data\n'state' // (unimplemented) a 'state' message is used by a state manager\n];\nconst TRANSACTION_MODE = ['req', // packet in initial 'request' mode\n'res' // packet in returned 'response' mode\n]; /// URSYS NETMESSAGE CLASS ////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Class NetPacket\n * Container for messages that can be sent across the network to the URSYS\n * server.\n * @typedef {Object} NetPacket\n * @property {string} msg - message\n * @property {Object} data - message data\n * @property {string} id - internal id\n * @property {string} type - packet operation type (1way,2way,sync)\n * @property {string} rmode - transaction direction\n * @property {string} memo - human-readable debug note space\n * @property {string} seqnum - sequence number for transaction\n * @property {Array} seqlog - array of seqnums, starting with originating address\n * @property {string} s_uid - originating browser internal endpoint\n * @property {string} s_uaddr - originating browser address\n * @property {string} s_group - group session key\n */\n\nclass NetPacket {\n  /** constructor\n   * @param {string|object} msg message name, or an existing plain object to coerce into a NetPacket\n   * @param {Object} data data packet to send\n   * @param {string} type the message (defined in PACKET_TYPES)\n   */\n  constructor(msg, data, type) {\n    // OPTION 1\n    // create NetPacket from (generic object)\n    if (typeof msg === 'object' && data === undefined) {\n      // make sure it has a msg and data obj\n      if (typeof msg.msg !== 'string' || typeof msg.data !== 'object') {\n        throw Error(ERR_NOT_NETMESG);\n      } // merge properties into this new class instance and return it\n\n\n      Object.assign(this, msg);\n      this.seqlog = this.seqlog.slice(); // copy array\n\n      m_SeqIncrement(this);\n      return this;\n    } // OPTION 2\n    // create NetPacket from JSON-encoded string\n\n\n    if (typeof msg === 'string' && data === undefined) {\n      let obj = JSON.parse(msg);\n      Object.assign(this, obj);\n      m_SeqIncrement(this);\n      return this;\n    } // OPTION 3\n    // create new NetPacket from scratch (mesg,data)\n    // unique id for every NetPacket\n\n\n    if (typeof type === 'string') m_CheckType(type);\n\n    if (typeof msg !== 'string' || typeof data !== 'object') {\n      throw Error(ERR_ERR_BAD_CSTR);\n    } // allow calls with null data by setting to empty object\n\n\n    this.data = data || {};\n    this.msg = msg; // id and debugging memo support\n\n    this.id = this.MakeNewID();\n    this.rmode = TRANSACTION_MODE[0]; // is default 'request' (trans request)\n\n    this.type = type || PACKET_TYPES[0]; // is default 'msend' (no return)\n\n    this.memo = ''; // transaction support\n\n    this.seqnum = 0; // positive when part of transaction\n\n    this.seqlog = []; // transaction log\n    // addressing support\n\n    this.s_uaddr = NetPacket.SocketUADDR() || null; // first originating uaddr set by SocketSend()\n\n    this.s_group = null; // session groupid is set by external module once validated\n\n    this.s_uid = null; // first originating URCHAN srcUID\n    // filtering support\n  } // constructor\n  /// ACCESSSOR METHODS ///////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.Type() returns the TRANSACTION_TYPE of this packet\n   */\n\n\n  Type() {\n    return this.type;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.Type() returns true if type matches\n   * @param {string} type the type to compare with the packet's type\n   * @returns {boolean}\n   */\n\n\n  IsType(type) {\n    return this.type === type;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.SetType() sets the type of the packet. Must be a known type\n   * in PACKET_TYPES\n   */\n\n\n  SetType(type) {\n    this.type = m_CheckType(type);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** returns the message string of form CHANNEL:MESSAGE, where CHANNEL:\n   * is optional\n   */\n\n\n  Message() {\n    return this.msg;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** returns MESSAGE without the CHANNEL: prefix. The channel (e.g.\n   * NET, LOCAL, STATE) is also set true\n   */\n\n\n  DecodedMessage() {\n    return NetPacket.ExtractChannel(this.msg);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.Is() returns truthy value (this.data) if the passed msgstr\n   *  matches the message associated with this NetPacket\n   */\n\n\n  Is(msgstr) {\n    return msgstr === this.msg ? this.data : undefined;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.IsServerMessage() is a convenience function return true if\n   * server message */\n\n\n  IsServerMessage() {\n    return this.msg.startsWith('NET:SRV_');\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.SetMessage() sets the message field\n   */\n\n\n  SetMessage(msgstr) {\n    this.msg = msgstr;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.Data() returns the entire data payload or the property within\n   * the data payload (can return undefined if property doesn't exist)\n   */\n\n\n  Data(prop) {\n    if (!prop) return this.data;\n    if (typeof prop === 'string') return this.data[prop];\n    throw Error(ERR_BAD_PROP);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /**\n   * Convenience method to set data object entirely\n   */\n\n\n  SetData(propOrVal, val) {\n    if (typeof propOrVal === 'object') {\n      this.data = propOrVal;\n      return;\n    }\n\n    if (typeof propOrVal === 'string') {\n      this.data[propOrVal] = val;\n      return;\n    }\n\n    throw Error(ERR_BAD_PROP);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.Memo() returns the 'memo' field of the packet */\n\n\n  Memo() {\n    return this.memo;\n  }\n\n  SetMemo(memo) {\n    this.memo = memo;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.JSON() returns a stringified JSON version of the packet. */\n\n\n  JSON() {\n    return JSON.stringify(this);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.SourceGroupId() return the session group id associated with\n   * this packet.\n   */\n\n\n  SourceGroupID() {\n    return this.s_group;\n  } /// TRANSACTION SUPPORT /////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.SeqNum() returns a non-positive integer that is the number of\n   * times this packet was reused during a transaction (e.g. 'mcall' types).\n   */\n\n\n  SeqNum() {\n    return this.seqnum;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.SourceAddress() returns the originating browser of the packet,\n   * which is the socketname maintained by the URSYS server. It is valid only\n   * after the URSYS server has received it, so it is invalid when a NetPacket\n   * packet is first created.\n   */\n\n\n  SourceAddress() {\n    /*/ NOTE\n         s_uaddr is the most recent sending browser.\n         If a NetPacket packet is reused in a transaction (e.g. a call that returns\n        data) then the originating browser is the first element in the transaction\n        log .seqlog\n    /*/\n    // is this packet originating from server to a remote?\n    if (this.s_uaddr === NetPacket.DefaultServerUADDR() && !this.msg.startsWith('NET:SVR_')) {\n      return this.s_uaddr;\n    } // this is a regular message forward to remote handlers\n\n\n    return this.IsTransaction() ? this.seqlog[0] : this.s_uaddr;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** Return true if this pkt is from the server targeting remote handlers\n   */\n\n\n  IsServerOrigin() {\n    return this.SourceAddress() === NetPacket.DefaultServerUADDR();\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.CopySourceAddress() copies the source address of sets the\n   * current address to the originating URSYS browser address. Used by server\n   * forwarding and returning packets between remotes.\n   * @param {NetPacket} pkt - the packet to copy source from\n   */\n\n\n  CopySourceAddress(pkt) {\n    if (pkt.constructor.name !== 'NetPacket') throw Error(ERR_NOT_PACKET);\n    this.s_uaddr = pkt.SourceAddress();\n  } /// - - - - - - - - server- - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.Info() returns debug information about the packet\n   * @param {string} key - type of debug info (always 'src' currently)\n   * @returns {string} source browser + group (if set)\n   */\n\n\n  Info(key) {\n    switch (key) {\n      case 'src':\n      /* falls-through */\n\n      default:\n        return this.SourceGroupID() ? `${this.SourceAddress()} [${this.SourceGroupID()}]` : `${this.SourceAddress()}`;\n    }\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.MakeNewID() is a utility method that generates a unique id for\n   * each NetPacket packet. When combined with s_uaddr and s_srcuid, this gives\n   * a packet a unique ID across the entire URSYS network.\n   * @returns {string} unique id\n   */\n\n\n  MakeNewID() {\n    let idStr = (++m_id_counter).toString();\n    this.id = m_id_prefix + idStr.padStart(5, '0');\n    return this.id;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.SocketSend() is a convenience method to let packets 'send\n   * themselves' to the network via the URSYS server.\n   * @param {Object=m_socket} socket - web socket object. m_socket\n   * is defined only on browsers; see NetPacket.GlobalSetup()\n   */\n\n\n  SocketSend(socket = m_netsocket) {\n    if (m_mode === M_ONLINE || m_mode === M_INIT) {\n      this.s_group = NetPacket.GlobalGroupID();\n      let dst = socket.UADDR || 'unregistered socket';\n      if (!socket) throw Error('SocketSend(sock) requires a valid socket');\n\n      if (DBG.send) {\n        let status = `sending '${this.Message()}' to ${dst}`;\n        console.log(PR, status);\n      } // for server-side ws library, send supports a function callback\n      // for WebSocket, this is ignored\n\n\n      socket.send(this.JSON(), err => {\n        if (err) console.error(`\\nsocket ${socket.UADDR} reports error ${err}\\n`);\n      });\n    } else if (m_mode !== M_STANDALONE) {\n      console.log(PR, \"SocketSend: Can't send because NetPacket mode is\", m_mode);\n    } else {\n      console.warn(PR, 'STANDALONE MODE: SocketSend() suppressed!');\n    } // FYI: global m_netsocket is not defined on server, since packets arrive on multiple sockets\n\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.PromiseTransaction() maps a packet to a return handler using a\n   * unique key. This key allows an incoming packet to be mapped back to the\n   * caller even if it is technically a different object received over the\n   * network.\n   * @param {Object=m_socket} socket - web socket object. m_socket is defined\n   * only on browsers; see NetPacket.GlobalSetup()\n   */\n\n\n  PromiseTransaction(socket = m_netsocket) {\n    if (m_mode === M_STANDALONE) {\n      console.warn(PR, 'STANDALONE MODE: PromiseTransaction() suppressed!');\n      return Promise.resolve();\n    } // global m_netsocket is not defined on server, since packets arrive on multiple sockets\n\n\n    if (!socket) throw Error('PromiseTransaction(sock) requires a valid socket'); // save our current UADDR\n\n    this.seqlog.push(NetPacket.UADDR);\n    let dbg = DBG.transact && !this.IsServerMessage();\n    let p = new Promise((resolve, reject) => {\n      let hash = m_GetHashKey(this);\n\n      if (m_transactions[hash]) {\n        reject(Error(`${ERR_DUPE_TRANS}:${hash}`));\n      } else {\n        // save the resolve function in transactions table;\n        // promise will resolve on remote invocation with data\n        m_transactions[hash] = data => {\n          if (dbg) {\n            console.log(PR, 'resolving promise with', JSON.stringify(data));\n          }\n\n          resolve(data);\n        };\n\n        this.SocketSend(socket);\n      }\n    });\n    return p;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.RoutingMode() returns the direction of the packet to a\n   * destination handler (req) or back to the origin (res).  */\n\n\n  RoutingMode() {\n    return this.rmode;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.IsRequest() returns true if this packet is one being sent\n   * to a remote handler\n   */\n\n\n  IsRequest() {\n    return this.rmode === 'req';\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.IsResponse() returns true if this is a packet\n   * being returned from a remote handler\n   * @returns {boolean} true if this is a transaction response\n   */\n\n\n  IsResponse() {\n    return this.rmode === 'res'; // more bulletproof check, but unnecessary\n    // return this.rmove ==='res' && this.SourceAddress() === NetPacket.UADDR;\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.IsTransaction() tests whether the packet is a response to a\n   * call that was sent out previously.\n   */\n\n\n  IsTransaction() {\n    return this.rmode !== 'req' && this.seqnum > 0 && this.seqlog[0] === NetPacket.UADDR;\n  } ///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.ReturnTransaction() is used to send a packet back to its\n   * origin. It saves the current browser address (stored in NetPacket.UADDR),\n   * sets the direction of the packet, and puts it on the socket.\n   * @param {Object=m_socket} socket - web socket object. m_socket is defined\n   * only on browsers; see NetPacket.GlobalSetup()\n   */\n\n\n  ReturnTransaction(socket = m_netsocket) {\n    // global m_netsocket is not defined on server, since packets arrive on multiple sockets\n    if (!socket) throw Error('ReturnTransaction(sock) requires a valid socket'); // note: seqnum is already incremented by the constructor if this was\n    // a received packet\n    // add this to the sequence log\n\n    this.seqlog.push(NetPacket.UADDR);\n    this.rmode = m_CheckRMode('res');\n    this.SocketSend(socket);\n  } /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n  /** NetPacket.CompleteTransaction() is called when a packet is received back\n   * from the remote handler. At this point, the original caller needs to be\n   * informed via the saved function handler created in\n   * NetPacket.PromiseTransaction().\n   */\n\n\n  CompleteTransaction() {\n    let dbg = DBG.transact && !this.IsServerMessage();\n    let hash = m_GetHashKey(this);\n    let resolverFunc = m_transactions[hash];\n    if (dbg) console.log(PR, 'CompleteTransaction', hash);\n\n    if (typeof resolverFunc !== 'function') {\n      throw Error(`transaction [${hash}] resolverFunction is type ${typeof resolverFunc}`);\n    } else {\n      resolverFunc(this.data);\n      Reflect.deleteProperty(m_transactions[hash]);\n    }\n  }\n\n} // class NetPacket\n/// STATIC CLASS METHODS //////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** NetPacket.GlobalSetup() is a static method that initializes shared\n * parameters for use by all instances of the NetPacket class. It is used only\n * on browsers, which have a single socket connection.\n *\n * If no netsocket property is defined, then NetPacket instances will surpress\n * sending of network messages while allowing local messages to work normally.\n * See NetPacket.GlobalOfflineMode() for more information.\n * @function\n * @param {Object} [config] - configuration object\n * @param {Object} [config.netsocket] - valid websocket to URSYS server\n * @param {Object} [config.uaddr] - URSYS browser address\n */\n\n\nNetPacket.GlobalSetup = (config = {}) => {\n  let {\n    uaddr,\n    netsocket,\n    peers,\n    is_local\n  } = config;\n  if (uaddr) NetPacket.UADDR = uaddr;\n  if (peers) NetPacket.PEERS = peers;\n\n  if (netsocket) {\n    // NOTE: m_netsocket is set only on clients since on server, there are\n    // multiple sockets\n    if (typeof netsocket.send !== 'function') throw Error(ERR_BAD_SOCKET);\n    if (DBG.setup) console.log(PR, 'GlobalSetup: netsocket set, mode online');\n    m_netsocket = netsocket;\n    m_mode = M_ONLINE;\n  }\n\n  if (is_local) NetPacket.ULOCAL = is_local;\n};\n\nNetPacket.UADDR = 'UNASSIGNED';\nNetPacket.ULOCAL = false; // set if connection is a local connection\n\nNetPacket.PEERS = undefined; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** NetPacket.GlobalCleanup() is a static method called only by the client,\n * which drops the current socket and puts the app in 'closed' state. In\n * practice this call doesn't accomplish much, but is here for symmetry to\n * GlobalSetup().\n * @function\n */\n\nNetPacket.GlobalCleanup = () => {\n  if (m_netsocket) {\n    if (DBG.setup) console.log(PR, 'GlobalCleanup: deallocating netsocket, mode closed');\n    m_netsocket = null;\n    m_mode = M_CLOSED;\n    NetPacket.ULOCAL = false;\n  }\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Static method NetPacket.GlobalOfflineMode() explicitly sets the mode to STANDALONE, which\n * actively suppresses remote network communication without throwing errors.\n * It's used for static code snapshots of the webapp that don't need the\n * network.\n * @function\n */\n\n\nNetPacket.GlobalOfflineMode = () => {\n  m_mode = M_STANDALONE;\n\n  if (m_netsocket) {\n    console.log(...PR('STANDALONE MODE: NetPacket disabling network'));\n    m_netsocket = null;\n    let event = new CustomEvent('URSYSDisconnect', {});\n    console.log(...PR('STANDALONE MODE: sending URSYSDisconnect'));\n    document.dispatchEvent(event);\n  }\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/**\n * Converts 'CHANNEL:MESSAGE' string to an object with channel, message\n * properties. If there is more than one : in the message string, it's left\n * as part of the message. All properties returned in are UPPERCASE.\n * @param {string} message - message with optional channel prefix\n * @returns {Object} - contains channel (UC) that are set\n * @example\n * const parsed = NetPacket.DecodeChannel('NET:MY_MESSAGE');\n * if (parsed.NET) console.log('this is true');\n * if (parsed.LOCAL) console.log('this is false');\n * console.log('message is',parsed.MESSAGE);\n */\n\n\nNetPacket.ExtractChannel = function ExtractChannel(msg) {\n  let [channel, MESSAGE] = msg.split(':', 2); // no : found, must be local\n\n  if (!MESSAGE) {\n    MESSAGE = channel;\n    channel = '';\n  }\n\n  const parsed = {\n    MESSAGE\n  };\n\n  if (!channel) {\n    parsed.LOCAL = true;\n    return parsed;\n  }\n\n  if (channel === '*') {\n    VALID_CHANNELS.forEach(chan => {\n      parsed[chan] = true;\n    });\n    return parsed;\n  }\n\n  if (VALID_CHANNELS.includes(channel)) {\n    parsed[channel] = true;\n    return parsed;\n  } // legacy messages use invalid channel names\n  // for now forward them as-is\n\n\n  console.warn(`'${msg}' replace : with _`);\n  parsed.LOCAL = true;\n  return parsed; // this is what should actually happen\n  // throw Error(`invalid channel '${channel}'`);\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** NetPacket.SocketUADDR() is a static method returning the class-wide setting\n * of the browser UADDR. This is only used on browser code.\n * @function\n * @returns {string} URSYS address of the current browser, a URSYS address\n */\n\n\nNetPacket.SocketUADDR = () => {\n  return NetPacket.UADDR;\n};\n\nNetPacket.Peers = () => {\n  return NetPacket.PEERS;\n};\n\nNetPacket.IsLocalhost = () => {\n  return NetPacket.ULOCAL;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** NetPacket.DefaultServerUADDR() is a static method returning a hardcoded\n * URSYS address referring to the URSYS server. It is used by the server-side\n * code to set the server address, and the browser can rely on it as well.\n * @function\n * @returns {string} URSYS address of the server\n */\n\n\nNetPacket.DefaultServerUADDR = () => {\n  return 'SVR_01';\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** NetPacket.GlobalGroupID() is a static method returning the session key\n * (aka group-id) set for this browser instance\n * @function\n * @returns {string} session key\n */\n\n\nNetPacket.GlobalGroupID = () => {\n  return m_group_id;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** NetPacket.GlobalSetGroupID() is a static method that stores the passed\n * token as the GroupID\n * @function\n * @param {string} token - special session key data\n */\n\n\nNetPacket.GlobalSetGroupID = token => {\n  m_group_id = token;\n}; /// PRIVATE CLASS HELPERS /////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/*/ DEPRECATE? Utility function to increment the packet's sequence number\n *  @param {NetPacket} pkt - packet to modify\n/*/\n\n\nfunction m_SeqIncrement(pkt) {\n  pkt.seqnum++;\n  return pkt;\n} ///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/*/ Utility to create a unique hash key from packet information. Used by\n *  PromiseTransaction().\n *  @param {NetPacket} pkt - packet to use\n *  @return {string} hash key string\n/*/\n\n\nfunction m_GetHashKey(pkt) {\n  let hash = `${pkt.SourceAddress()}:${pkt.id}`;\n  return hash;\n} ///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/*/ Utility to ensure that the passed type is one of the allowed packet types.\n *  Throws an error if it is not.\n *  @param {string} type - a string to be matched against PACKET_TYPES\n *  @returns {string} the string that passed the type check\n/*/\n\n\nfunction m_CheckType(type) {\n  if (type === undefined) {\n    throw new Error(`must pass a type string, not ${type}`);\n  }\n\n  if (!PACKET_TYPES.includes(type)) throw Error(`${ERR_UNKNOWN_TYPE} '${type}'`);\n  return type;\n} ///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/*/ Utility to ensure the passed transaction mode is one of the allowed\n *  types. Throws an error if it is not.\n *  @param {string} mode - a string to be matched against TRANSACTION_MODE\n *  @returns {string} the string the passed the mode check\n/*/\n\n\nfunction m_CheckRMode(mode) {\n  if (mode === undefined) {\n    throw new Error(`must pass a mode string, not ${mode}`);\n  }\n\n  if (!TRANSACTION_MODE.includes(mode)) throw Error(`${ERR_UNKNOWN_RMODE} '${mode}'`);\n  return mode;\n} /// EXPORT CLASS DEFINITION ///////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nNetPacket.CODE_OK = 0;\nNetPacket.CODE_NO_MESSAGE = 1; // requested message doesn't exist\n\nNetPacket.CODE_SOC_NOSOCK = -100;\nNetPacket.CODE_SES_REQUIRE_KEY = -200; // access key not set\n\nNetPacket.CODE_SES_REQUIRE_LOGIN = -201; // socket was not logged-in\n\nNetPacket.CODE_SES_INVALID_KEY = -202; // provided key didn't match socket key\n\nNetPacket.CODE_SES_RE_REGISTER = -203; // session attempted to login again\n\nNetPacket.CODE_SES_INVALID_TOKEN = -204; // session attempted to login again\n\nNetPacket.CODE_REG_DENIED = -300; // registration of handler denied\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n/// using CommonJS format on purpose for node compatibility\n\nmodule.exports = NetPacket;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2xhc3MtbmV0cGFja2V0LmpzPzIwMjUiXSwibmFtZXMiOlsiUFJPTVBUUyIsInJlcXVpcmUiLCJEQkciLCJzZW5kIiwidHJhbnNhY3QiLCJzZXR1cCIsIlBSIiwibWFrZVN0eWxlRm9ybWF0dGVyIiwiRVJSIiwiUEVSUiIsIkVSUl9OT1RfTkVUTUVTRyIsIkVSUl9CQURfUFJPUCIsIkVSUl9FUlJfQkFEX0NTVFIiLCJFUlJfQkFEX1NPQ0tFVCIsIkVSUl9EVVBFX1RSQU5TIiwiRVJSX05PX0dMT0JfVUFERFIiLCJFUlJfVU5LTk9XTl9UWVBFIiwiRVJSX05PVF9QQUNLRVQiLCJFUlJfVU5LTk9XTl9STU9ERSIsIk1fSU5JVCIsIk1fT05MSU5FIiwiTV9TVEFOREFMT05FIiwiTV9DTE9TRUQiLCJNX0VSUk9SIiwiVkFMSURfQ0hBTk5FTFMiLCJtX2lkX2NvdW50ZXIiLCJtX2lkX3ByZWZpeCIsIm1fdHJhbnNhY3Rpb25zIiwibV9uZXRzb2NrZXQiLCJtX2dyb3VwX2lkIiwibV9tb2RlIiwiUEFDS0VUX1RZUEVTIiwiVFJBTlNBQ1RJT05fTU9ERSIsIk5ldFBhY2tldCIsImNvbnN0cnVjdG9yIiwibXNnIiwiZGF0YSIsInR5cGUiLCJ1bmRlZmluZWQiLCJFcnJvciIsIk9iamVjdCIsImFzc2lnbiIsInNlcWxvZyIsInNsaWNlIiwibV9TZXFJbmNyZW1lbnQiLCJvYmoiLCJKU09OIiwicGFyc2UiLCJtX0NoZWNrVHlwZSIsImlkIiwiTWFrZU5ld0lEIiwicm1vZGUiLCJtZW1vIiwic2VxbnVtIiwic191YWRkciIsIlNvY2tldFVBRERSIiwic19ncm91cCIsInNfdWlkIiwiVHlwZSIsIklzVHlwZSIsIlNldFR5cGUiLCJNZXNzYWdlIiwiRGVjb2RlZE1lc3NhZ2UiLCJFeHRyYWN0Q2hhbm5lbCIsIklzIiwibXNnc3RyIiwiSXNTZXJ2ZXJNZXNzYWdlIiwic3RhcnRzV2l0aCIsIlNldE1lc3NhZ2UiLCJEYXRhIiwicHJvcCIsIlNldERhdGEiLCJwcm9wT3JWYWwiLCJ2YWwiLCJNZW1vIiwiU2V0TWVtbyIsInN0cmluZ2lmeSIsIlNvdXJjZUdyb3VwSUQiLCJTZXFOdW0iLCJTb3VyY2VBZGRyZXNzIiwiRGVmYXVsdFNlcnZlclVBRERSIiwiSXNUcmFuc2FjdGlvbiIsIklzU2VydmVyT3JpZ2luIiwiQ29weVNvdXJjZUFkZHJlc3MiLCJwa3QiLCJuYW1lIiwiSW5mbyIsImtleSIsImlkU3RyIiwidG9TdHJpbmciLCJwYWRTdGFydCIsIlNvY2tldFNlbmQiLCJzb2NrZXQiLCJHbG9iYWxHcm91cElEIiwiZHN0IiwiVUFERFIiLCJzdGF0dXMiLCJjb25zb2xlIiwibG9nIiwiZXJyIiwiZXJyb3IiLCJ3YXJuIiwiUHJvbWlzZVRyYW5zYWN0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwdXNoIiwiZGJnIiwicCIsInJlamVjdCIsImhhc2giLCJtX0dldEhhc2hLZXkiLCJSb3V0aW5nTW9kZSIsIklzUmVxdWVzdCIsIklzUmVzcG9uc2UiLCJSZXR1cm5UcmFuc2FjdGlvbiIsIm1fQ2hlY2tSTW9kZSIsIkNvbXBsZXRlVHJhbnNhY3Rpb24iLCJyZXNvbHZlckZ1bmMiLCJSZWZsZWN0IiwiZGVsZXRlUHJvcGVydHkiLCJHbG9iYWxTZXR1cCIsImNvbmZpZyIsInVhZGRyIiwibmV0c29ja2V0IiwicGVlcnMiLCJpc19sb2NhbCIsIlBFRVJTIiwiVUxPQ0FMIiwiR2xvYmFsQ2xlYW51cCIsIkdsb2JhbE9mZmxpbmVNb2RlIiwiZXZlbnQiLCJDdXN0b21FdmVudCIsImRvY3VtZW50IiwiZGlzcGF0Y2hFdmVudCIsImNoYW5uZWwiLCJNRVNTQUdFIiwic3BsaXQiLCJwYXJzZWQiLCJMT0NBTCIsImZvckVhY2giLCJjaGFuIiwiaW5jbHVkZXMiLCJQZWVycyIsIklzTG9jYWxob3N0IiwiR2xvYmFsU2V0R3JvdXBJRCIsInRva2VuIiwibW9kZSIsIkNPREVfT0siLCJDT0RFX05PX01FU1NBR0UiLCJDT0RFX1NPQ19OT1NPQ0siLCJDT0RFX1NFU19SRVFVSVJFX0tFWSIsIkNPREVfU0VTX1JFUVVJUkVfTE9HSU4iLCJDT0RFX1NFU19JTlZBTElEX0tFWSIsIkNPREVfU0VTX1JFX1JFR0lTVEVSIiwiQ09ERV9TRVNfSU5WQUxJRF9UT0tFTiIsIkNPREVfUkVHX0RFTklFRCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBLE1BQU1BLE9BQU8sR0FBR0MsbUJBQU8sQ0FBQyw2Q0FBRCxDQUF2QixDLENBRUE7QUFDQTs7O0FBQ0EsTUFBTUMsR0FBRyxHQUFHO0FBQUVDLE1BQUksRUFBRSxLQUFSO0FBQWVDLFVBQVEsRUFBRSxLQUF6QjtBQUFnQ0MsT0FBSyxFQUFFO0FBQXZDLENBQVo7QUFFQSxNQUFNQyxFQUFFLEdBQUdOLE9BQU8sQ0FBQ08sa0JBQVIsQ0FBMkIsS0FBM0IsQ0FBWDtBQUNBLE1BQU1DLEdBQUcsR0FBRyxPQUFaO0FBQ0EsTUFBTUMsSUFBSSxHQUFHRCxHQUFHLEdBQUdGLEVBQW5CO0FBQ0EsTUFBTUksZUFBZSxHQUFJLEdBQUVELElBQUsscUNBQWhDO0FBQ0EsTUFBTUUsWUFBWSxHQUFJLEdBQUVGLElBQUssb0NBQTdCO0FBQ0EsTUFBTUcsZ0JBQWdCLEdBQUksR0FBRUgsSUFBSyxxQ0FBakM7QUFDQSxNQUFNSSxjQUFjLEdBQUksR0FBRUosSUFBSyxxQ0FBL0I7QUFDQSxNQUFNSyxjQUFjLEdBQUksR0FBRUwsSUFBSyxnREFBL0I7QUFDQSxNQUFNTSxpQkFBaUIsR0FBSSxHQUFFTixJQUFLLCtDQUFsQztBQUNBLE1BQU1PLGdCQUFnQixHQUFJLEdBQUVQLElBQUsseUJBQWpDO0FBQ0EsTUFBTVEsY0FBYyxHQUFJLEdBQUVSLElBQUssa0NBQS9CO0FBQ0EsTUFBTVMsaUJBQWlCLEdBQUksR0FBRVQsSUFBSyxpQ0FBbEMsQyxDQUVBO0FBQ0E7O0FBQ0EsTUFBTVUsTUFBTSxHQUFHLE1BQWY7QUFDQSxNQUFNQyxRQUFRLEdBQUcsUUFB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QUEvQixDQUFYO0FBQ0YsU0FBT0EsSUFBUDtBQUNELEMsQ0FFRDtBQUNBOzs7QUFDQWpILFNBQVMsQ0FBQ2tILE9BQVYsR0FBb0IsQ0FBcEI7QUFDQWxILFNBQVMsQ0FBQ21ILGVBQVYsR0FBNEIsQ0FBNUIsQyxDQUErQjs7QUFDL0JuSCxTQUFTLENBQUNvSCxlQUFWLEdBQTRCLENBQUMsR0FBN0I7QUFDQXBILFNBQVMsQ0FBQ3FILG9CQUFWLEdBQWlDLENBQUMsR0FBbEMsQyxDQUF1Qzs7QUFDdkNySCxTQUFTLENBQUNzSCxzQkFBVixHQUFtQyxDQUFDLEdBQXBDLEMsQ0FBeUM7O0FBQ3pDdEgsU0FBUyxDQUFDdUgsb0JBQVYsR0FBaUMsQ0FBQyxHQUFsQyxDLENBQXVDOztBQUN2Q3ZILFNBQVMsQ0FBQ3dILG9CQUFWLEdBQWlDLENBQUMsR0FBbEMsQyxDQUF1Qzs7QUFDdkN4SCxTQUFTLENBQUN5SCxzQkFBVixHQUFtQyxDQUFDLEdBQXBDLEMsQ0FBeUM7O0FBQ3pDekgsU0FBUyxDQUFDMEgsZUFBVixHQUE0QixDQUFDLEdBQTdCLEMsQ0FBa0M7QUFDbEM7QUFDQTs7QUFDQUMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCNUgsU0FBakIiLCJmaWxlIjoiLi9zcmMvY2xhc3MtbmV0cGFja2V0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIGxpbmVzLWJldHdlZW4tY2xhc3MtbWVtYmVycyAqL1xuLyovLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBBQk9VVCBcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwqXFxcblxuICBOZXRQYWNrZXQgb2JqZWN0cyBhcmUgc2VudCBiZXR3ZWVuIHRoZSBicm93c2VyIGFuZCBzZXJ2ZXIgYXMgcGFydCBvZiB0aGVcbiAgVVJTWVMgbWVzc2FnaW5nIHN5c3RlbS4gTmV0TWVzc2FnZXMgZG8gbm90IG5lZWQgYWRkcmVzc2VzLlxuXG4gIFRoaXMgTmV0UGFja2V0IGRlY2xhcmF0aW9uIGlzIFNIQVJFRCBpbiBib3RoIG5vZGUgYW5kIGJyb3dzZXIgamF2YXNjcmlwdFxuICBjb2RlYmFzZXMuXG5cbiAgRkVBVFVSRVNcblxuICAqIGhhbmRsZXMgYXN5bmNocm9ub3VzIHRyYW5zYWN0aW9uc1xuICAqIHdvcmtzIGluIGJvdGggbm9kZSBhbmQgYnJvd3NlciBjb250ZXh0c1xuICAqIGhhcyBhbiBcIm9mZmxpbmUgbW9kZVwiIHRvIHN1cHByZXNzIG5ldHdvcmsgbWVzc2FnZXMgd2l0aG91dCBlcnJvcmluZ1xuXG5cXCpcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCAqIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vKi9cblxuLy8vIERFUEVOREVOQ0lFUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuY29uc3QgUFJPTVBUUyA9IHJlcXVpcmUoJy4vdXRpbC9wcm9tcHRzJyk7XG5cbi8vLyBERUJVRyBNRVNTQUdFUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbmNvbnN0IERCRyA9IHsgc2VuZDogZmFsc2UsIHRyYW5zYWN0OiBmYWxzZSwgc2V0dXA6IGZhbHNlIH07XG5cbmNvbnN0IFBSID0gUFJPTVBUUy5tYWtlU3R5bGVGb3JtYXR0ZXIoJ1BLVCcpO1xuY29uc3QgRVJSID0gJzpFUlI6JztcbmNvbnN0IFBFUlIgPSBFUlIgKyBQUjtcbmNvbnN0IEVSUl9OT1RfTkVUTUVTRyA9IGAke1BFUlJ9b2JqIGRvZXMgbm90IHNlZW0gdG8gYmUgYSBOZXRQYWNrZXRgO1xuY29uc3QgRVJSX0JBRF9QUk9QID0gYCR7UEVSUn1wcm9wZXJ0eSBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nYDtcbmNvbnN0IEVSUl9FUlJfQkFEX0NTVFIgPSBgJHtQRVJSfWNvbnN0cnVjdG9yIGFyZ3MgYXJlIHN0cmluZywgb2JqZWN0YDtcbmNvbnN0IEVSUl9CQURfU09DS0VUID0gYCR7UEVSUn1zZW5kZXIgb2JqZWN0IG11c3QgaW1wbGVtZW50IHNlbmQoKWA7XG5jb25zdCBFUlJfRFVQRV9UUkFOUyA9IGAke1BFUlJ9dGhpcyBwYWNrZXQgdHJhbnNhY3Rpb24gaXMgYWxyZWFkeSByZWdpc3RlcmVkIWA7XG5jb25zdCBFUlJfTk9fR0xPQl9VQUREUiA9IGAke1BFUlJ9cGFja2V0IHNlbmRpbmcgYXR0ZW1wdGVkIGJlZm9yZSBVQUREUiBpcyBzZXQhYDtcbmNvbnN0IEVSUl9VTktOT1dOX1RZUEUgPSBgJHtQRVJSfXBhY2tldCB0eXBlIGlzIHVua25vd246YDtcbmNvbnN0IEVSUl9OT1RfUEFDS0VUID0gYCR7UEVSUn1wYXNzZWQgb2JqZWN0IGlzIG5vdCBhIE5ldFBhY2tldGA7XG5jb25zdCBFUlJfVU5LTk9XTl9STU9ERSA9IGAke1BFUlJ9cGFja2V0IHJvdXRpbmUgbW9kZSBpcyB1bmtub3duOmA7XG5cbi8vLyBDT05TVEFOVFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbmNvbnN0IE1fSU5JVCA9ICdpbml0JztcbmNvbnN0IE1fT05MSU5FID0gJ29ubGluZSc7XG5jb25zdCBNX1NUQU5EQUxPTkUgPSAnb2ZmbGluZSc7XG5jb25zdCBNX0NMT1NFRCA9ICdjbG9zZWQnO1xuY29uc3QgTV9FUlJPUiA9ICdlcnJvcic7XG5jb25zdCBWQUxJRF9DSEFOTkVMUyA9IFsnTE9DQUwnLCAnTkVUJywgJ1NUQVRFJ107IC8vICogaXMgYWxsIGNoYW5uZWxzIGluIGxpc3RcblxuLy8vIERFQ0xBUkFUSU9OUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxubGV0IG1faWRfY291bnRlciA9IDA7XG5sZXQgbV9pZF9wcmVmaXggPSAnUEtUJztcbmxldCBtX3RyYW5zYWN0aW9ucyA9IHt9O1xubGV0IG1fbmV0c29ja2V0ID0gbnVsbDtcbmxldCBtX2dyb3VwX2lkID0gbnVsbDtcbmxldCBtX21vZGUgPSBNX0lOSVQ7XG5cbi8vLyBFTlVNUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbmNvbnN0IFBBQ0tFVF9UWVBFUyA9IFtcbiAgJ21zZW5kJywgLy8gYSAnc2VuZCcgbWVzc2FnZSByZXR1cm5zIG5vIGRhdGFcbiAgJ21zaWcnLCAvLyBhICdzaWduYWwnIG1lc3NhZ2UgaXMgYSBzZW5kIHRoYXQgY2FsbHMgYWxsIGhhbmRsZXJzIGV2ZXJ5d2hlcmVcbiAgJ21jYWxsJywgLy8gYSAnY2FsbCcgbWVzc2FnZSByZXR1cm5zIGRhdGFcbiAgJ3N0YXRlJyAvLyAodW5pbXBsZW1lbnRlZCkgYSAnc3RhdGUnIG1lc3NhZ2UgaXMgdXNlZCBieSBhIHN0YXRlIG1hbmFnZXJcbl07XG5jb25zdCBUUkFOU0FDVElPTl9NT0RFID0gW1xuICAncmVxJywgLy8gcGFja2V0IGluIGluaXRpYWwgJ3JlcXVlc3QnIG1vZGVcbiAgJ3JlcycgLy8gcGFja2V0IGluIHJldHVybmVkICdyZXNwb25zZScgbW9kZVxuXTtcblxuLy8vIFVSU1lTIE5FVE1FU1NBR0UgQ0xBU1MgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIENsYXNzIE5ldFBhY2tldFxuICogQ29udGFpbmVyIGZvciBtZXNzYWdlcyB0aGF0IGNhbiBiZSBzZW50IGFjcm9zcyB0aGUgbmV0d29yayB0byB0aGUgVVJTWVNcbiAqIHNlcnZlci5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IE5ldFBhY2tldFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1zZyAtIG1lc3NhZ2VcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhIC0gbWVzc2FnZSBkYXRhXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBpbnRlcm5hbCBpZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgLSBwYWNrZXQgb3BlcmF0aW9uIHR5cGUgKDF3YXksMndheSxzeW5jKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJtb2RlIC0gdHJhbnNhY3Rpb24gZGlyZWN0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVtbyAtIGh1bWFuLXJlYWRhYmxlIGRlYnVnIG5vdGUgc3BhY2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZXFudW0gLSBzZXF1ZW5jZSBudW1iZXIgZm9yIHRyYW5zYWN0aW9uXG4gKiBAcHJvcGVydHkge0FycmF5fSBzZXFsb2cgLSBhcnJheSBvZiBzZXFudW1zLCBzdGFydGluZyB3aXRoIG9yaWdpbmF0aW5nIGFkZHJlc3NcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzX3VpZCAtIG9yaWdpbmF0aW5nIGJyb3dzZXIgaW50ZXJuYWwgZW5kcG9pbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzX3VhZGRyIC0gb3JpZ2luYXRpbmcgYnJvd3NlciBhZGRyZXNzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc19ncm91cCAtIGdyb3VwIHNlc3Npb24ga2V5XG4gKi9cbmNsYXNzIE5ldFBhY2tldCB7XG4gIC8qKiBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IG1zZyBtZXNzYWdlIG5hbWUsIG9yIGFuIGV4aXN0aW5nIHBsYWluIG9iamVjdCB0byBjb2VyY2UgaW50byBhIE5ldFBhY2tldFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBkYXRhIHBhY2tldCB0byBzZW5kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSBtZXNzYWdlIChkZWZpbmVkIGluIFBBQ0tFVF9UWVBFUylcbiAgICovXG4gIGNvbnN0cnVjdG9yKG1zZywgZGF0YSwgdHlwZSkge1xuICAgIC8vIE9QVElPTiAxXG4gICAgLy8gY3JlYXRlIE5ldFBhY2tldCBmcm9tIChnZW5lcmljIG9iamVjdClcbiAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ29iamVjdCcgJiYgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgaXQgaGFzIGEgbXNnIGFuZCBkYXRhIG9ialxuICAgICAgaWYgKHR5cGVvZiBtc2cubXNnICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgbXNnLmRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IEVycm9yKEVSUl9OT1RfTkVUTUVTRyk7XG4gICAgICB9XG4gICAgICAvLyBtZXJnZSBwcm9wZXJ0aWVzIGludG8gdGhpcyBuZXcgY2xhc3MgaW5zdGFuY2UgYW5kIHJldHVybiBpdFxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBtc2cpO1xuICAgICAgdGhpcy5zZXFsb2cgPSB0aGlzLnNlcWxvZy5zbGljZSgpOyAvLyBjb3B5IGFycmF5XG4gICAgICBtX1NlcUluY3JlbWVudCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBPUFRJT04gMlxuICAgIC8vIGNyZWF0ZSBOZXRQYWNrZXQgZnJvbSBKU09OLWVuY29kZWQgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnICYmIGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IG9iaiA9IEpTT04ucGFyc2UobXNnKTtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgb2JqKTtcbiAgICAgIG1fU2VxSW5jcmVtZW50KHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIE9QVElPTiAzXG4gICAgLy8gY3JlYXRlIG5ldyBOZXRQYWNrZXQgZnJvbSBzY3JhdGNoIChtZXNnLGRhdGEpXG4gICAgLy8gdW5pcXVlIGlkIGZvciBldmVyeSBOZXRQYWNrZXRcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSBtX0NoZWNrVHlwZSh0eXBlKTtcbiAgICBpZiAodHlwZW9mIG1zZyAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBFcnJvcihFUlJfRVJSX0JBRF9DU1RSKTtcbiAgICB9XG4gICAgLy8gYWxsb3cgY2FsbHMgd2l0aCBudWxsIGRhdGEgYnkgc2V0dGluZyB0byBlbXB0eSBvYmplY3RcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIHRoaXMubXNnID0gbXNnO1xuICAgIC8vIGlkIGFuZCBkZWJ1Z2dpbmcgbWVtbyBzdXBwb3J0XG4gICAgdGhpcy5pZCA9IHRoaXMuTWFrZU5ld0lEKCk7XG4gICAgdGhpcy5ybW9kZSA9IFRSQU5TQUNUSU9OX01PREVbMF07IC8vIGlzIGRlZmF1bHQgJ3JlcXVlc3QnICh0cmFucyByZXF1ZXN0KVxuICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgUEFDS0VUX1RZUEVTWzBdOyAvLyBpcyBkZWZhdWx0ICdtc2VuZCcgKG5vIHJldHVybilcbiAgICB0aGlzLm1lbW8gPSAnJztcbiAgICAvLyB0cmFuc2FjdGlvbiBzdXBwb3J0XG4gICAgdGhpcy5zZXFudW0gPSAwOyAvLyBwb3NpdGl2ZSB3aGVuIHBhcnQgb2YgdHJhbnNhY3Rpb25cbiAgICB0aGlzLnNlcWxvZyA9IFtdOyAvLyB0cmFuc2FjdGlvbiBsb2dcbiAgICAvLyBhZGRyZXNzaW5nIHN1cHBvcnRcbiAgICB0aGlzLnNfdWFkZHIgPSBOZXRQYWNrZXQuU29ja2V0VUFERFIoKSB8fCBudWxsOyAvLyBmaXJzdCBvcmlnaW5hdGluZyB1YWRkciBzZXQgYnkgU29ja2V0U2VuZCgpXG4gICAgdGhpcy5zX2dyb3VwID0gbnVsbDsgLy8gc2Vzc2lvbiBncm91cGlkIGlzIHNldCBieSBleHRlcm5hbCBtb2R1bGUgb25jZSB2YWxpZGF0ZWRcbiAgICB0aGlzLnNfdWlkID0gbnVsbDsgLy8gZmlyc3Qgb3JpZ2luYXRpbmcgVVJDSEFOIHNyY1VJRFxuICAgIC8vIGZpbHRlcmluZyBzdXBwb3J0XG4gIH0gLy8gY29uc3RydWN0b3JcblxuICAvLy8gQUNDRVNTU09SIE1FVEhPRFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LlR5cGUoKSByZXR1cm5zIHRoZSBUUkFOU0FDVElPTl9UWVBFIG9mIHRoaXMgcGFja2V0XG4gICAqL1xuICBUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LlR5cGUoKSByZXR1cm5zIHRydWUgaWYgdHlwZSBtYXRjaGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSB0eXBlIHRvIGNvbXBhcmUgd2l0aCB0aGUgcGFja2V0J3MgdHlwZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIElzVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZTtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBOZXRQYWNrZXQuU2V0VHlwZSgpIHNldHMgdGhlIHR5cGUgb2YgdGhlIHBhY2tldC4gTXVzdCBiZSBhIGtub3duIHR5cGVcbiAgICogaW4gUEFDS0VUX1RZUEVTXG4gICAqL1xuICBTZXRUeXBlKHR5cGUpIHtcbiAgICB0aGlzLnR5cGUgPSBtX0NoZWNrVHlwZSh0eXBlKTtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiByZXR1cm5zIHRoZSBtZXNzYWdlIHN0cmluZyBvZiBmb3JtIENIQU5ORUw6TUVTU0FHRSwgd2hlcmUgQ0hBTk5FTDpcbiAgICogaXMgb3B0aW9uYWxcbiAgICovXG4gIE1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMubXNnO1xuICB9XG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiByZXR1cm5zIE1FU1NBR0Ugd2l0aG91dCB0aGUgQ0hBTk5FTDogcHJlZml4LiBUaGUgY2hhbm5lbCAoZS5nLlxuICAgKiBORVQsIExPQ0FMLCBTVEFURSkgaXMgYWxzbyBzZXQgdHJ1ZVxuICAgKi9cbiAgRGVjb2RlZE1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIE5ldFBhY2tldC5FeHRyYWN0Q2hhbm5lbCh0aGlzLm1zZyk7XG4gIH1cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqIE5ldFBhY2tldC5JcygpIHJldHVybnMgdHJ1dGh5IHZhbHVlICh0aGlzLmRhdGEpIGlmIHRoZSBwYXNzZWQgbXNnc3RyXG4gICAqICBtYXRjaGVzIHRoZSBtZXNzYWdlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIE5ldFBhY2tldFxuICAgKi9cbiAgSXMobXNnc3RyKSB7XG4gICAgcmV0dXJuIG1zZ3N0ciA9PT0gdGhpcy5tc2cgPyB0aGlzLmRhdGEgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LklzU2VydmVyTWVzc2FnZSgpIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gcmV0dXJuIHRydWUgaWZcbiAgICogc2VydmVyIG1lc3NhZ2UgKi9cbiAgSXNTZXJ2ZXJNZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLm1zZy5zdGFydHNXaXRoKCdORVQ6U1JWXycpO1xuICB9XG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqIE5ldFBhY2tldC5TZXRNZXNzYWdlKCkgc2V0cyB0aGUgbWVzc2FnZSBmaWVsZFxuICAgKi9cbiAgU2V0TWVzc2FnZShtc2dzdHIpIHtcbiAgICB0aGlzLm1zZyA9IG1zZ3N0cjtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBOZXRQYWNrZXQuRGF0YSgpIHJldHVybnMgdGhlIGVudGlyZSBkYXRhIHBheWxvYWQgb3IgdGhlIHByb3BlcnR5IHdpdGhpblxuICAgKiB0aGUgZGF0YSBwYXlsb2FkIChjYW4gcmV0dXJuIHVuZGVmaW5lZCBpZiBwcm9wZXJ0eSBkb2Vzbid0IGV4aXN0KVxuICAgKi9cbiAgRGF0YShwcm9wKSB7XG4gICAgaWYgKCFwcm9wKSByZXR1cm4gdGhpcy5kYXRhO1xuICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHJldHVybiB0aGlzLmRhdGFbcHJvcF07XG4gICAgdGhyb3cgRXJyb3IoRVJSX0JBRF9QUk9QKTtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gc2V0IGRhdGEgb2JqZWN0IGVudGlyZWx5XG4gICAqL1xuICBTZXREYXRhKHByb3BPclZhbCwgdmFsKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wT3JWYWwgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLmRhdGEgPSBwcm9wT3JWYWw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcE9yVmFsID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5kYXRhW3Byb3BPclZhbF0gPSB2YWw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IEVycm9yKEVSUl9CQURfUFJPUCk7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0Lk1lbW8oKSByZXR1cm5zIHRoZSAnbWVtbycgZmllbGQgb2YgdGhlIHBhY2tldCAqL1xuICBNZW1vKCkge1xuICAgIHJldHVybiB0aGlzLm1lbW87XG4gIH1cblxuICBTZXRNZW1vKG1lbW8pIHtcbiAgICB0aGlzLm1lbW8gPSBtZW1vO1xuICB9XG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqIE5ldFBhY2tldC5KU09OKCkgcmV0dXJucyBhIHN0cmluZ2lmaWVkIEpTT04gdmVyc2lvbiBvZiB0aGUgcGFja2V0LiAqL1xuICBKU09OKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBOZXRQYWNrZXQuU291cmNlR3JvdXBJZCgpIHJldHVybiB0aGUgc2Vzc2lvbiBncm91cCBpZCBhc3NvY2lhdGVkIHdpdGhcbiAgICogdGhpcyBwYWNrZXQuXG4gICAqL1xuICBTb3VyY2VHcm91cElEKCkge1xuICAgIHJldHVybiB0aGlzLnNfZ3JvdXA7XG4gIH1cblxuICAvLy8gVFJBTlNBQ1RJT04gU1VQUE9SVCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LlNlcU51bSgpIHJldHVybnMgYSBub24tcG9zaXRpdmUgaW50ZWdlciB0aGF0IGlzIHRoZSBudW1iZXIgb2ZcbiAgICogdGltZXMgdGhpcyBwYWNrZXQgd2FzIHJldXNlZCBkdXJpbmcgYSB0cmFuc2FjdGlvbiAoZS5nLiAnbWNhbGwnIHR5cGVzKS5cbiAgICovXG4gIFNlcU51bSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXFudW07XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LlNvdXJjZUFkZHJlc3MoKSByZXR1cm5zIHRoZSBvcmlnaW5hdGluZyBicm93c2VyIG9mIHRoZSBwYWNrZXQsXG4gICAqIHdoaWNoIGlzIHRoZSBzb2NrZXRuYW1lIG1haW50YWluZWQgYnkgdGhlIFVSU1lTIHNlcnZlci4gSXQgaXMgdmFsaWQgb25seVxuICAgKiBhZnRlciB0aGUgVVJTWVMgc2VydmVyIGhhcyByZWNlaXZlZCBpdCwgc28gaXQgaXMgaW52YWxpZCB3aGVuIGEgTmV0UGFja2V0XG4gICAqIHBhY2tldCBpcyBmaXJzdCBjcmVhdGVkLlxuICAgKi9cbiAgU291cmNlQWRkcmVzcygpIHtcbiAgICAvKi8gTk9URVxuXG4gICAgICAgIHNfdWFkZHIgaXMgdGhlIG1vc3QgcmVjZW50IHNlbmRpbmcgYnJvd3Nlci5cblxuICAgICAgICBJZiBhIE5ldFBhY2tldCBwYWNrZXQgaXMgcmV1c2VkIGluIGEgdHJhbnNhY3Rpb24gKGUuZy4gYSBjYWxsIHRoYXQgcmV0dXJuc1xuICAgICAgICBkYXRhKSB0aGVuIHRoZSBvcmlnaW5hdGluZyBicm93c2VyIGlzIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICBsb2cgLnNlcWxvZ1xuICAgIC8qL1xuICAgIC8vIGlzIHRoaXMgcGFja2V0IG9yaWdpbmF0aW5nIGZyb20gc2VydmVyIHRvIGEgcmVtb3RlP1xuICAgIGlmIChcbiAgICAgIHRoaXMuc191YWRkciA9PT0gTmV0UGFja2V0LkRlZmF1bHRTZXJ2ZXJVQUREUigpICYmXG4gICAgICAhdGhpcy5tc2cuc3RhcnRzV2l0aCgnTkVUOlNWUl8nKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXMuc191YWRkcjtcbiAgICB9XG4gICAgLy8gdGhpcyBpcyBhIHJlZ3VsYXIgbWVzc2FnZSBmb3J3YXJkIHRvIHJlbW90ZSBoYW5kbGVyc1xuICAgIHJldHVybiB0aGlzLklzVHJhbnNhY3Rpb24oKSA/IHRoaXMuc2VxbG9nWzBdIDogdGhpcy5zX3VhZGRyO1xuICB9XG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBSZXR1cm4gdHJ1ZSBpZiB0aGlzIHBrdCBpcyBmcm9tIHRoZSBzZXJ2ZXIgdGFyZ2V0aW5nIHJlbW90ZSBoYW5kbGVyc1xuICAgKi9cbiAgSXNTZXJ2ZXJPcmlnaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuU291cmNlQWRkcmVzcygpID09PSBOZXRQYWNrZXQuRGVmYXVsdFNlcnZlclVBRERSKCk7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LkNvcHlTb3VyY2VBZGRyZXNzKCkgY29waWVzIHRoZSBzb3VyY2UgYWRkcmVzcyBvZiBzZXRzIHRoZVxuICAgKiBjdXJyZW50IGFkZHJlc3MgdG8gdGhlIG9yaWdpbmF0aW5nIFVSU1lTIGJyb3dzZXIgYWRkcmVzcy4gVXNlZCBieSBzZXJ2ZXJcbiAgICogZm9yd2FyZGluZyBhbmQgcmV0dXJuaW5nIHBhY2tldHMgYmV0d2VlbiByZW1vdGVzLlxuICAgKiBAcGFyYW0ge05ldFBhY2tldH0gcGt0IC0gdGhlIHBhY2tldCB0byBjb3B5IHNvdXJjZSBmcm9tXG4gICAqL1xuICBDb3B5U291cmNlQWRkcmVzcyhwa3QpIHtcbiAgICBpZiAocGt0LmNvbnN0cnVjdG9yLm5hbWUgIT09ICdOZXRQYWNrZXQnKSB0aHJvdyBFcnJvcihFUlJfTk9UX1BBQ0tFVCk7XG4gICAgdGhpcy5zX3VhZGRyID0gcGt0LlNvdXJjZUFkZHJlc3MoKTtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gc2VydmVyLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBOZXRQYWNrZXQuSW5mbygpIHJldHVybnMgZGVidWcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHBhY2tldFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gdHlwZSBvZiBkZWJ1ZyBpbmZvIChhbHdheXMgJ3NyYycgY3VycmVudGx5KVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzb3VyY2UgYnJvd3NlciArIGdyb3VwIChpZiBzZXQpXG4gICAqL1xuICBJbmZvKGtleSkge1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlICdzcmMnOiAvKiBmYWxscy10aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5Tb3VyY2VHcm91cElEKClcbiAgICAgICAgICA/IGAke3RoaXMuU291cmNlQWRkcmVzcygpfSBbJHt0aGlzLlNvdXJjZUdyb3VwSUQoKX1dYFxuICAgICAgICAgIDogYCR7dGhpcy5Tb3VyY2VBZGRyZXNzKCl9YDtcbiAgICB9XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0Lk1ha2VOZXdJRCgpIGlzIGEgdXRpbGl0eSBtZXRob2QgdGhhdCBnZW5lcmF0ZXMgYSB1bmlxdWUgaWQgZm9yXG4gICAqIGVhY2ggTmV0UGFja2V0IHBhY2tldC4gV2hlbiBjb21iaW5lZCB3aXRoIHNfdWFkZHIgYW5kIHNfc3JjdWlkLCB0aGlzIGdpdmVzXG4gICAqIGEgcGFja2V0IGEgdW5pcXVlIElEIGFjcm9zcyB0aGUgZW50aXJlIFVSU1lTIG5ldHdvcmsuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHVuaXF1ZSBpZFxuICAgKi9cbiAgTWFrZU5ld0lEKCkge1xuICAgIGxldCBpZFN0ciA9ICgrK21faWRfY291bnRlcikudG9TdHJpbmcoKTtcbiAgICB0aGlzLmlkID0gbV9pZF9wcmVmaXggKyBpZFN0ci5wYWRTdGFydCg1LCAnMCcpO1xuICAgIHJldHVybiB0aGlzLmlkO1xuICB9XG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqIE5ldFBhY2tldC5Tb2NrZXRTZW5kKCkgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgdG8gbGV0IHBhY2tldHMgJ3NlbmRcbiAgICogdGhlbXNlbHZlcycgdG8gdGhlIG5ldHdvcmsgdmlhIHRoZSBVUlNZUyBzZXJ2ZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0PW1fc29ja2V0fSBzb2NrZXQgLSB3ZWIgc29ja2V0IG9iamVjdC4gbV9zb2NrZXRcbiAgICogaXMgZGVmaW5lZCBvbmx5IG9uIGJyb3dzZXJzOyBzZWUgTmV0UGFja2V0Lkdsb2JhbFNldHVwKClcbiAgICovXG4gIFNvY2tldFNlbmQoc29ja2V0ID0gbV9uZXRzb2NrZXQpIHtcbiAgICBpZiAobV9tb2RlID09PSBNX09OTElORSB8fCBtX21vZGUgPT09IE1fSU5JVCkge1xuICAgICAgdGhpcy5zX2dyb3VwID0gTmV0UGFja2V0Lkdsb2JhbEdyb3VwSUQoKTtcbiAgICAgIGxldCBkc3QgPSBzb2NrZXQuVUFERFIgfHwgJ3VucmVnaXN0ZXJlZCBzb2NrZXQnO1xuICAgICAgaWYgKCFzb2NrZXQpIHRocm93IEVycm9yKCdTb2NrZXRTZW5kKHNvY2spIHJlcXVpcmVzIGEgdmFsaWQgc29ja2V0Jyk7XG4gICAgICBpZiAoREJHLnNlbmQpIHtcbiAgICAgICAgbGV0IHN0YXR1cyA9IGBzZW5kaW5nICcke3RoaXMuTWVzc2FnZSgpfScgdG8gJHtkc3R9YDtcbiAgICAgICAgY29uc29sZS5sb2coUFIsIHN0YXR1cyk7XG4gICAgICB9XG4gICAgICAvLyBmb3Igc2VydmVyLXNpZGUgd3MgbGlicmFyeSwgc2VuZCBzdXBwb3J0cyBhIGZ1bmN0aW9uIGNhbGxiYWNrXG4gICAgICAvLyBmb3IgV2ViU29ja2V0LCB0aGlzIGlzIGlnbm9yZWRcbiAgICAgIHNvY2tldC5zZW5kKHRoaXMuSlNPTigpLCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSBjb25zb2xlLmVycm9yKGBcXG5zb2NrZXQgJHtzb2NrZXQuVUFERFJ9IHJlcG9ydHMgZXJyb3IgJHtlcnJ9XFxuYCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1fbW9kZSAhPT0gTV9TVEFOREFMT05FKSB7XG4gICAgICBjb25zb2xlLmxvZyhQUiwgXCJTb2NrZXRTZW5kOiBDYW4ndCBzZW5kIGJlY2F1c2UgTmV0UGFja2V0IG1vZGUgaXNcIiwgbV9tb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFBSLCAnU1RBTkRBTE9ORSBNT0RFOiBTb2NrZXRTZW5kKCkgc3VwcHJlc3NlZCEnKTtcbiAgICB9XG4gICAgLy8gRllJOiBnbG9iYWwgbV9uZXRzb2NrZXQgaXMgbm90IGRlZmluZWQgb24gc2VydmVyLCBzaW5jZSBwYWNrZXRzIGFycml2ZSBvbiBtdWx0aXBsZSBzb2NrZXRzXG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LlByb21pc2VUcmFuc2FjdGlvbigpIG1hcHMgYSBwYWNrZXQgdG8gYSByZXR1cm4gaGFuZGxlciB1c2luZyBhXG4gICAqIHVuaXF1ZSBrZXkuIFRoaXMga2V5IGFsbG93cyBhbiBpbmNvbWluZyBwYWNrZXQgdG8gYmUgbWFwcGVkIGJhY2sgdG8gdGhlXG4gICAqIGNhbGxlciBldmVuIGlmIGl0IGlzIHRlY2huaWNhbGx5IGEgZGlmZmVyZW50IG9iamVjdCByZWNlaXZlZCBvdmVyIHRoZVxuICAgKiBuZXR3b3JrLlxuICAgKiBAcGFyYW0ge09iamVjdD1tX3NvY2tldH0gc29ja2V0IC0gd2ViIHNvY2tldCBvYmplY3QuIG1fc29ja2V0IGlzIGRlZmluZWRcbiAgICogb25seSBvbiBicm93c2Vyczsgc2VlIE5ldFBhY2tldC5HbG9iYWxTZXR1cCgpXG4gICAqL1xuICBQcm9taXNlVHJhbnNhY3Rpb24oc29ja2V0ID0gbV9uZXRzb2NrZXQpIHtcbiAgICBpZiAobV9tb2RlID09PSBNX1NUQU5EQUxPTkUpIHtcbiAgICAgIGNvbnNvbGUud2FybihQUiwgJ1NUQU5EQUxPTkUgTU9ERTogUHJvbWlzZVRyYW5zYWN0aW9uKCkgc3VwcHJlc3NlZCEnKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLy8gZ2xvYmFsIG1fbmV0c29ja2V0IGlzIG5vdCBkZWZpbmVkIG9uIHNlcnZlciwgc2luY2UgcGFja2V0cyBhcnJpdmUgb24gbXVsdGlwbGUgc29ja2V0c1xuICAgIGlmICghc29ja2V0KSB0aHJvdyBFcnJvcignUHJvbWlzZVRyYW5zYWN0aW9uKHNvY2spIHJlcXVpcmVzIGEgdmFsaWQgc29ja2V0Jyk7XG4gICAgLy8gc2F2ZSBvdXIgY3VycmVudCBVQUREUlxuICAgIHRoaXMuc2VxbG9nLnB1c2goTmV0UGFja2V0LlVBRERSKTtcbiAgICBsZXQgZGJnID0gREJHLnRyYW5zYWN0ICYmICF0aGlzLklzU2VydmVyTWVzc2FnZSgpO1xuICAgIGxldCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IGhhc2ggPSBtX0dldEhhc2hLZXkodGhpcyk7XG4gICAgICBpZiAobV90cmFuc2FjdGlvbnNbaGFzaF0pIHtcbiAgICAgICAgcmVqZWN0KEVycm9yKGAke0VSUl9EVVBFX1RSQU5TfToke2hhc2h9YCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2F2ZSB0aGUgcmVzb2x2ZSBmdW5jdGlvbiBpbiB0cmFuc2FjdGlvbnMgdGFibGU7XG4gICAgICAgIC8vIHByb21pc2Ugd2lsbCByZXNvbHZlIG9uIHJlbW90ZSBpbnZvY2F0aW9uIHdpdGggZGF0YVxuICAgICAgICBtX3RyYW5zYWN0aW9uc1toYXNoXSA9IGRhdGEgPT4ge1xuICAgICAgICAgIGlmIChkYmcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFBSLCAncmVzb2x2aW5nIHByb21pc2Ugd2l0aCcsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5Tb2NrZXRTZW5kKHNvY2tldCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LlJvdXRpbmdNb2RlKCkgcmV0dXJucyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBwYWNrZXQgdG8gYVxuICAgKiBkZXN0aW5hdGlvbiBoYW5kbGVyIChyZXEpIG9yIGJhY2sgdG8gdGhlIG9yaWdpbiAocmVzKS4gICovXG4gIFJvdXRpbmdNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLnJtb2RlO1xuICB9XG5cbiAgLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbiAgLyoqIE5ldFBhY2tldC5Jc1JlcXVlc3QoKSByZXR1cm5zIHRydWUgaWYgdGhpcyBwYWNrZXQgaXMgb25lIGJlaW5nIHNlbnRcbiAgICogdG8gYSByZW1vdGUgaGFuZGxlclxuICAgKi9cbiAgSXNSZXF1ZXN0KCkge1xuICAgIHJldHVybiB0aGlzLnJtb2RlID09PSAncmVxJztcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBOZXRQYWNrZXQuSXNSZXNwb25zZSgpIHJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgcGFja2V0XG4gICAqIGJlaW5nIHJldHVybmVkIGZyb20gYSByZW1vdGUgaGFuZGxlclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGlzIGEgdHJhbnNhY3Rpb24gcmVzcG9uc2VcbiAgICovXG4gIElzUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucm1vZGUgPT09ICdyZXMnO1xuICAgIC8vIG1vcmUgYnVsbGV0cHJvb2YgY2hlY2ssIGJ1dCB1bm5lY2Vzc2FyeVxuICAgIC8vIHJldHVybiB0aGlzLnJtb3ZlID09PSdyZXMnICYmIHRoaXMuU291cmNlQWRkcmVzcygpID09PSBOZXRQYWNrZXQuVUFERFI7XG4gIH1cblxuICAvLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuICAvKiogTmV0UGFja2V0LklzVHJhbnNhY3Rpb24oKSB0ZXN0cyB3aGV0aGVyIHRoZSBwYWNrZXQgaXMgYSByZXNwb25zZSB0byBhXG4gICAqIGNhbGwgdGhhdCB3YXMgc2VudCBvdXQgcHJldmlvdXNseS5cbiAgICovXG4gIElzVHJhbnNhY3Rpb24oKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucm1vZGUgIT09ICdyZXEnICYmXG4gICAgICB0aGlzLnNlcW51bSA+IDAgJiZcbiAgICAgIHRoaXMuc2VxbG9nWzBdID09PSBOZXRQYWNrZXQuVUFERFJcbiAgICApO1xuICB9XG5cbiAgLy8vXHQtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBOZXRQYWNrZXQuUmV0dXJuVHJhbnNhY3Rpb24oKSBpcyB1c2VkIHRvIHNlbmQgYSBwYWNrZXQgYmFjayB0byBpdHNcbiAgICogb3JpZ2luLiBJdCBzYXZlcyB0aGUgY3VycmVudCBicm93c2VyIGFkZHJlc3MgKHN0b3JlZCBpbiBOZXRQYWNrZXQuVUFERFIpLFxuICAgKiBzZXRzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHBhY2tldCwgYW5kIHB1dHMgaXQgb24gdGhlIHNvY2tldC5cbiAgICogQHBhcmFtIHtPYmplY3Q9bV9zb2NrZXR9IHNvY2tldCAtIHdlYiBzb2NrZXQgb2JqZWN0LiBtX3NvY2tldCBpcyBkZWZpbmVkXG4gICAqIG9ubHkgb24gYnJvd3NlcnM7IHNlZSBOZXRQYWNrZXQuR2xvYmFsU2V0dXAoKVxuICAgKi9cbiAgUmV0dXJuVHJhbnNhY3Rpb24oc29ja2V0ID0gbV9uZXRzb2NrZXQpIHtcbiAgICAvLyBnbG9iYWwgbV9uZXRzb2NrZXQgaXMgbm90IGRlZmluZWQgb24gc2VydmVyLCBzaW5jZSBwYWNrZXRzIGFycml2ZSBvbiBtdWx0aXBsZSBzb2NrZXRzXG4gICAgaWYgKCFzb2NrZXQpIHRocm93IEVycm9yKCdSZXR1cm5UcmFuc2FjdGlvbihzb2NrKSByZXF1aXJlcyBhIHZhbGlkIHNvY2tldCcpO1xuICAgIC8vIG5vdGU6IHNlcW51bSBpcyBhbHJlYWR5IGluY3JlbWVudGVkIGJ5IHRoZSBjb25zdHJ1Y3RvciBpZiB0aGlzIHdhc1xuICAgIC8vIGEgcmVjZWl2ZWQgcGFja2V0XG4gICAgLy8gYWRkIHRoaXMgdG8gdGhlIHNlcXVlbmNlIGxvZ1xuICAgIHRoaXMuc2VxbG9nLnB1c2goTmV0UGFja2V0LlVBRERSKTtcbiAgICB0aGlzLnJtb2RlID0gbV9DaGVja1JNb2RlKCdyZXMnKTtcbiAgICB0aGlzLlNvY2tldFNlbmQoc29ja2V0KTtcbiAgfVxuXG4gIC8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4gIC8qKiBOZXRQYWNrZXQuQ29tcGxldGVUcmFuc2FjdGlvbigpIGlzIGNhbGxlZCB3aGVuIGEgcGFja2V0IGlzIHJlY2VpdmVkIGJhY2tcbiAgICogZnJvbSB0aGUgcmVtb3RlIGhhbmRsZXIuIEF0IHRoaXMgcG9pbnQsIHRoZSBvcmlnaW5hbCBjYWxsZXIgbmVlZHMgdG8gYmVcbiAgICogaW5mb3JtZWQgdmlhIHRoZSBzYXZlZCBmdW5jdGlvbiBoYW5kbGVyIGNyZWF0ZWQgaW5cbiAgICogTmV0UGFja2V0LlByb21pc2VUcmFuc2FjdGlvbigpLlxuICAgKi9cbiAgQ29tcGxldGVUcmFuc2FjdGlvbigpIHtcbiAgICBsZXQgZGJnID0gREJHLnRyYW5zYWN0ICYmICF0aGlzLklzU2VydmVyTWVzc2FnZSgpO1xuICAgIGxldCBoYXNoID0gbV9HZXRIYXNoS2V5KHRoaXMpO1xuICAgIGxldCByZXNvbHZlckZ1bmMgPSBtX3RyYW5zYWN0aW9uc1toYXNoXTtcbiAgICBpZiAoZGJnKSBjb25zb2xlLmxvZyhQUiwgJ0NvbXBsZXRlVHJhbnNhY3Rpb24nLCBoYXNoKTtcbiAgICBpZiAodHlwZW9mIHJlc29sdmVyRnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGB0cmFuc2FjdGlvbiBbJHtoYXNofV0gcmVzb2x2ZXJGdW5jdGlvbiBpcyB0eXBlICR7dHlwZW9mIHJlc29sdmVyRnVuY31gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlckZ1bmModGhpcy5kYXRhKTtcbiAgICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkobV90cmFuc2FjdGlvbnNbaGFzaF0pO1xuICAgIH1cbiAgfVxufSAvLyBjbGFzcyBOZXRQYWNrZXRcblxuLy8vIFNUQVRJQyBDTEFTUyBNRVRIT0RTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIE5ldFBhY2tldC5HbG9iYWxTZXR1cCgpIGlzIGEgc3RhdGljIG1ldGhvZCB0aGF0IGluaXRpYWxpemVzIHNoYXJlZFxuICogcGFyYW1ldGVycyBmb3IgdXNlIGJ5IGFsbCBpbnN0YW5jZXMgb2YgdGhlIE5ldFBhY2tldCBjbGFzcy4gSXQgaXMgdXNlZCBvbmx5XG4gKiBvbiBicm93c2Vycywgd2hpY2ggaGF2ZSBhIHNpbmdsZSBzb2NrZXQgY29ubmVjdGlvbi5cbiAqXG4gKiBJZiBubyBuZXRzb2NrZXQgcHJvcGVydHkgaXMgZGVmaW5lZCwgdGhlbiBOZXRQYWNrZXQgaW5zdGFuY2VzIHdpbGwgc3VycHJlc3NcbiAqIHNlbmRpbmcgb2YgbmV0d29yayBtZXNzYWdlcyB3aGlsZSBhbGxvd2luZyBsb2NhbCBtZXNzYWdlcyB0byB3b3JrIG5vcm1hbGx5LlxuICogU2VlIE5ldFBhY2tldC5HbG9iYWxPZmZsaW5lTW9kZSgpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gLSBjb25maWd1cmF0aW9uIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcubmV0c29ja2V0XSAtIHZhbGlkIHdlYnNvY2tldCB0byBVUlNZUyBzZXJ2ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnVhZGRyXSAtIFVSU1lTIGJyb3dzZXIgYWRkcmVzc1xuICovXG5OZXRQYWNrZXQuR2xvYmFsU2V0dXAgPSAoY29uZmlnID0ge30pID0+IHtcbiAgbGV0IHsgdWFkZHIsIG5ldHNvY2tldCwgcGVlcnMsIGlzX2xvY2FsIH0gPSBjb25maWc7XG4gIGlmICh1YWRkcikgTmV0UGFja2V0LlVBRERSID0gdWFkZHI7XG4gIGlmIChwZWVycykgTmV0UGFja2V0LlBFRVJTID0gcGVlcnM7XG4gIGlmIChuZXRzb2NrZXQpIHtcbiAgICAvLyBOT1RFOiBtX25ldHNvY2tldCBpcyBzZXQgb25seSBvbiBjbGllbnRzIHNpbmNlIG9uIHNlcnZlciwgdGhlcmUgYXJlXG4gICAgLy8gbXVsdGlwbGUgc29ja2V0c1xuICAgIGlmICh0eXBlb2YgbmV0c29ja2V0LnNlbmQgIT09ICdmdW5jdGlvbicpIHRocm93IEVycm9yKEVSUl9CQURfU09DS0VUKTtcbiAgICBpZiAoREJHLnNldHVwKSBjb25zb2xlLmxvZyhQUiwgJ0dsb2JhbFNldHVwOiBuZXRzb2NrZXQgc2V0LCBtb2RlIG9ubGluZScpO1xuICAgIG1fbmV0c29ja2V0ID0gbmV0c29ja2V0O1xuICAgIG1fbW9kZSA9IE1fT05MSU5FO1xuICB9XG4gIGlmIChpc19sb2NhbCkgTmV0UGFja2V0LlVMT0NBTCA9IGlzX2xvY2FsO1xufTtcbk5ldFBhY2tldC5VQUREUiA9ICdVTkFTU0lHTkVEJztcbk5ldFBhY2tldC5VTE9DQUwgPSBmYWxzZTsgLy8gc2V0IGlmIGNvbm5lY3Rpb24gaXMgYSBsb2NhbCBjb25uZWN0aW9uXG5OZXRQYWNrZXQuUEVFUlMgPSB1bmRlZmluZWQ7XG5cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBOZXRQYWNrZXQuR2xvYmFsQ2xlYW51cCgpIGlzIGEgc3RhdGljIG1ldGhvZCBjYWxsZWQgb25seSBieSB0aGUgY2xpZW50LFxuICogd2hpY2ggZHJvcHMgdGhlIGN1cnJlbnQgc29ja2V0IGFuZCBwdXRzIHRoZSBhcHAgaW4gJ2Nsb3NlZCcgc3RhdGUuIEluXG4gKiBwcmFjdGljZSB0aGlzIGNhbGwgZG9lc24ndCBhY2NvbXBsaXNoIG11Y2gsIGJ1dCBpcyBoZXJlIGZvciBzeW1tZXRyeSB0b1xuICogR2xvYmFsU2V0dXAoKS5cbiAqIEBmdW5jdGlvblxuICovXG5OZXRQYWNrZXQuR2xvYmFsQ2xlYW51cCA9ICgpID0+IHtcbiAgaWYgKG1fbmV0c29ja2V0KSB7XG4gICAgaWYgKERCRy5zZXR1cClcbiAgICAgIGNvbnNvbGUubG9nKFBSLCAnR2xvYmFsQ2xlYW51cDogZGVhbGxvY2F0aW5nIG5ldHNvY2tldCwgbW9kZSBjbG9zZWQnKTtcbiAgICBtX25ldHNvY2tldCA9IG51bGw7XG4gICAgbV9tb2RlID0gTV9DTE9TRUQ7XG4gICAgTmV0UGFja2V0LlVMT0NBTCA9IGZhbHNlO1xuICB9XG59O1xuXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogU3RhdGljIG1ldGhvZCBOZXRQYWNrZXQuR2xvYmFsT2ZmbGluZU1vZGUoKSBleHBsaWNpdGx5IHNldHMgdGhlIG1vZGUgdG8gU1RBTkRBTE9ORSwgd2hpY2hcbiAqIGFjdGl2ZWx5IHN1cHByZXNzZXMgcmVtb3RlIG5ldHdvcmsgY29tbXVuaWNhdGlvbiB3aXRob3V0IHRocm93aW5nIGVycm9ycy5cbiAqIEl0J3MgdXNlZCBmb3Igc3RhdGljIGNvZGUgc25hcHNob3RzIG9mIHRoZSB3ZWJhcHAgdGhhdCBkb24ndCBuZWVkIHRoZVxuICogbmV0d29yay5cbiAqIEBmdW5jdGlvblxuICovXG5OZXRQYWNrZXQuR2xvYmFsT2ZmbGluZU1vZGUgPSAoKSA9PiB7XG4gIG1fbW9kZSA9IE1fU1RBTkRBTE9ORTtcbiAgaWYgKG1fbmV0c29ja2V0KSB7XG4gICAgY29uc29sZS5sb2coLi4uUFIoJ1NUQU5EQUxPTkUgTU9ERTogTmV0UGFja2V0IGRpc2FibGluZyBuZXR3b3JrJykpO1xuICAgIG1fbmV0c29ja2V0ID0gbnVsbDtcbiAgICBsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ1VSU1lTRGlzY29ubmVjdCcsIHt9KTtcbiAgICBjb25zb2xlLmxvZyguLi5QUignU1RBTkRBTE9ORSBNT0RFOiBzZW5kaW5nIFVSU1lTRGlzY29ubmVjdCcpKTtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxufTtcbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKlxuICogQ29udmVydHMgJ0NIQU5ORUw6TUVTU0FHRScgc3RyaW5nIHRvIGFuIG9iamVjdCB3aXRoIGNoYW5uZWwsIG1lc3NhZ2VcbiAqIHByb3BlcnRpZXMuIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgOiBpbiB0aGUgbWVzc2FnZSBzdHJpbmcsIGl0J3MgbGVmdFxuICogYXMgcGFydCBvZiB0aGUgbWVzc2FnZS4gQWxsIHByb3BlcnRpZXMgcmV0dXJuZWQgaW4gYXJlIFVQUEVSQ0FTRS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gbWVzc2FnZSB3aXRoIG9wdGlvbmFsIGNoYW5uZWwgcHJlZml4XG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIGNvbnRhaW5zIGNoYW5uZWwgKFVDKSB0aGF0IGFyZSBzZXRcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBwYXJzZWQgPSBOZXRQYWNrZXQuRGVjb2RlQ2hhbm5lbCgnTkVUOk1ZX01FU1NBR0UnKTtcbiAqIGlmIChwYXJzZWQuTkVUKSBjb25zb2xlLmxvZygndGhpcyBpcyB0cnVlJyk7XG4gKiBpZiAocGFyc2VkLkxPQ0FMKSBjb25zb2xlLmxvZygndGhpcyBpcyBmYWxzZScpO1xuICogY29uc29sZS5sb2coJ21lc3NhZ2UgaXMnLHBhcnNlZC5NRVNTQUdFKTtcbiAqL1xuTmV0UGFja2V0LkV4dHJhY3RDaGFubmVsID0gZnVuY3Rpb24gRXh0cmFjdENoYW5uZWwobXNnKSB7XG4gIGxldCBbY2hhbm5lbCwgTUVTU0FHRV0gPSBtc2cuc3BsaXQoJzonLCAyKTtcbiAgLy8gbm8gOiBmb3VuZCwgbXVzdCBiZSBsb2NhbFxuICBpZiAoIU1FU1NBR0UpIHtcbiAgICBNRVNTQUdFID0gY2hhbm5lbDtcbiAgICBjaGFubmVsID0gJyc7XG4gIH1cbiAgY29uc3QgcGFyc2VkID0geyBNRVNTQUdFIH07XG4gIGlmICghY2hhbm5lbCkge1xuICAgIHBhcnNlZC5MT0NBTCA9IHRydWU7XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBpZiAoY2hhbm5lbCA9PT0gJyonKSB7XG4gICAgVkFMSURfQ0hBTk5FTFMuZm9yRWFjaChjaGFuID0+IHtcbiAgICAgIHBhcnNlZFtjaGFuXSA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBpZiAoVkFMSURfQ0hBTk5FTFMuaW5jbHVkZXMoY2hhbm5lbCkpIHtcbiAgICBwYXJzZWRbY2hhbm5lbF0gPSB0cnVlO1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgLy8gbGVnYWN5IG1lc3NhZ2VzIHVzZSBpbnZhbGlkIGNoYW5uZWwgbmFtZXNcbiAgLy8gZm9yIG5vdyBmb3J3YXJkIHRoZW0gYXMtaXNcbiAgY29uc29sZS53YXJuKGAnJHttc2d9JyByZXBsYWNlIDogd2l0aCBfYCk7XG4gIHBhcnNlZC5MT0NBTCA9IHRydWU7XG4gIHJldHVybiBwYXJzZWQ7XG4gIC8vIHRoaXMgaXMgd2hhdCBzaG91bGQgYWN0dWFsbHkgaGFwcGVuXG4gIC8vIHRocm93IEVycm9yKGBpbnZhbGlkIGNoYW5uZWwgJyR7Y2hhbm5lbH0nYCk7XG59O1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIE5ldFBhY2tldC5Tb2NrZXRVQUREUigpIGlzIGEgc3RhdGljIG1ldGhvZCByZXR1cm5pbmcgdGhlIGNsYXNzLXdpZGUgc2V0dGluZ1xuICogb2YgdGhlIGJyb3dzZXIgVUFERFIuIFRoaXMgaXMgb25seSB1c2VkIG9uIGJyb3dzZXIgY29kZS5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge3N0cmluZ30gVVJTWVMgYWRkcmVzcyBvZiB0aGUgY3VycmVudCBicm93c2VyLCBhIFVSU1lTIGFkZHJlc3NcbiAqL1xuTmV0UGFja2V0LlNvY2tldFVBRERSID0gKCkgPT4ge1xuICByZXR1cm4gTmV0UGFja2V0LlVBRERSO1xufTtcbk5ldFBhY2tldC5QZWVycyA9ICgpID0+IHtcbiAgcmV0dXJuIE5ldFBhY2tldC5QRUVSUztcbn07XG5OZXRQYWNrZXQuSXNMb2NhbGhvc3QgPSAoKSA9PiB7XG4gIHJldHVybiBOZXRQYWNrZXQuVUxPQ0FMO1xufTtcblxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIE5ldFBhY2tldC5EZWZhdWx0U2VydmVyVUFERFIoKSBpcyBhIHN0YXRpYyBtZXRob2QgcmV0dXJuaW5nIGEgaGFyZGNvZGVkXG4gKiBVUlNZUyBhZGRyZXNzIHJlZmVycmluZyB0byB0aGUgVVJTWVMgc2VydmVyLiBJdCBpcyB1c2VkIGJ5IHRoZSBzZXJ2ZXItc2lkZVxuICogY29kZSB0byBzZXQgdGhlIHNlcnZlciBhZGRyZXNzLCBhbmQgdGhlIGJyb3dzZXIgY2FuIHJlbHkgb24gaXQgYXMgd2VsbC5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge3N0cmluZ30gVVJTWVMgYWRkcmVzcyBvZiB0aGUgc2VydmVyXG4gKi9cbk5ldFBhY2tldC5EZWZhdWx0U2VydmVyVUFERFIgPSAoKSA9PiB7XG4gIHJldHVybiAnU1ZSXzAxJztcbn07XG5cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBOZXRQYWNrZXQuR2xvYmFsR3JvdXBJRCgpIGlzIGEgc3RhdGljIG1ldGhvZCByZXR1cm5pbmcgdGhlIHNlc3Npb24ga2V5XG4gKiAoYWthIGdyb3VwLWlkKSBzZXQgZm9yIHRoaXMgYnJvd3NlciBpbnN0YW5jZVxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBzZXNzaW9uIGtleVxuICovXG5OZXRQYWNrZXQuR2xvYmFsR3JvdXBJRCA9ICgpID0+IHtcbiAgcmV0dXJuIG1fZ3JvdXBfaWQ7XG59O1xuXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogTmV0UGFja2V0Lkdsb2JhbFNldEdyb3VwSUQoKSBpcyBhIHN0YXRpYyBtZXRob2QgdGhhdCBzdG9yZXMgdGhlIHBhc3NlZFxuICogdG9rZW4gYXMgdGhlIEdyb3VwSURcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gc3BlY2lhbCBzZXNzaW9uIGtleSBkYXRhXG4gKi9cbk5ldFBhY2tldC5HbG9iYWxTZXRHcm91cElEID0gdG9rZW4gPT4ge1xuICBtX2dyb3VwX2lkID0gdG9rZW47XG59O1xuXG4vLy8gUFJJVkFURSBDTEFTUyBIRUxQRVJTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKi8gREVQUkVDQVRFPyBVdGlsaXR5IGZ1bmN0aW9uIHRvIGluY3JlbWVudCB0aGUgcGFja2V0J3Mgc2VxdWVuY2UgbnVtYmVyXG4gKiAgQHBhcmFtIHtOZXRQYWNrZXR9IHBrdCAtIHBhY2tldCB0byBtb2RpZnlcbi8qL1xuZnVuY3Rpb24gbV9TZXFJbmNyZW1lbnQocGt0KSB7XG4gIHBrdC5zZXFudW0rKztcbiAgcmV0dXJuIHBrdDtcbn1cbi8vL1x0LSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKi8gVXRpbGl0eSB0byBjcmVhdGUgYSB1bmlxdWUgaGFzaCBrZXkgZnJvbSBwYWNrZXQgaW5mb3JtYXRpb24uIFVzZWQgYnlcbiAqICBQcm9taXNlVHJhbnNhY3Rpb24oKS5cbiAqICBAcGFyYW0ge05ldFBhY2tldH0gcGt0IC0gcGFja2V0IHRvIHVzZVxuICogIEByZXR1cm4ge3N0cmluZ30gaGFzaCBrZXkgc3RyaW5nXG4vKi9cbmZ1bmN0aW9uIG1fR2V0SGFzaEtleShwa3QpIHtcbiAgbGV0IGhhc2ggPSBgJHtwa3QuU291cmNlQWRkcmVzcygpfToke3BrdC5pZH1gO1xuICByZXR1cm4gaGFzaDtcbn1cbi8vL1x0LSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKi8gVXRpbGl0eSB0byBlbnN1cmUgdGhhdCB0aGUgcGFzc2VkIHR5cGUgaXMgb25lIG9mIHRoZSBhbGxvd2VkIHBhY2tldCB0eXBlcy5cbiAqICBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgaXMgbm90LlxuICogIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gYSBzdHJpbmcgdG8gYmUgbWF0Y2hlZCBhZ2FpbnN0IFBBQ0tFVF9UWVBFU1xuICogIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBzdHJpbmcgdGhhdCBwYXNzZWQgdGhlIHR5cGUgY2hlY2tcbi8qL1xuZnVuY3Rpb24gbV9DaGVja1R5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdXN0IHBhc3MgYSB0eXBlIHN0cmluZywgbm90ICR7dHlwZX1gKTtcbiAgfVxuICBpZiAoIVBBQ0tFVF9UWVBFUy5pbmNsdWRlcyh0eXBlKSkgdGhyb3cgRXJyb3IoYCR7RVJSX1VOS05PV05fVFlQRX0gJyR7dHlwZX0nYCk7XG4gIHJldHVybiB0eXBlO1xufVxuLy8vXHQtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qLyBVdGlsaXR5IHRvIGVuc3VyZSB0aGUgcGFzc2VkIHRyYW5zYWN0aW9uIG1vZGUgaXMgb25lIG9mIHRoZSBhbGxvd2VkXG4gKiAgdHlwZXMuIFRocm93cyBhbiBlcnJvciBpZiBpdCBpcyBub3QuXG4gKiAgQHBhcmFtIHtzdHJpbmd9IG1vZGUgLSBhIHN0cmluZyB0byBiZSBtYXRjaGVkIGFnYWluc3QgVFJBTlNBQ1RJT05fTU9ERVxuICogIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBzdHJpbmcgdGhlIHBhc3NlZCB0aGUgbW9kZSBjaGVja1xuLyovXG5mdW5jdGlvbiBtX0NoZWNrUk1vZGUobW9kZSkge1xuICBpZiAobW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdXN0IHBhc3MgYSBtb2RlIHN0cmluZywgbm90ICR7bW9kZX1gKTtcbiAgfVxuICBpZiAoIVRSQU5TQUNUSU9OX01PREUuaW5jbHVkZXMobW9kZSkpXG4gICAgdGhyb3cgRXJyb3IoYCR7RVJSX1VOS05PV05fUk1PREV9ICcke21vZGV9J2ApO1xuICByZXR1cm4gbW9kZTtcbn1cblxuLy8vIEVYUE9SVCBDTEFTUyBERUZJTklUSU9OIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuTmV0UGFja2V0LkNPREVfT0sgPSAwO1xuTmV0UGFja2V0LkNPREVfTk9fTUVTU0FHRSA9IDE7IC8vIHJlcXVlc3RlZCBtZXNzYWdlIGRvZXNuJ3QgZXhpc3Rcbk5ldFBhY2tldC5DT0RFX1NPQ19OT1NPQ0sgPSAtMTAwO1xuTmV0UGFja2V0LkNPREVfU0VTX1JFUVVJUkVfS0VZID0gLTIwMDsgLy8gYWNjZXNzIGtleSBub3Qgc2V0XG5OZXRQYWNrZXQuQ09ERV9TRVNfUkVRVUlSRV9MT0dJTiA9IC0yMDE7IC8vIHNvY2tldCB3YXMgbm90IGxvZ2dlZC1pblxuTmV0UGFja2V0LkNPREVfU0VTX0lOVkFMSURfS0VZID0gLTIwMjsgLy8gcHJvdmlkZWQga2V5IGRpZG4ndCBtYXRjaCBzb2NrZXQga2V5XG5OZXRQYWNrZXQuQ09ERV9TRVNfUkVfUkVHSVNURVIgPSAtMjAzOyAvLyBzZXNzaW9uIGF0dGVtcHRlZCB0byBsb2dpbiBhZ2FpblxuTmV0UGFja2V0LkNPREVfU0VTX0lOVkFMSURfVE9LRU4gPSAtMjA0OyAvLyBzZXNzaW9uIGF0dGVtcHRlZCB0byBsb2dpbiBhZ2FpblxuTmV0UGFja2V0LkNPREVfUkVHX0RFTklFRCA9IC0zMDA7IC8vIHJlZ2lzdHJhdGlvbiBvZiBoYW5kbGVyIGRlbmllZFxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLy8vIHVzaW5nIENvbW1vbkpTIGZvcm1hdCBvbiBwdXJwb3NlIGZvciBub2RlIGNvbXBhdGliaWxpdHlcbm1vZHVsZS5leHBvcnRzID0gTmV0UGFja2V0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/class-netpacket.js\n");

/***/ }),

/***/ "./src/index-server.js":
/*!*****************************!*\
  !*** ./src/index-server.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__filename) {/*///////////////////////////////// ABOUT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\n\n  URSYS SERVER MAIN ENTRY\n\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ * /////////////////////////////////////*/\n/// LIBRARIES /////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nconst {\n  parse\n} = __webpack_require__(/*! url */ \"url\");\n\nconst requestIp = __webpack_require__(/*! request-ip */ \"../../node_modules/request-ip/dist/index.js\");\n\nconst NETWORK = __webpack_require__(/*! ./server-urnet */ \"./src/server-urnet.js\");\n\nconst PROMPTS = __webpack_require__(/*! ./util/prompts */ \"./src/util/prompts.js\"); /// DECLARATIONS //////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nlet m_network_options; /// META DATA /////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** these properties are exported from the library so you can tell if the\n *  ur instance you're using is serverside or clientside, if that needs\n *  to be checked\n */\n\nconst META = {\n  _SERVER: true,\n  _SCRIPT: __filename,\n  _VERSION: '0.0.1'\n};\nconst URNET_PROP_ROUTE = '/urnet/getinfo'; /// SERVER-SIDE ///////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst STORE = {};\nconst EXPRESS = {};\nconst LOGGER = {}; // const NETWORK = {};\n\nconst MEDIA = {}; /// LIBRARY INITIALIZATION ////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** initialize dependent libraries\n */\n\nfunction Initialize() {// hooks registration goes here\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** deallocate any system resources assigned during Initialize\n */\n\n\nfunction Shutdown() {// ot\n} /// MAIN API //////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Start the URNET socket server\n */\n\n\nfunction StartServer(options) {\n  m_network_options = NETWORK.StartNetwork(options);\n  return m_network_options;\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Retrieve URNET broker information. The m_network_options object\n *  may contain non-broker information, so we return specific properties\n *  instead of the whole object.\n */\n\n\nfunction GetNetBroker() {\n  const {\n    host,\n    port,\n    urnet_version,\n    uaddr\n  } = m_network_options;\n  return {\n    host,\n    port,\n    urnet_version,\n    uaddr\n  };\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** given req and response, return URNET connection information\n */\n\n\nfunction ReplyWithUrnetInfo(req, res) {\n  res.setHeader('Content-Type', 'application/json');\n  res.writeHead(200);\n  let {\n    host,\n    port,\n    urnet_version,\n    uaddr\n  } = GetNetBroker();\n  let client_ip = requestIp.getClientIp(req); // prevent socket connection refusal due to mismatch of localhost\n  // with use of numeric IP when connecting to server\n\n  if (client_ip.includes('127.0.0.1')) client_ip = 'localhost';\n  const netProps = {\n    broker: {\n      host,\n      port,\n      urnet_version,\n      uaddr\n    },\n    client: {\n      ip: client_ip\n    }\n  };\n  res.end(JSON.stringify(netProps));\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Called from a custom NextJS server using http.createServer(requestListener).\n *  This listener is hardcoded with the urnet API, so it is independent of\n *  the NextJS and other frameworks.\n */\n\n\nfunction HttpRequestListener(req, res) {\n  // Be sure to pass `true` as the second argument to `url.parse`.\n  // This tells it to parse the query portion of the URL.\n  const parsedUrl = parse(req.url, true); // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  const {\n    pathname,\n    query\n  } = parsedUrl; // Do our route interception here\n\n  if (pathname === URNET_PROP_ROUTE) {\n    ReplyWithUrnetInfo(req, res);\n    return true;\n  }\n\n  return false;\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nfunction ExpressHandler(req, res, next) {\n  const parsedUrl = parse(req.url, true); // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  const {\n    pathname,\n    query\n  } = parsedUrl;\n\n  if (pathname === URNET_PROP_ROUTE) {\n    ReplyWithUrnetInfo(req, res);\n  } else next();\n} /// EXPORTS ///////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nmodule.exports = { // META\n  ...META,\n  // MAIN API\n  Initialize,\n  Shutdown,\n  StartServer,\n  GetNetBroker,\n  HttpRequestListener,\n  ExpressHandler,\n  // SERVICES API\n  STORE,\n  EXPRESS,\n  LOGGER,\n  NETWORK,\n  MEDIA,\n  // PROMPT UTILITIES\n  PrefixUtil: PROMPTS.makeStyleFormatter,\n  TermOut: PROMPTS.makeTerminalOut,\n  SetPromptColor: PROMPTS.setPromptColor\n};\n/* WEBPACK VAR INJECTION */}.call(this, \"src/index-server.js\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgtc2VydmVyLmpzPzRjY2MiXSwibmFtZXMiOlsicGFyc2UiLCJyZXF1aXJlIiwicmVxdWVzdElwIiwiTkVUV09SSyIsIlBST01QVFMiLCJtX25ldHdvcmtfb3B0aW9ucyIsIk1FVEEiLCJfU0VSVkVSIiwiX1NDUklQVCIsIl9fZmlsZW5hbWUiLCJfVkVSU0lPTiIsIlVSTkVUX1BST1BfUk9VVEUiLCJTVE9SRSIsIkVYUFJFU1MiLCJMT0dHRVIiLCJNRURJQSIsIkluaXRpYWxpemUiLCJTaHV0ZG93biIsIlN0YXJ0U2VydmVyIiwib3B0aW9ucyIsIlN0YXJ0TmV0d29yayIsIkdldE5ldEJyb2tlciIsImhvc3QiLCJwb3J0IiwidXJuZXRfdmVyc2lvbiIsInVhZGRyIiwiUmVwbHlXaXRoVXJuZXRJbmZvIiwicmVxIiwicmVzIiwic2V0SGVhZGVyIiwid3JpdGVIZWFkIiwiY2xpZW50X2lwIiwiZ2V0Q2xpZW50SXAiLCJpbmNsdWRlcyIsIm5ldFByb3BzIiwiYnJva2VyIiwiY2xpZW50IiwiaXAiLCJlbmQiLCJKU09OIiwic3RyaW5naWZ5IiwiSHR0cFJlcXVlc3RMaXN0ZW5lciIsInBhcnNlZFVybCIsInVybCIsInBhdGhuYW1lIiwicXVlcnkiLCJFeHByZXNzSGFuZGxlciIsIm5leHQiLCJtb2R1bGUiLCJleHBvcnRzIiwiUHJlZml4VXRpbCIsIm1ha2VTdHlsZUZvcm1hdHRlciIsIlRlcm1PdXQiLCJtYWtlVGVybWluYWxPdXQiLCJTZXRQcm9tcHRDb2xvciIsInNldFByb21wdENvbG9yIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7QUFNQTtBQUNBO0FBQ0EsTUFBTTtBQUFFQTtBQUFGLElBQVlDLG1CQUFPLENBQUMsZ0JBQUQsQ0FBekI7O0FBQ0EsTUFBTUMsU0FBUyxHQUFHRCxtQkFBTyxDQUFDLCtEQUFELENBQXpCOztBQUNBLE1BQU1FLE9BQU8sR0FBR0YsbUJBQU8sQ0FBQyw2Q0FBRCxDQUF2Qjs7QUFDQSxNQUFNRyxPQUFPLEdBQUdILG1CQUFPLENBQUMsNkNBQUQsQ0FBdkIsQyxDQUVBO0FBQ0E7OztBQUNBLElBQUlJLGlCQUFKLEMsQ0FFQTtBQUNBOztBQUNBOzs7OztBQUlBLE1BQU1DLElBQUksR0FBRztBQUNYQyxTQUFPLEVBQUUsSUFERTtBQUVYQyxTQUFPLEVBQUVDLFVBRkU7QUFHWEMsVUFBUSxFQUFFO0FBSEMsQ0FBYjtBQUtBLE1BQU1DLGdCQUFnQixHQUFHLGdCQUF6QixDLENBRUE7QUFDQTs7QUFDQSxNQUFNQyxLQUFLLEdBQUcsRUFBZDtBQUNBLE1BQU1DLE9BQU8sR0FBRyxFQUFoQjtBQUNBLE1BQU1DLE1BQU0sR0FBRyxFQUFmLEMsQ0FDQTs7QUFDQSxNQUFNQyxLQUFLLEdBQUcsRUFBZCxDLENBRUE7QUFDQTs7QUFDQTs7O0FBRUEsU0FBU0MsVUFBVCxHQUFzQixDQUNwQjtBQUNELEMsQ0FDRDs7QUFDQTs7OztBQUVBLFNBQVNDLFFBQVQsR0FBb0IsQ0FDbEI7QUFDRCxDLENBRUQ7QUFDQTs7QUFDQTs7OztBQUVBLFNBQVNDLFdBQVQsQ0FBcUJDLE9BQXJCLEVBQThCO0FBQzVCZCxtQkFBaUIsR0FBR0YsT0FBTyxDQUFDaUIsWUFBUixDQUFxQkQsT0FBckIsQ0FBcEI7QUFDQSxTQUFPZCxpQkFBUDtBQUNELEMsQ0FDRDs7QUFDQTs7Ozs7O0FBSUEsU0FBU2dCLFlBQVQsR0FBd0I7QUFDdEIsUUFBTTtBQUFFQyxRQUFGO0FBQVFDLFFBQVI7QUFBY0MsaUJBQWQ7QUFBNkJDO0FBQTdCLE1BQXVDcEIsaUJBQTdDO0FBQ0EsU0FBTztBQUFFaUIsUUFBRjtBQUFRQyxRQUFSO0FBQWNDLGlCQUFkO0FBQTZCQztBQUE3QixHQUFQO0FBQ0QsQyxDQUVEOztBQUNBOzs7O0FBRUEsU0FBU0Msa0JBQVQsQ0FBNEJDLEdBQTVCLEVBQWlDQyxHQUFqQyxFQUFzQztBQUNwQ0EsS0FBRyxDQUFDQyxTQUFKLENBQWMsY0FBZCxFQUE4QixrQkFBOUI7QUFDQUQsS0FBRyxDQUFDRSxTQUFKLENBQWMsR0FBZDtBQUNBLE1BQUk7QUFBRVIsUUFBRjtBQUFRQyxRQUFSO0FBQWNDLGlCQUFkO0FBQTZCQztBQUE3QixNQUF1Q0osWUFBWSxFQUF2RDtBQUNBLE1BQUlVLFNBQVMsR0FBRzdCLFNBQVMsQ0FBQzhCLFdBQVYsQ0FBc0JMLEdBQXRCLENBQWhCLENBSm9DLENBS3BDO0FBQ0E7O0FBQ0EsTUFBSUksU0FBUyxDQUFDRSxRQUFWLENBQW1CLFdBQW5CLENBQUosRUFBcUNGLFNBQVMsR0FBRyxXQUFaO0FBQ3JDLFFBQU1HLFFBQVEsR0FBRztBQUNmQyxVQUFNLEVBQUU7QUFDTmIsVUFETTtBQUVOQyxVQUZNO0FBR05DLG1CQUhNO0FBSU5DO0FBSk0sS0FETztBQU9mVyxVQUFNLEVBQUU7QUFDTkMsUUFBRSxFQUFFTjtBQURFO0FBUE8sR0FBakI7QUFXQUgsS0FBRyxDQUFDVSxHQUFKLENBQVFDLElBQUksQ0FBQ0MsU0FBTCxDQUFlTixRQUFmLENBQVI7QUFDRCxDLENBQ0Q7O0FBQ0E7Ozs7OztBQUlBLFNBQVNPLG1CQUFULENBQTZCZCxHQUE3QixFQUFrQ0MsR0FBbEMsRUFBdUM7QUFDckM7QUFDQTtBQUNBLFFBQU1jLFNBQVMsR0FBRzFDLEtBQUssQ0FBQzJCLEdBQUcsQ0FBQ2dCLEdBQUwsRUFBVSxJQUFWLENBQXZCLENBSHFDLENBSXJDOztBQUNBLFFBQU07QUFBRUMsWUFBRjtBQUFZQztBQUFaLE1BQXNCSCxTQUE1QixDQUxxQyxDQU1yQzs7QUFDQSxNQUFJRSxRQUFRLEtBQUtqQyxnQkFBakIsRUFBbUM7QUFDakNlLHNCQUFrQixDQUFDQyxHQUFELEVBQU1DLEdBQU4sQ0FBbEI7QUFDQSxXQUFPLElBQVA7QUFDRDs7QUFDRCxTQUFPLEtBQVA7QUFDRCxDLENBQ0Q7OztBQUNBLFNBQVNrQixjQUFULENBQXdCbkIsR0FBeEIsRUFBNkJDLEdBQTdCLEVBQWtDbUIsSUFBbEMsRUFBd0M7QUFDdEMsUUFBTUwsU0FBUyxHQUFHMUMsS0FBSyxDQUFDMkIsR0FBRyxDQUFDZ0IsR0FBTCxFQUFVLElBQVYsQ0FBdkIsQ0FEc0MsQ0FFdEM7O0FBQ0EsUUFBTTtBQUFFQyxZQUFGO0FBQVlDO0FBQVosTUFBc0JILFNBQTVCOztBQUNBLE1BQUlFLFFBQVEsS0FBS2pDLGdCQUFqQixFQUFtQztBQUNqQ2Usc0JBQWtCLENBQUNDLEdBQUQsRUFBTUMsR0FBTixDQUFsQjtBQUNELEdBRkQsTUFFT21CLElBQUk7QUFDWixDLENBRUQ7QUFDQTs7O0FBQ0FDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQixFQUNmO0FBQ0EsS0FBRzNDLElBRlk7QUFHZjtBQUNBVSxZQUplO0FBS2ZDLFVBTGU7QUFNZkMsYUFOZTtBQU9mRyxjQVBlO0FBUWZvQixxQkFSZTtBQVNmSyxnQkFUZTtBQVVmO0FBQ0FsQyxPQVhlO0FBWWZDLFNBWmU7QUFhZkMsUUFiZTtBQWNmWCxTQWRlO0FBZWZZLE9BZmU7QUFnQmY7QUFDQW1DLFlBQVUsRUFBRTlDLE9BQU8sQ0FBQytDLGtCQWpCTDtBQWtCZkMsU0FBTyxFQUFFaEQsT0FBTyxDQUFDaUQsZUFsQkY7QUFtQmZDLGdCQUFjLEVBQUVsRCxPQUFPLENBQUNtRDtBQW5CVCxDQUFqQixDIiwiZmlsZSI6Ii4vc3JjL2luZGV4LXNlcnZlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIEFCT1VUIFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwqXFxcblxuICBVUlNZUyBTRVJWRVIgTUFJTiBFTlRSWVxuXG5cXCpcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcICogLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyovXG5cbi8vLyBMSUJSQVJJRVMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbmNvbnN0IHsgcGFyc2UgfSA9IHJlcXVpcmUoJ3VybCcpO1xuY29uc3QgcmVxdWVzdElwID0gcmVxdWlyZSgncmVxdWVzdC1pcCcpO1xuY29uc3QgTkVUV09SSyA9IHJlcXVpcmUoJy4vc2VydmVyLXVybmV0Jyk7XG5jb25zdCBQUk9NUFRTID0gcmVxdWlyZSgnLi91dGlsL3Byb21wdHMnKTtcblxuLy8vIERFQ0xBUkFUSU9OUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxubGV0IG1fbmV0d29ya19vcHRpb25zO1xuXG4vLy8gTUVUQSBEQVRBIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogdGhlc2UgcHJvcGVydGllcyBhcmUgZXhwb3J0ZWQgZnJvbSB0aGUgbGlicmFyeSBzbyB5b3UgY2FuIHRlbGwgaWYgdGhlXG4gKiAgdXIgaW5zdGFuY2UgeW91J3JlIHVzaW5nIGlzIHNlcnZlcnNpZGUgb3IgY2xpZW50c2lkZSwgaWYgdGhhdCBuZWVkc1xuICogIHRvIGJlIGNoZWNrZWRcbiAqL1xuY29uc3QgTUVUQSA9IHtcbiAgX1NFUlZFUjogdHJ1ZSxcbiAgX1NDUklQVDogX19maWxlbmFtZSxcbiAgX1ZFUlNJT046ICcwLjAuMSdcbn07XG5jb25zdCBVUk5FVF9QUk9QX1JPVVRFID0gJy91cm5ldC9nZXRpbmZvJztcblxuLy8vIFNFUlZFUi1TSURFIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuY29uc3QgU1RPUkUgPSB7fTtcbmNvbnN0IEVYUFJFU1MgPSB7fTtcbmNvbnN0IExPR0dFUiA9IHt9O1xuLy8gY29uc3QgTkVUV09SSyA9IHt9O1xuY29uc3QgTUVESUEgPSB7fTtcblxuLy8vIExJQlJBUlkgSU5JVElBTElaQVRJT04gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIGluaXRpYWxpemUgZGVwZW5kZW50IGxpYnJhcmllc1xuICovXG5mdW5jdGlvbiBJbml0aWFsaXplKCkge1xuICAvLyBob29rcyByZWdpc3RyYXRpb24gZ29lcyBoZXJlXG59XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogZGVhbGxvY2F0ZSBhbnkgc3lzdGVtIHJlc291cmNlcyBhc3NpZ25lZCBkdXJpbmcgSW5pdGlhbGl6ZVxuICovXG5mdW5jdGlvbiBTaHV0ZG93bigpIHtcbiAgLy8gb3Rcbn1cblxuLy8vIE1BSU4gQVBJIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIFN0YXJ0IHRoZSBVUk5FVCBzb2NrZXQgc2VydmVyXG4gKi9cbmZ1bmN0aW9uIFN0YXJ0U2VydmVyKG9wdGlvbnMpIHtcbiAgbV9uZXR3b3JrX29wdGlvbnMgPSBORVRXT1JLLlN0YXJ0TmV0d29yayhvcHRpb25zKTtcbiAgcmV0dXJuIG1fbmV0d29ya19vcHRpb25zO1xufVxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIFJldHJpZXZlIFVSTkVUIGJyb2tlciBpbmZvcm1hdGlvbi4gVGhlIG1fbmV0d29ya19vcHRpb25zIG9iamVjdFxuICogIG1heSBjb250YWluIG5vbi1icm9rZXIgaW5mb3JtYXRpb24sIHNvIHdlIHJldHVybiBzcGVjaWZpYyBwcm9wZXJ0aWVzXG4gKiAgaW5zdGVhZCBvZiB0aGUgd2hvbGUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBHZXROZXRCcm9rZXIoKSB7XG4gIGNvbnN0IHsgaG9zdCwgcG9ydCwgdXJuZXRfdmVyc2lvbiwgdWFkZHIgfSA9IG1fbmV0d29ya19vcHRpb25zO1xuICByZXR1cm4geyBob3N0LCBwb3J0LCB1cm5ldF92ZXJzaW9uLCB1YWRkciB9O1xufVxuXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogZ2l2ZW4gcmVxIGFuZCByZXNwb25zZSwgcmV0dXJuIFVSTkVUIGNvbm5lY3Rpb24gaW5mb3JtYXRpb25cbiAqL1xuZnVuY3Rpb24gUmVwbHlXaXRoVXJuZXRJbmZvKHJlcSwgcmVzKSB7XG4gIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gIHJlcy53cml0ZUhlYWQoMjAwKTtcbiAgbGV0IHsgaG9zdCwgcG9ydCwgdXJuZXRfdmVyc2lvbiwgdWFkZHIgfSA9IEdldE5ldEJyb2tlcigpO1xuICBsZXQgY2xpZW50X2lwID0gcmVxdWVzdElwLmdldENsaWVudElwKHJlcSk7XG4gIC8vIHByZXZlbnQgc29ja2V0IGNvbm5lY3Rpb24gcmVmdXNhbCBkdWUgdG8gbWlzbWF0Y2ggb2YgbG9jYWxob3N0XG4gIC8vIHdpdGggdXNlIG9mIG51bWVyaWMgSVAgd2hlbiBjb25uZWN0aW5nIHRvIHNlcnZlclxuICBpZiAoY2xpZW50X2lwLmluY2x1ZGVzKCcxMjcuMC4wLjEnKSkgY2xpZW50X2lwID0gJ2xvY2FsaG9zdCc7XG4gIGNvbnN0IG5ldFByb3BzID0ge1xuICAgIGJyb2tlcjoge1xuICAgICAgaG9zdCxcbiAgICAgIHBvcnQsXG4gICAgICB1cm5ldF92ZXJzaW9uLFxuICAgICAgdWFkZHJcbiAgICB9LFxuICAgIGNsaWVudDoge1xuICAgICAgaXA6IGNsaWVudF9pcFxuICAgIH1cbiAgfTtcbiAgcmVzLmVuZChKU09OLnN0cmluZ2lmeShuZXRQcm9wcykpO1xufVxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIENhbGxlZCBmcm9tIGEgY3VzdG9tIE5leHRKUyBzZXJ2ZXIgdXNpbmcgaHR0cC5jcmVhdGVTZXJ2ZXIocmVxdWVzdExpc3RlbmVyKS5cbiAqICBUaGlzIGxpc3RlbmVyIGlzIGhhcmRjb2RlZCB3aXRoIHRoZSB1cm5ldCBBUEksIHNvIGl0IGlzIGluZGVwZW5kZW50IG9mXG4gKiAgdGhlIE5leHRKUyBhbmQgb3RoZXIgZnJhbWV3b3Jrcy5cbiAqL1xuZnVuY3Rpb24gSHR0cFJlcXVlc3RMaXN0ZW5lcihyZXEsIHJlcykge1xuICAvLyBCZSBzdXJlIHRvIHBhc3MgYHRydWVgIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYHVybC5wYXJzZWAuXG4gIC8vIFRoaXMgdGVsbHMgaXQgdG8gcGFyc2UgdGhlIHF1ZXJ5IHBvcnRpb24gb2YgdGhlIFVSTC5cbiAgY29uc3QgcGFyc2VkVXJsID0gcGFyc2UocmVxLnVybCwgdHJ1ZSk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgY29uc3QgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHBhcnNlZFVybDtcbiAgLy8gRG8gb3VyIHJvdXRlIGludGVyY2VwdGlvbiBoZXJlXG4gIGlmIChwYXRobmFtZSA9PT0gVVJORVRfUFJPUF9ST1VURSkge1xuICAgIFJlcGx5V2l0aFVybmV0SW5mbyhyZXEsIHJlcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuZnVuY3Rpb24gRXhwcmVzc0hhbmRsZXIocmVxLCByZXMsIG5leHQpIHtcbiAgY29uc3QgcGFyc2VkVXJsID0gcGFyc2UocmVxLnVybCwgdHJ1ZSk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgY29uc3QgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHBhcnNlZFVybDtcbiAgaWYgKHBhdGhuYW1lID09PSBVUk5FVF9QUk9QX1JPVVRFKSB7XG4gICAgUmVwbHlXaXRoVXJuZXRJbmZvKHJlcSwgcmVzKTtcbiAgfSBlbHNlIG5leHQoKTtcbn1cblxuLy8vIEVYUE9SVFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIE1FVEFcbiAgLi4uTUVUQSxcbiAgLy8gTUFJTiBBUElcbiAgSW5pdGlhbGl6ZSxcbiAgU2h1dGRvd24sXG4gIFN0YXJ0U2VydmVyLFxuICBHZXROZXRCcm9rZXIsXG4gIEh0dHBSZXF1ZXN0TGlzdGVuZXIsXG4gIEV4cHJlc3NIYW5kbGVyLFxuICAvLyBTRVJWSUNFUyBBUElcbiAgU1RPUkUsXG4gIEVYUFJFU1MsXG4gIExPR0dFUixcbiAgTkVUV09SSyxcbiAgTUVESUEsXG4gIC8vIFBST01QVCBVVElMSVRJRVNcbiAgUHJlZml4VXRpbDogUFJPTVBUUy5tYWtlU3R5bGVGb3JtYXR0ZXIsXG4gIFRlcm1PdXQ6IFBST01QVFMubWFrZVRlcm1pbmFsT3V0LFxuICBTZXRQcm9tcHRDb2xvcjogUFJPTVBUUy5zZXRQcm9tcHRDb2xvclxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index-server.js\n");

/***/ }),

/***/ "./src/server-logger.js":
/*!******************************!*\
  !*** ./src/server-logger.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable @typescript-eslint/no-use-before-define */\n\n/* eslint-disable no-param-reassign */\n\n/*//////////////////////////////// ABOUT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\n\n  LOGGER - WIP\n  porting PLAE logger for now to get it minimally working\n\n  SUPER UGLY PORT WILL CLEAN UP LATER AVERT YOUR EYES OMG\n\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ * //////////////////////////////////////*/\nconst DBG = false; /// LOAD LIBRARIES ////////////////////////////////////////////////////////////\n/// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n\nconst PATH = __webpack_require__(/*! path */ \"path\");\n\nconst FSE = __webpack_require__(/*! fs-extra */ \"../../node_modules/fs-extra/lib/index.js\"); /// for server-side modules,\n\n\nconst TOUT = __webpack_require__(/*! ./util/prompts */ \"./src/util/prompts.js\").makeTerminalOut(' URLOG'); /// CONSTANTS /////////////////////////////////////////////////////////////////\n/// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n\n\nconst DATESTR = __webpack_require__(/*! ./util/datestring */ \"./src/util/datestring.js\"); /// MODULE-WIDE VARS //////////////////////////////////////////////////////////\n/// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n\n\nlet LOG_DIR;\nconst LOG_DELIMITER = '\\t';\nlet fs_log = null;\n\nfunction StartLogging(options = {}) {\n  if (!options.runtimePath) throw Error('runtime path is required');\n  if (!options.serverName) options.serverName = '<UNNAMED SERVER>'; // initialize event logger\n\n  LOG_DIR = PATH.join(options.runtimePath, 'logs');\n  let dir = PATH.resolve(LOG_DIR);\n\n  try {\n    TOUT(`logging to ${dir}`);\n    FSE.ensureDirSync(dir);\n    let logname = `${DATESTR.DatedFilename('log')}.txt`;\n    let pathname = `${dir}/${logname}`;\n    fs_log = FSE.createWriteStream(pathname);\n    LogLine(`${options.serverName} APPSERVER SESSION LOG for ${DATESTR.DateStamp()} ${DATESTR.TimeStamp()}`);\n    LogLine('---');\n  } catch (err) {\n    if (err) throw new Error(`could not make ${dir} directory`);\n  }\n}\n/**\tLOGGING FUNCTIONS ******************************************************/\n///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/*/\tLog a standard system log message\n/*/\n\n\nfunction LogLine(...args) {\n  if (!fs_log) throw Error('must call StartLogging with runtimePath first');\n  let out = `${DATESTR.TimeStamp()} `;\n  let c = args.length; // arguments are delimited\n\n  if (c) {\n    for (let i = 0; i < c; i++) {\n      if (i > 0) out += LOG_DELIMITER;\n      out += args[i];\n    }\n  }\n\n  out += '\\n';\n  fs_log.write(out);\n} /// API METHODS ///////////////////////////////////////////////////////////////\n/// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n\n\nlet LOG = {}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** API: Handle incoming log events\n */\n\nLOG.PKT_LogEvent = pkt => {\n  let {\n    event,\n    items\n  } = pkt.Data();\n  if (DBG) console.log(TOUT, pkt.Info(), event, ...items);\n  LogLine(pkt.Info(), event || '-', ...items);\n  return {\n    OK: true\n  };\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** API: Write to log as delimited arguments\n */\n\n\nLOG.Write = LogLine; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** API: Initialize Logger\n */\n\nLOG.StartLogging = StartLogging; /// EXPORT MODULE DEFINITION //////////////////////////////////////////////////\n/// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n\nmodule.exports = LOG;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2VydmVyLWxvZ2dlci5qcz83ZmFlIl0sIm5hbWVzIjpbIkRCRyIsIlBBVEgiLCJyZXF1aXJlIiwiRlNFIiwiVE9VVCIsIm1ha2VUZXJtaW5hbE91dCIsIkRBVEVTVFIiLCJMT0dfRElSIiwiTE9HX0RFTElNSVRFUiIsImZzX2xvZyIsIlN0YXJ0TG9nZ2luZyIsIm9wdGlvbnMiLCJydW50aW1lUGF0aCIsIkVycm9yIiwic2VydmVyTmFtZSIsImpvaW4iLCJkaXIiLCJyZXNvbHZlIiwiZW5zdXJlRGlyU3luYyIsImxvZ25hbWUiLCJEYXRlZEZpbGVuYW1lIiwicGF0aG5hbWUiLCJjcmVhdGVXcml0ZVN0cmVhbSIsIkxvZ0xpbmUiLCJEYXRlU3RhbXAiLCJUaW1lU3RhbXAiLCJlcnIiLCJhcmdzIiwib3V0IiwiYyIsImxlbmd0aCIsImkiLCJ3cml0ZSIsIkxPRyIsIlBLVF9Mb2dFdmVudCIsInBrdCIsImV2ZW50IiwiaXRlbXMiLCJEYXRhIiwiY29uc29sZSIsImxvZyIsIkluZm8iLCJPSyIsIldyaXRlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBU0EsTUFBTUEsR0FBRyxHQUFHLEtBQVosQyxDQUVBO0FBQ0E7O0FBQ0EsTUFBTUMsSUFBSSxHQUFHQyxtQkFBTyxDQUFDLGtCQUFELENBQXBCOztBQUNBLE1BQU1DLEdBQUcsR0FBR0QsbUJBQU8sQ0FBQywwREFBRCxDQUFuQixDLENBQ0E7OztBQUNBLE1BQU1FLElBQUksR0FBR0YsbUJBQU8sQ0FBQyw2Q0FBRCxDQUFQLENBQTBCRyxlQUExQixDQUEwQyxRQUExQyxDQUFiLEMsQ0FFQTtBQUNBOzs7QUFDQSxNQUFNQyxPQUFPLEdBQUdKLG1CQUFPLENBQUMsbURBQUQsQ0FBdkIsQyxDQUVBO0FBQ0E7OztBQUNBLElBQUlLLE9BQUo7QUFDQSxNQUFNQyxhQUFhLEdBQUcsSUFBdEI7QUFDQSxJQUFJQyxNQUFNLEdBQUcs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QW5CLEMsQ0FFQTtBQUNBOztBQUNBa0MsTUFBTSxDQUFDQyxPQUFQLEdBQWlCWixHQUFqQiIsImZpbGUiOiIuL3NyYy9zZXJ2ZXItbG9nZ2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuLyovLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBBQk9VVCBcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwqXFxcblxuICBMT0dHRVIgLSBXSVBcbiAgcG9ydGluZyBQTEFFIGxvZ2dlciBmb3Igbm93IHRvIGdldCBpdCBtaW5pbWFsbHkgd29ya2luZ1xuXG4gIFNVUEVSIFVHTFkgUE9SVCBXSUxMIENMRUFOIFVQIExBVEVSIEFWRVJUIFlPVVIgRVlFUyBPTUdcblxuXFwqXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwgKiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyovXG5cbmNvbnN0IERCRyA9IGZhbHNlO1xuXG4vLy8gTE9BRCBMSUJSQVJJRVMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9XG5jb25zdCBQQVRIID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgRlNFID0gcmVxdWlyZSgnZnMtZXh0cmEnKTtcbi8vLyBmb3Igc2VydmVyLXNpZGUgbW9kdWxlcyxcbmNvbnN0IFRPVVQgPSByZXF1aXJlKCcuL3V0aWwvcHJvbXB0cycpLm1ha2VUZXJtaW5hbE91dCgnIFVSTE9HJyk7XG5cbi8vLyBDT05TVEFOVFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID1cbmNvbnN0IERBVEVTVFIgPSByZXF1aXJlKCcuL3V0aWwvZGF0ZXN0cmluZycpO1xuXG4vLy8gTU9EVUxFLVdJREUgVkFSUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9XG5sZXQgTE9HX0RJUjtcbmNvbnN0IExPR19ERUxJTUlURVIgPSAnXFx0JztcbmxldCBmc19sb2cgPSBudWxsO1xuXG5mdW5jdGlvbiBTdGFydExvZ2dpbmcob3B0aW9ucyA9IHt9KSB7XG4gIGlmICghb3B0aW9ucy5ydW50aW1lUGF0aCkgdGhyb3cgRXJyb3IoJ3J1bnRpbWUgcGF0aCBpcyByZXF1aXJlZCcpO1xuICBpZiAoIW9wdGlvbnMuc2VydmVyTmFtZSkgb3B0aW9ucy5zZXJ2ZXJOYW1lID0gJzxVTk5BTUVEIFNFUlZFUj4nO1xuICAvLyBpbml0aWFsaXplIGV2ZW50IGxvZ2dlclxuICBMT0dfRElSID0gUEFUSC5qb2luKG9wdGlvbnMucnVudGltZVBhdGgsICdsb2dzJyk7XG4gIGxldCBkaXIgPSBQQVRILnJlc29sdmUoTE9HX0RJUik7XG4gIHRyeSB7XG4gICAgVE9VVChgbG9nZ2luZyB0byAke2Rpcn1gKTtcbiAgICBGU0UuZW5zdXJlRGlyU3luYyhkaXIpO1xuICAgIGxldCBsb2duYW1lID0gYCR7REFURVNUUi5EYXRlZEZpbGVuYW1lKCdsb2cnKX0udHh0YDtcbiAgICBsZXQgcGF0aG5hbWUgPSBgJHtkaXJ9LyR7bG9nbmFtZX1gO1xuICAgIGZzX2xvZyA9IEZTRS5jcmVhdGVXcml0ZVN0cmVhbShwYXRobmFtZSk7XG4gICAgTG9nTGluZShcbiAgICAgIGAke1xuICAgICAgICBvcHRpb25zLnNlcnZlck5hbWVcbiAgICAgIH0gQVBQU0VSVkVSIFNFU1NJT04gTE9HIGZvciAke0RBVEVTVFIuRGF0ZVN0YW1wKCl9ICR7REFURVNUUi5UaW1lU3RhbXAoKX1gXG4gICAgKTtcbiAgICBMb2dMaW5lKCctLS0nKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVycikgdGhyb3cgbmV3IEVycm9yKGBjb3VsZCBub3QgbWFrZSAke2Rpcn0gZGlyZWN0b3J5YCk7XG4gIH1cbn1cblxuLyoqXHRMT0dHSU5HIEZVTkNUSU9OUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vLy9cdC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qL1x0TG9nIGEgc3RhbmRhcmQgc3lzdGVtIGxvZyBtZXNzYWdlXG4vKi9cbmZ1bmN0aW9uIExvZ0xpbmUoLi4uYXJncykge1xuICBpZiAoIWZzX2xvZykgdGhyb3cgRXJyb3IoJ211c3QgY2FsbCBTdGFydExvZ2dpbmcgd2l0aCBydW50aW1lUGF0aCBmaXJzdCcpO1xuXG4gIGxldCBvdXQgPSBgJHtEQVRFU1RSLlRpbWVTdGFtcCgpfSBgO1xuICBsZXQgYyA9IGFyZ3MubGVuZ3RoO1xuICAvLyBhcmd1bWVudHMgYXJlIGRlbGltaXRlZFxuICBpZiAoYykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYzsgaSsrKSB7XG4gICAgICBpZiAoaSA+IDApIG91dCArPSBMT0dfREVMSU1JVEVSO1xuICAgICAgb3V0ICs9IGFyZ3NbaV07XG4gICAgfVxuICB9XG4gIG91dCArPSAnXFxuJztcbiAgZnNfbG9nLndyaXRlKG91dCk7XG59XG5cbi8vLyBBUEkgTUVUSE9EUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID1cbmxldCBMT0cgPSB7fTtcbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBBUEk6IEhhbmRsZSBpbmNvbWluZyBsb2cgZXZlbnRzXG4gKi9cbkxPRy5QS1RfTG9nRXZlbnQgPSBwa3QgPT4ge1xuICBsZXQgeyBldmVudCwgaXRlbXMgfSA9IHBrdC5EYXRhKCk7XG4gIGlmIChEQkcpIGNvbnNvbGUubG9nKFRPVVQsIHBrdC5JbmZvKCksIGV2ZW50LCAuLi5pdGVtcyk7XG4gIExvZ0xpbmUocGt0LkluZm8oKSwgZXZlbnQgfHwgJy0nLCAuLi5pdGVtcyk7XG4gIHJldHVybiB7IE9LOiB0cnVlIH07XG59O1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIEFQSTogV3JpdGUgdG8gbG9nIGFzIGRlbGltaXRlZCBhcmd1bWVudHNcbiAqL1xuTE9HLldyaXRlID0gTG9nTGluZTtcbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBBUEk6IEluaXRpYWxpemUgTG9nZ2VyXG4gKi9cbkxPRy5TdGFydExvZ2dpbmcgPSBTdGFydExvZ2dpbmc7XG5cbi8vLyBFWFBPUlQgTU9EVUxFIERFRklOSVRJT04gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID0gPSA9ID1cbm1vZHVsZS5leHBvcnRzID0gTE9HO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/server-logger.js\n");

/***/ }),

/***/ "./src/server-urnet.js":
/*!*****************************!*\
  !*** ./src/server-urnet.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable @typescript-eslint/no-use-before-define */\n\n/* eslint-disable no-param-reassign */\n\n/* eslint-disable no-restricted-syntax */\n\n/*//////////////////////////////// ABOUT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\n\n  WebSocketServer and Network Management for URSYS\n\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ * //////////////////////////////////////*/\n///\tLOAD LIBRARIES ////////////////////////////////////////////////////////////\n///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nconst IP = __webpack_require__(/*! ip */ \"../../node_modules/ip/lib/ip.js\");\n\nconst WSS = __webpack_require__(/*! ws */ \"../../node_modules/ws/index.js\").Server;\n\nconst NetPacket = __webpack_require__(/*! ./class-netpacket */ \"./src/class-netpacket.js\");\n\nconst LOGGER = __webpack_require__(/*! ./server-logger */ \"./src/server-logger.js\");\n\nconst SESSION = __webpack_require__(/*! ./util/session */ \"./src/util/session.js\");\n\nconst TOUT = __webpack_require__(/*! ./util/prompts */ \"./src/util/prompts.js\").makeTerminalOut(' URNET'); /// DEBUG MESSAGES ////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nconst DBG = {\n  init: true,\n  calls: false,\n  client: true\n};\nconst ERR_SS_EXISTS = 'socket server already created';\nconst DBG_SOCK_BADCLOSE = 'closing socket is not in mu_sockets';\nconst ERR_INVALID_DEST = \"couldn't find socket with provided address\"; /// CONSTANTS /////////////////////////////////////////////////////////////////\n///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst DEFAULT_NET_PORT = 2929;\nconst SERVER_UADDR = NetPacket.DefaultServerUADDR(); // is 'SVR_01'\n\nconst PROTOCOL_VERSION = 3; /// MODULE-WIDE VARS //////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n/// sockets\n\nlet mu_wss; // websocket server\n\nlet mu_options; // websocket options\n\nlet mu_sockets = new Map(); // sockets mapped by socket id\n\nlet mu_sid_counter = 0; // for generating  unique socket ids\n// storage\n\nlet m_server_handlers = new Map(); // message map storing sets of functions\n\nlet m_remote_handlers = new Map(); // message map storing other handlers\n\nlet m_socket_msgs_list = new Map(); // message map by uaddr\n// module object\n\nlet UNET = {}; /// API METHODS ///////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Initializes the web socket server using the options set by\n *  InitializeNetwork(), and directs connections to utility function\n *  m_NewSocketConnected()\n *  @param {Object} [options] - configuration settings\n *  @param {number} [options.port] - default to DEFAULT_NET_PORT 2929\n *  @param {string} [options.uaddr] - default to DefaultServerUADDR() 'SVR_01'\n *  @returns {Object} complete configuration object\n */\n\nUNET.StartNetwork = (options = {}) => {\n  if (!options.runtimePath) {\n    return Error('runtimePath required to start URSYS SERVER');\n  }\n\n  LOGGER.StartLogging(options); // WSS options\n\n  options.host = IP.address();\n  options.port = options.port || DEFAULT_NET_PORT; // URNET options\n\n  options.uaddr = options.uaddr || SERVER_UADDR;\n  options.urnet_version = PROTOCOL_VERSION;\n  if (mu_wss !== undefined) throw Error(ERR_SS_EXISTS);\n  NetPacket.GlobalSetup({\n    uaddr: options.uaddr\n  });\n  mu_options = options; // create listener.\n\n  mu_wss = new WSS(mu_options);\n  mu_wss.on('listening', () => {\n    if (DBG.init) TOUT(`socket server listening on port ${mu_options.port}`);\n    mu_wss.on('connection', (socket, req) => {\n      // if (DBG) TOUT('socket connected');\n      // house keeping\n      m_SocketAdd(socket, req); // assign UADDR to socket\n\n      m_SocketClientAck(socket); // tell client HELLO with new UADDR\n      // subscribe socket to handlers\n\n      socket.on('message', json => m_SocketOnMessage(socket, json));\n      socket.on('close', () => m_SocketDelete(socket));\n    }); // end on 'connection'\n  });\n  return options;\n}; // end StartNetwork()\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Registers SERVER-side message handlers that are reachable from remote\n * clients. Server-side handlers use their own map.\n * @param {string} mesgName message to register a handler for\n * @param {function} handlerFunc function receiving 'data' object\n */\n\n\nUNET.NetSubscribe = (mesgName, handlerFunc) => {\n  if (typeof handlerFunc !== 'function') {\n    TOUT(`${mesgName} subscription failure`);\n    throw Error('arg2 must be a function');\n  }\n\n  let handlers = m_server_handlers.get(mesgName);\n\n  if (!handlers) {\n    handlers = new Set();\n    m_server_handlers.set(mesgName, handlers);\n  }\n\n  handlers.add(handlerFunc);\n}; // end NetSubscribe()\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Revokes a handler function from a registered message. The handler function\n * object must be the same one used to register it.\n * @param {string} mesgName message to unregister a handler for\n * @param {function} handlerFunc function originally registered\n */\n\n\nUNET.NetUnsubscribe = (mesgName, handlerFunc) => {\n  if (mesgName === undefined) {\n    m_server_handlers.clear();\n  } else if (handlerFunc === undefined) {\n    m_server_handlers.delete(mesgName);\n  } else {\n    const handlers = m_server_handlers.get(mesgName);\n\n    if (handlers) {\n      handlers.delete(handlerFunc);\n    }\n  }\n\n  return this;\n}; // end NetUnsubscribe()\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Server-side method for invoking a remote message. It executes asynchronously\n * but uses async/await so it can be used in a synchronous style to retrieve\n * values.\n * @param {string} mesgName message to unregister a handler for\n * @param {function} handlerFunc function originally registered\n * @return {Array<Object>} array of returned data items\n */\n\n\nUNET.NetCall = async (mesgName, data) => {\n  let pkt = new NetPacket(mesgName, data);\n  let promises = m_PromiseRemoteHandlers(pkt);\n  if (DBG.call) TOUT(`${pkt.Info()} NETCALL ${pkt.Message()} to ${promises.length} remotes`); /// MAGICAL ASYNC/AWAIT BLOCK ///////\n\n  const results = await Promise.all(promises); /// END MAGICAL ASYNC/AWAIT BLOCK ///\n  // const result = Object.assign({}, ...resArray);\n\n  return results; // array of data objects\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Server-side local server subscription. It's the same as NetSubscribe\n */\n\n\nUNET.LocalSubscribe = UNET.NetSubscribe; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Server-side local server publishing. It executes synchronously, unlike the\n *  remote version. Doesn't return vsalues.\n */\n\nUNET.LocalPublish = (mesgName, data) => {\n  const handlers = m_server_handlers.get(mesgName);\n  if (!handlers) return;\n  const results = [];\n  handlers.forEach(hFunc => {\n    results.push(hFunc(data));\n  });\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Server-side method for sending a remote message. It fires the messages but\n * doesn't do anything with the returned promises. Use for notifying remote\n * message handlers.\n * @param {string} mesgName message to unregister a handler for\n * @param {function} handlerFunc function originally registered\n */\n\n\nUNET.NetPublish = (mesgName, data) => {\n  let pkt = new NetPacket(mesgName, data);\n  let promises = m_PromiseRemoteHandlers(pkt); // we don't care about waiting for the promise to complete\n\n  if (DBG.call) TOUT(`${pkt.Info()} NETSEND ${pkt.Message()} to ${promises.length} remotes`);\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Alias for NetPublish(), kept for conceptual symmetry to the client-side URSYS\n * interface. It is not needed because the server never mirrors NetPublish to\n * itself for signaling purposes.\n * @param {string} mesgName message to unregister a handler for\n * @param {function} handlerFunc function originally registered\n */\n\n\nUNET.NetSignal = (mesgName, data) => {\n  TOUT('NOTE: Use NetPublish(), not NetSignal() since the server doesnt care.');\n  UNET.NetPublish(mesgName, data);\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Return list of registered server handlers\n */\n\n\nUNET.ServiceList = () => {\n  const serviceList = [...m_server_handlers.keys()];\n  return serviceList;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Return list of clients and registered handlers\n */\n\n\nUNET.ClientList = () => {\n  const handlerList = [...m_remote_handlers.entries()];\n  const clientsByMessage = {};\n  handlerList.forEach(entry => {\n    const [msg, set] = entry;\n    const remotes = [...set.keys()];\n    clientsByMessage[msg] = remotes;\n  });\n  return clientsByMessage;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Handles URSYS REGISTRATION PACKETS from connecting clients. It is the first\n * packet sent on successful socket connection.\n * @param {NetPacket} pkt - NetPacket packet instance\n * @return {Object} object with registered property containing array of message\n */\n\n\nUNET.PKT_RegisterRemoteHandlers = pkt => {\n  if (pkt.Message() !== 'NET:SRV_REG_HANDLERS') throw Error('not a registration packet');\n  let uaddr = pkt.SourceAddress();\n  let {\n    messages = []\n  } = pkt.Data(); // make sure there's no sneaky attempt to subvert the system messages\n\n  const filtered = messages.filter(msg => !msg.startsWith('NET:SRV'));\n\n  if (filtered.length !== messages.length) {\n    const error = `${uaddr} blocked from registering SRV message`;\n    TOUT(error);\n    return {\n      error,\n      code: NetPacket.CODE_REG_DENIED\n    };\n  }\n\n  let regd = []; // save message list, for later when having to delete\n\n  m_socket_msgs_list.set(uaddr, messages); // add uaddr for each message in the list\n  // m_remote_handlers[mesg] contains a Set\n\n  messages.forEach(msg => {\n    let entry = m_remote_handlers.get(msg);\n\n    if (!entry) {\n      entry = new Set();\n      m_remote_handlers.set(msg, entry);\n    }\n\n    if (DBG.client) TOUT(`${uaddr} regr '${msg}'`);\n    entry.add(uaddr);\n    regd.push(msg);\n  });\n  return {\n    registered: regd\n  };\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Handle SESSION LOGIN packets. A key is generated based on the provided\n * user token and socket address, and stored in the client socket. This should\n * ensure that keys can not be reused by other socket connections or multiple\n * logins using the same token.\n *\n * @param {NetPacket} pkt - NetPacket packet instance\n * @param {Object} pkt.data - data payload\n * @param {String} pkt.data.token - hashed session info\n * @return {Object} returned data payload\n */\n\n\nUNET.PKT_SessionLogin = pkt => {\n  if (pkt.Message() !== 'NET:SRV_SESSION_LOGIN') throw Error('not a session login packet');\n  const uaddr = pkt.SourceAddress();\n  const sock = m_SocketLookup(uaddr);\n  if (!sock) throw Error(`uaddr '${uaddr}' not associated with a socket`);\n\n  if (sock.USESS) {\n    const error = `socket '${uaddr}' already has a session '${JSON.stringify(sock.USESS)}'`;\n    return {\n      error,\n      code: NetPacket.CODE_SES_RE_REGISTER\n    };\n  }\n\n  const {\n    token\n  } = pkt.Data();\n  if (!token || typeof token !== 'string') return {\n    error: 'must provide token string'\n  };\n  const decoded = SESSION.DecodeToken(token);\n\n  if (!decoded.isValid) {\n    const error = `token '${token}' is not valid`;\n    return {\n      error,\n      code: NetPacket.CODE_SES_INVALID_TOKEN\n    };\n  }\n\n  const key = SESSION.MakeAccessKey(token, uaddr);\n  sock.USESS = decoded;\n  sock.UKEY = key;\n  if (DBG.client) TOUT(`${uaddr} user log-in '${decoded.token}'`);\n  LOGGER.Write(sock.UADDR, 'log-in', decoded.token);\n  return {\n    status: 'logged in',\n    success: true,\n    token,\n    uaddr,\n    key\n  };\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Handle SESSION LOGOUT packets\n *\n * @param {NetPacket} pkt - NetPacket packet instance\n * @param {Object} pkt.data - data payload\n * @param {String} pkt.data.token - hashed session info\n * @return {Object} returned data payload\n */\n\n\nUNET.PKT_SessionLogout = pkt => {\n  if (pkt.Message() !== 'NET:SRV_SESSION_LOGOUT') throw Error('not a session logout packet');\n  const uaddr = pkt.SourceAddress();\n  const sock = m_SocketLookup(uaddr);\n  const {\n    key\n  } = pkt.Data();\n  if (sock.UKEY !== key) return {\n    error: `uaddr '${uaddr}' key '${key}'!=='${sock.UKEY}'`\n  };\n  if (DBG.client) TOUT(`${uaddr} user logout '${sock.USESS.token}'`);\n  if (sock.USESS) LOGGER.Write(sock.UADDR, 'logout', sock.USESS.token);\n  sock.UKEY = undefined;\n  sock.USESS = undefined;\n  return {\n    status: 'logged out',\n    success: true\n  };\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Return a session object based on the passed packet's stored credentials\n */\n\n\nUNET.PKT_Session = pkt => {\n  const uaddr = pkt.SourceAddress();\n  const sock = m_SocketLookup(uaddr);\n\n  if (!sock) {\n    const error = `${uaddr} impossible socket lookup failure`;\n    TOUT(error);\n    return {\n      error,\n      code: NetPacket.CODE_SOC_NOSOCK\n    };\n  }\n\n  const {\n    key\n  } = pkt.Data();\n\n  if (sock.ULOCAL) {\n    if (DBG.client) TOUT(`${uaddr} is localhost so bypass key check`);\n    return {\n      localhost: true\n    };\n  }\n\n  if (!key) {\n    const error = `${uaddr} access key is not set`;\n    if (DBG.client) TOUT(error);\n    return {\n      error,\n      code: NetPacket.CODE_SES_REQUIRE_KEY\n    };\n  }\n\n  const evil_backdoor = SESSION.AdminPlaintextPassphrase();\n\n  if (key === evil_backdoor) {\n    // do some hacky bypassing...yeep\n    if (!sock.USESS) {\n      const warning = `non-localhost admin '${evil_backdoor}' logged-in`;\n      LOGGER.Write(uaddr, warning);\n      TOUT(`${uaddr} WARN ${warning}`);\n      const adminToken = SESSION.MakeToken('Admin', {\n        groupId: 0,\n        classroomId: 0\n      });\n      sock.USESS = SESSION.DecodeToken(adminToken);\n      sock.UKEY = key;\n    }\n  }\n\n  if (!sock.USESS) {\n    const error = `sock.${uaddr} is not logged-in`;\n    if (DBG.client) TOUT(`${uaddr} is not logged-in`);\n    return {\n      error,\n      code: NetPacket.CODE_SES_REQUIRE_LOGIN\n    };\n  }\n\n  if (key !== sock.UKEY) {\n    if (DBG.client) {\n      TOUT(`Session: sock.${uaddr} keys do not match packet '${sock.UKEY}' '${key}'`);\n    }\n\n    const error = `sock.${uaddr} access keys do not match '${sock.UKEY}' '${key}'`;\n    return {\n      error,\n      code: NetPacket.CODE_SES_INVALID_KEY\n    };\n  } // passes all tests, so its good!\n\n\n  return sock.USESS;\n}; /// END OF UNET PUBLIC API ////////////////////////////////////////////////////\n/// MODULE HELPER FUNCTIONS ///////////////////////////////////////////////////\n///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Assigns a unique URSYS address (UADDR) to new sockets, storing it as the\n * UADDR property of the socket and adding to mu_sockets map. The connection is\n * logged to the logfile.\n * @param {Object} socket connecting socket\n * @param {Object} req raw request\n */\n\n\nfunction m_SocketAdd(socket, req) {\n  // save socket by socket_id\n  let sid = m_GetNewUADDR(); // store ursys address\n\n  socket.UADDR = sid; // set ULOCAL flag if socket is local because this is privilleged\n\n  const remoteIp = req && req.connection ? req.connection.remoteAddress : '';\n  socket.ULOCAL = remoteIp === '127.0.0.1' || remoteIp === '::1'; // save socket\n\n  mu_sockets.set(sid, socket);\n  if (DBG.init) TOUT(`socket ADD ${socket.UADDR} to network`);\n  LOGGER.Write(socket.UADDR, 'joined network');\n  if (DBG.init) log_ListSockets(`add ${sid}`);\n} // end m_SocketAdd()\n///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Utility to generate a new UADDR id for connecting clients\n * @param {string} [prefix] - default to UADDR\n */\n\n\nfunction m_GetNewUADDR(prefix = 'UADDR') {\n  ++mu_sid_counter;\n  let cstr = mu_sid_counter.toString(10).padStart(2, '0');\n  return `${prefix}_${cstr}`;\n} ///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Returns a JSON packet to the just-connected client with its assigned URSYS\n * address (UADDR) and the server's UADDR.\n * @param {Object} socket connecting socket\n */\n\n\nfunction m_SocketClientAck(socket) {\n  let PEERS = {\n    count: mu_sockets.size\n  };\n  let data = {\n    HELLO: `Welcome to URSYS, ${socket.UADDR}`,\n    UADDR: socket.UADDR,\n    SERVER_UADDR,\n    PEERS,\n    ULOCAL: socket.ULOCAL\n  };\n  socket.send(JSON.stringify(data));\n} // end m_SocketClientAck()\n///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Main entry point for handling 'message' events from a client socket. It\n * converts the incoming JSON to a NetPacket packet and passes processing\n * further on depending on the type.\n * @param {Object} socket messaging socket\n * @param {string} json text-encoded NetPacket\n */\n\n\nfunction m_SocketOnMessage(socket, json) {\n  let pkt = new NetPacket(json); // figure out what to do\n\n  switch (pkt.Type()) {\n    case 'msig':\n    case 'msend':\n    case 'mcall':\n      m_HandleMessage(socket, pkt);\n      break;\n\n    case 'state':\n      // m_HandleState(socket, pkt);\n      break;\n\n    default:\n      throw new Error(`${TOUT} unknown packet type '${pkt.Type()}'`);\n  } // end switch\n\n} // end m_SocketOnMessage()\n///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Utility to handle disconnected sockets. It does the internal housekeeping\n * and logging, and removes any registered messages that the socket may have\n * had.\n */\n\n\nfunction m_SocketDelete(socket) {\n  let uaddr = socket.UADDR;\n  if (!mu_sockets.has(uaddr)) throw Error(DBG_SOCK_BADCLOSE);\n  if (DBG) TOUT(`socket DEL ${uaddr} from network`);\n  const user = socket.USESS ? socket.USESS.token : '';\n  LOGGER.Write(socket.UADDR, 'left network', user.toUpperCase());\n  mu_sockets.delete(uaddr); // delete socket reference from previously registered handlers\n\n  let rmesgs = m_socket_msgs_list.get(uaddr);\n\n  if (Array.isArray(rmesgs)) {\n    rmesgs.forEach(msg => {\n      let handlers = m_remote_handlers.get(msg);\n      if (DBG) TOUT(`${uaddr} removed handler '${msg}'`);\n      if (handlers) handlers.delete(uaddr);\n    });\n  }\n\n  if (DBG.init) log_ListSockets(`del ${socket.UADDR}`); // tell subscribers socket is gone\n\n  UNET.LocalPublish('SRV_SOCKET_DELETED', {\n    uaddr\n  });\n} // end m_SocketDelete()\n///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Returns the socket associated with a uaddr. The UADDR\n * can be accessed from a NetPacket packet's SourceAddress().\n */\n\n\nfunction m_SocketLookup(uaddr) {\n  return mu_sockets.get(uaddr);\n} ///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** MAIN HANDLER that performs the actual work of dispatching messages on behalf\n * of a client to other remote clients, gathers up all the data, and returns\n * it. There are THREE CASES:\n * 1. The incoming message is returning from a remote caller to remote sender\n * 2. The incoming message is intended for the server\n * 3. the incoming message is from a remote reaching another remote\n * @param {Object} socket messaging socket\n * @param {NetPacket} pkt - NetPacket packet instance\n */\n\n\nasync function m_HandleMessage(socket, pkt) {\n  // (1) Is the incoming message a response to a message that the server sent?\n  // It might have been a duplicate packet ('forwarded') or one the server itself sent.\n  // In either case, the packet will invoke whatever function handler is associated with\n  // it and complete the transaction function. Note that dispatched messages comprise\n  // of the original packet and the forwarded duplicate packet(s) that the server\n  // recombines and returns to the original packet sender\n  if (pkt.IsResponse()) {\n    if (DBG.calls) TOUT(`-- ${pkt.Message()} completing transaction ${pkt.seqlog.join(':')}`);\n    pkt.CompleteTransaction();\n    return;\n  } // (2) If we got this far, it's a new message.\n  // Does the server implement any of the messages? Let's add that to our\n  // list of promises. It will return empty array if there are none.\n\n\n  let promises = m_PromiseServerHandlers(pkt); // (3) If the server doesn't implement any promises, check if there are\n  // any remotes that have registered one.\n\n  if (promises.length === 0) promises = m_PromiseRemoteHandlers(pkt); // (3a) If there were NO HANDLERS defined for the incoming message, then\n  // this is an error. If the message is a CALL, then report an error back to\n  // the originator; other message types don't expect a return value.\n\n  if (promises.length === 0) {\n    const out = `${pkt.SourceAddress()} cannot resolve call '${pkt.Message()}'`;\n    TOUT(out); // return transaction to resolve callee\n\n    pkt.SetData({\n      URserver: `info: ${out}`,\n      error: `message ${pkt.Message()} not found`,\n      code: NetPacket.CODE_NO_MESSAGE\n    });\n    if (pkt.IsType('mcall')) pkt.ReturnTransaction(socket);\n    return;\n  } // (3b) We have at least one promise for remote handlers.\n  // It will either be server calls or remote calls. The server\n  // always takes precedence over remote calls so clients can't\n  // subscribe to critical system messages intended only for\n  // the server!\n  // Print some debugging messages\n\n\n  const DBG_NOSRV = !pkt.IsServerMessage();\n  if (DBG.calls) log_PktDirection(pkt, 'call', promises);\n  if (DBG.calls && DBG_NOSRV) log_PktTransaction(pkt, 'queuing', promises);\n  /* (3c) MAGICAL ASYNC/AWAIT BLOCK ****************************/\n\n  /* pktArray will contain data objects from each resolved */\n\n  /* promise */\n\n  let pktArray = await Promise.all(promises);\n  /* END MAGICAL ASYNC/AWAIT BLOCK *****************************/\n  // (3d) Print some more debugging messages after async\n\n  if (DBG.calls) {\n    if (DBG_NOSRV) log_PktTransaction(pkt, 'resolved');\n    log_PktDirection(pkt, 'rtrn', promises);\n  } // (3e) If the call type doesn't expect return data, we are done!\n\n\n  if (!pkt.IsType('mcall')) return; // (3f) If the call type is 'mcall', and we need to return the original\n  // message packet to the original caller. First merge the data into\n  // one data object...\n\n  let data = pktArray.reduce((d, p) => {\n    let pdata = p instanceof NetPacket ? p.Data() : p;\n    let retval = Object.assign(d, pdata);\n    if (DBG_NOSRV) TOUT(`'${pkt.Message()}' reduce`, JSON.stringify(retval));\n    return retval;\n  }, {}); // (3g) ...then return the combined data using NetPacket.ReturnTransaction()\n  // on the caller's socket, which we have retained through the magic of closures!\n\n  const dbgData = JSON.stringify(data);\n  pkt.SetData(data);\n  if (DBG_NOSRV) TOUT(`'${pkt.Message()}' returning transaction data ${dbgData}`);\n  pkt.ReturnTransaction(socket);\n} // end m_HandleMessage()\n///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** MAIN HANDLER (currently stub) for network-synched state messages, which\n * are not yet implemented in URSYS\n * @param {Object} socket messaging socket\n * @param {NetPacket} pkt a NetPacket object received from socket\n */\n/// function m_HandleState(socket, pkt) {}\n///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** KEY HELPER that returns an array of Promises that call the functions\n * associated with a SERVER-based message handler. Handler functions must return\n * a data object. Unlike the remote version of this function, this executes\n * synchronously because there is no network communication required.\n * @param {NetPacket} pkt a NetPacket object to use as message key\n * @returns {Array<Promise>} promises objects to use with await\n */\n\n\nfunction m_PromiseServerHandlers(pkt) {\n  let mesgName = pkt.Message();\n  const handlers = m_server_handlers.get(mesgName); /// create promises for all registered handlers in the set\n\n  let promises = [];\n  if (!handlers) return promises;\n  handlers.forEach(hFunc => {\n    let p = new Promise((resolve, reject) => {\n      let retval = hFunc(pkt);\n      if (retval === undefined) throw Error(`'${mesgName}' message handler MUST return object or error string`);\n      if (typeof retval !== 'object') reject(retval);else resolve(retval);\n    });\n    promises.push(p);\n  }); // handlers forEach\n\n  return promises;\n} // end m_PromiseServerHandlers()\n///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** KEY HELPER for handling \"forwarded calls\" to remote URSYS devices on behalf\n * of an incoming call that isn't implemented on the server. It works by cloning\n * the original NetPacket packet and sending it to removes via\n * NetPacket.PromiseTransaction(), returning an array of promises that resolve\n * when NetPacket.CompleteTransaction() is invoked on the returned data. Use\n * await Promise.all(promises) to wait.\n * @param {NetPacket} pkt a NetPacket object to use as message key\n * @returns {Array<Promise>} promises objects to use with Promise.all()\n */\n\n\nfunction m_PromiseRemoteHandlers(pkt) {\n  // debugging values\n  let s_uaddr = pkt.SourceAddress(); // logic values\n\n  let mesgName = pkt.Message();\n  let type = pkt.Type();\n  const publishOnly = type === 'msend' || type === 'mcall'; // generate the list of promises\n\n  let promises = []; // disallow NET:SYSTEM published messages from remote clients\n\n  if (!pkt.IsServerOrigin() && mesgName.startsWith('NET:SYSTEM')) return promises; // check for handlers\n\n  let handlers = m_remote_handlers.get(mesgName);\n  if (!handlers) return promises; // if there are handlers to handle, create a NetPacket\n  // clone of this packet and forward it and save the promise\n\n  handlers.forEach(d_uaddr => {\n    const isOrigin = s_uaddr === d_uaddr; // we want to do this only when\n\n    if (publishOnly && isOrigin) {\n      if (DBG.calls) TOUT(`skipping msend|mcall from ${s_uaddr} to ${d_uaddr}`);\n    } else {\n      let d_sock = mu_sockets.get(d_uaddr);\n      if (d_sock === undefined) throw Error(`${ERR_INVALID_DEST} ${d_uaddr}`);\n      let newpkt = new NetPacket(pkt); // clone packet data to new packet\n\n      newpkt.MakeNewID(); // make new packet unique\n\n      newpkt.CopySourceAddress(pkt); // clone original source address\n\n      promises.push(newpkt.PromiseTransaction(d_sock));\n    }\n  }); // handlers.forEach\n\n  return promises;\n} ///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** helper debug output used by m_SocketAdd(), m_SocketDelete() */\n\n\nfunction log_ListSockets(change) {\n  TOUT(`socketlist changed: '${change}'`); // let's use iterators! for..of\n\n  let values = mu_sockets.values();\n  let count = 1;\n\n  for (let socket of values) {\n    TOUT(`  ${count} = ${socket.UADDR}`);\n    count++;\n  }\n} ///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** helper debug output used by m_HandleMessage() */\n\n\nfunction log_PktDirection(pkt, direction, promises) {\n  if (promises.length < 1) return;\n  const ents = promises.length > 1 ? 'handlers' : 'handler';\n  TOUT(`${pkt.Info()} ${direction} '${pkt.Message()}' (${promises.length} ${ents})`);\n} ///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** helper debug output used by m_HandleMessage() */\n\n\nfunction log_PktTransaction(pkt, status, promises) {\n  const src = pkt.SourceAddress();\n\n  if (promises && promises.length) {\n    TOUT(`${src} >> '${pkt.Message()}' ${status} ${promises.length} Promises`);\n  } else {\n    TOUT(`${src} << '${pkt.Message()}' ${status}`);\n  }\n} /// EXPORT MODULE DEFINITION //////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nmodule.exports = UNET;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2VydmVyLXVybmV0LmpzPzNiOTYiXSwibmFtZXMiOlsiSVAiLCJyZXF1aXJlIiwiV1NTIiwiU2VydmVyIiwiTmV0UGFja2V0IiwiTE9HR0VSIiwiU0VTU0lPTiIsIlRPVVQiLCJtYWtlVGVybWluYWxPdXQiLCJEQkciLCJpbml0IiwiY2FsbHMiLCJjbGllbnQiLCJFUlJfU1NfRVhJU1RTIiwiREJHX1NPQ0tfQkFEQ0xPU0UiLCJFUlJfSU5WQUxJRF9ERVNUIiwiREVGQVVMVF9ORVRfUE9SVCIsIlNFUlZFUl9VQUREUiIsIkRlZmF1bHRTZXJ2ZXJVQUREUiIsIlBST1RPQ09MX1ZFUlNJT04iLCJtdV93c3MiLCJtdV9vcHRpb25zIiwibXVfc29ja2V0cyIsIk1hcCIsIm11X3NpZF9jb3VudGVyIiwibV9zZXJ2ZXJfaGFuZGxlcnMiLCJtX3JlbW90ZV9oYW5kbGVycyIsIm1fc29ja2V0X21zZ3NfbGlzdCIsIlVORVQiLCJTdGFydE5ldHdvcmsiLCJvcHRpb25zIiwicnVudGltZVBhdGgiLCJFcnJvciIsIlN0YXJ0TG9nZ2luZyIsImhvc3QiLCJhZGRyZXNzIiwicG9ydCIsInVhZGRyIiwidXJuZXRfdmVyc2lvbiIsInVuZGVmaW5lZCIsIkdsb2JhbFNldHVwIiwib24iLCJzb2NrZXQiLCJyZXEiLCJtX1NvY2tldEFkZCIsIm1fU29ja2V0Q2xpZW50QWNrIiwianNvbiIsIm1fU29ja2V0T25NZXNzYWdlIiwibV9Tb2NrZXREZWxldGUiLCJOZXRTdWJzY3JpYmUiLCJtZXNnTmFtZSIsImhhbmRsZXJGdW5jIiwiaGFuZGxlcnMiLCJnZXQiLCJTZXQiLCJzZXQiLCJhZGQiLCJOZXRVbnN1YnNjcmliZSIsImNsZWFyIiwiZGVsZXRlIiwiTmV0Q2FsbCIsImRhdGEiLCJwa3QiLCJwcm9taXNlcyIsIm1fUHJvbWlzZVJlbW90ZUhhbmRsZXJzIiwiY2FsbCIsIkluZm8iLCJNZXNzYWdlIiwibGVuZ3RoIiwicmVzdWx0cyIsIlByb21pc2UiLCJhbGwiLCJMb2NhbFN1YnNjcmliZSIsIkxvY2FsUHVibGlzaCIsImZvckVhY2giLCJoRnVuYyIsInB1c2giLCJOZXRQdWJsaXNoIiwiTmV0U2lnbmFsIiwiU2VydmljZUxpc3QiLCJzZXJ2aWNlTGlzdCIsImtleXMiLCJDbGllbnRMaXN0IiwiaGFuZGxlckxpc3QiLCJlbnRyaWVzIiwiY2xpZW50c0J5TWVzc2FnZSIsImVudHJ5IiwibXNnIiwicmVtb3RlcyIsIlBLVF9SZWdpc3RlclJlbW90ZUhhbmRsZXJzIiwiU291cmNlQWRkcmVzcyIsIm1lc3NhZ2VzIiwiRGF0YSIsImZpbHRlcmVkIiwiZmlsdGVyIiwic3RhcnRzV2l0aCIsImVycm9yIiwiY29kZSIsIkNPREVfUkVHX0RFTklFRCIsInJlZ2QiLCJyZWdpc3RlcmVkIiwiUEtUX1Nlc3Npb25Mb2dpbiIsInNvY2siLCJtX1NvY2tldExvb2t1cCIsIlVTRVNTIiwiSlNPTiIsInN0cmluZ2lmeSIsIkNPREVfU0VTX1JFX1JFR0lTVEVSIiwidG9rZW4iLCJkZWNvZGVkIiwiRGVjb2RlVG9rZW4iLCJpc1ZhbGlkIiwiQ09ERV9TRVNfSU5WQUxJRF9UT0tFTiIsImtleSIsIk1ha2VBY2Nlc3NLZXkiLCJVS0VZIiwiV3JpdGUiLCJVQUREUiIsInN0YXR1cyIsInN1Y2Nlc3MiLCJQS1RfU2Vzc2lvbkxvZ291dCIsIlBLVF9TZXNzaW9uIiwiQ09ERV9TT0NfTk9TT0NLIiwiVUxPQ0FMIiwibG9jYWxob3N0IiwiQ09ERV9TRVNfUkVRVUlSRV9LRVkiLCJldmlsX2JhY2tkb29yIiwiQWRtaW5QbGFpbnRleHRQYXNzcGhyYXNlIiwid2FybmluZyIsImFkbWluVG9rZW4iLCJNYWtlVG9rZW4iLCJncm91cElkIiwiY2xhc3Nyb29tSWQiLCJDT0RFX1NFU19SRVFVSVJFX0xPR0lOIiwiQ09ERV9TRVNfSU5WQUxJRF9LRVkiLCJzaWQiLCJtX0dldE5ld1VBRERSIiwicmVtb3RlSXAiLCJjb25uZWN0aW9uIiwicmVtb3RlQWRkcmVzcyIsImxvZ19MaXN0U29ja2V0cyIsInByZWZpeCIsImNzdHIiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiUEVFUlMiLCJjb3VudCIsInNpemUiLCJIRUxMTyIsInNlbmQiLCJUeXBlIiwibV9IYW5kbGVNZXNzYWdlIiwiaGFzIiwidXNlciIsInRvVXBwZXJDYXNlIiwicm1lc2dzIiwiQXJyYXkiLCJpc0FycmF5IiwiSXNSZXNwb25zZSIsInNlcWxvZyIsImpvaW4iLCJDb21wbGV0ZVRyYW5zYWN0aW9uIiwibV9Qcm9taXNlU2VydmVySGFuZGxlcnMiLCJvdXQiLCJTZXREYXRhIiwiVVJzZXJ2ZXIiLCJDT0RFX05PX01FU1NBR0UiLCJJc1R5cGUiLCJSZXR1cm5UcmFuc2FjdGlvbiIsIkRCR19OT1NSViIsIklzU2VydmVyTWVzc2FnZSIsImxvZ19Qa3REaXJlY3Rpb24iLCJsb2dfUGt0VHJhbnNhY3Rpb24iLCJwa3RBcnJheSIsInJlZHVjZSIsImQiLCJwIiwicGRhdGEiLCJyZXR2YWwiLCJPYmplY3QiLCJhc3NpZ24iLCJkYmdEYXRhIiwicmVzb2x2ZSIsInJlamVjdCIsInNfdWFkZHIiLCJ0eXBlIiwicHVibGlzaE9ubHkiLCJJc1NlcnZlck9yaWdpbiIsImRfdWFkZHIiLCJpc09yaWdpbiIsImRfc29jayIsIm5ld3BrdCIsIk1ha2VOZXdJRCIsIkNvcHlTb3VyY2VBZGRyZXNzIiwiUHJvbWlzZVRyYW5zYWN0aW9uIiwiY2hhbmdlIiwidmFsdWVzIiwiZGlyZWN0aW9uIiwiZW50cyIsInNyYyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBOztBQUNBOztBQUNBOzs7OztBQU1BO0FBQ0E7QUFDQSxNQUFNQSxFQUFFLEdBQUdDLG1CQUFPLENBQUMsMkNBQUQsQ0FBbEI7O0FBQ0EsTUFBTUMsR0FBRyxHQUFHRCxtQkFBTyxDQUFDLDBDQUFELENBQVAsQ0FBY0UsTUFBMUI7O0FBQ0EsTUFBTUMsU0FBUyxHQUFHSCxtQkFBTyxDQUFDLG1EQUFELENBQXpCOztBQUNBLE1BQU1JLE1BQU0sR0FBR0osbUJBQU8s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QVEsSUFBSUEsUUFBUSxDQUFDSyxNQUF6QixFQUFpQztBQUMvQjdELFFBQUksQ0FBRSxHQUFFZ00sR0FBSSxRQUFPekksR0FBRyxDQUFDSyxPQUFKLEVBQWMsS0FBSW1ELE1BQU8sSUFBR3ZELFFBQVEsQ0FBQ0ssTUFBTyxXQUEzRCxDQUFKO0FBQ0QsR0FGRCxNQUVPO0FBQ0w3RCxRQUFJLENBQUUsR0FBRWdNLEdBQUksUUFBT3pJLEdBQUcsQ0FBQ0ssT0FBSixFQUFjLEtBQUltRCxNQUFPLEVBQXhDLENBQUo7QUFDRDtBQUNGLEMsQ0FFRDtBQUNBOzs7QUFDQWtGLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQjdLLElBQWpCIiwiZmlsZSI6Ii4vc3JjL3NlcnZlci11cm5ldC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZSAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG4vKi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIEFCT1VUIFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCpcXFxuXG4gIFdlYlNvY2tldFNlcnZlciBhbmQgTmV0d29yayBNYW5hZ2VtZW50IGZvciBVUlNZU1xuXG5cXCpcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCAqIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vKi9cblxuLy8vXHRMT0FEIExJQlJBUklFUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vL1x0LSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5jb25zdCBJUCA9IHJlcXVpcmUoJ2lwJyk7XG5jb25zdCBXU1MgPSByZXF1aXJlKCd3cycpLlNlcnZlcjtcbmNvbnN0IE5ldFBhY2tldCA9IHJlcXVpcmUoJy4vY2xhc3MtbmV0cGFja2V0Jyk7XG5jb25zdCBMT0dHRVIgPSByZXF1aXJlKCcuL3NlcnZlci1sb2dnZXInKTtcbmNvbnN0IFNFU1NJT04gPSByZXF1aXJlKCcuL3V0aWwvc2Vzc2lvbicpO1xuY29uc3QgVE9VVCA9IHJlcXVpcmUoJy4vdXRpbC9wcm9tcHRzJykubWFrZVRlcm1pbmFsT3V0KCcgVVJORVQnKTtcblxuLy8vIERFQlVHIE1FU1NBR0VTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuY29uc3QgREJHID0geyBpbml0OiB0cnVlLCBjYWxsczogZmFsc2UsIGNsaWVudDogdHJ1ZSB9O1xuXG5jb25zdCBFUlJfU1NfRVhJU1RTID0gJ3NvY2tldCBzZXJ2ZXIgYWxyZWFkeSBjcmVhdGVkJztcbmNvbnN0IERCR19TT0NLX0JBRENMT1NFID0gJ2Nsb3Npbmcgc29ja2V0IGlzIG5vdCBpbiBtdV9zb2NrZXRzJztcbmNvbnN0IEVSUl9JTlZBTElEX0RFU1QgPSBcImNvdWxkbid0IGZpbmQgc29ja2V0IHdpdGggcHJvdmlkZWQgYWRkcmVzc1wiO1xuXG4vLy8gQ09OU1RBTlRTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy9cdC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuY29uc3QgREVGQVVMVF9ORVRfUE9SVCA9IDI5Mjk7XG5jb25zdCBTRVJWRVJfVUFERFIgPSBOZXRQYWNrZXQuRGVmYXVsdFNlcnZlclVBRERSKCk7IC8vIGlzICdTVlJfMDEnXG5jb25zdCBQUk9UT0NPTF9WRVJTSU9OID0gMztcblxuLy8vIE1PRFVMRS1XSURFIFZBUlMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLy8vIHNvY2tldHNcbmxldCBtdV93c3M7IC8vIHdlYnNvY2tldCBzZXJ2ZXJcbmxldCBtdV9vcHRpb25zOyAvLyB3ZWJzb2NrZXQgb3B0aW9uc1xubGV0IG11X3NvY2tldHMgPSBuZXcgTWFwKCk7IC8vIHNvY2tldHMgbWFwcGVkIGJ5IHNvY2tldCBpZFxubGV0IG11X3NpZF9jb3VudGVyID0gMDsgLy8gZm9yIGdlbmVyYXRpbmcgIHVuaXF1ZSBzb2NrZXQgaWRzXG4vLyBzdG9yYWdlXG5sZXQgbV9zZXJ2ZXJfaGFuZGxlcnMgPSBuZXcgTWFwKCk7IC8vIG1lc3NhZ2UgbWFwIHN0b3Jpbmcgc2V0cyBvZiBmdW5jdGlvbnNcbmxldCBtX3JlbW90ZV9oYW5kbGVycyA9IG5ldyBNYXAoKTsgLy8gbWVzc2FnZSBtYXAgc3RvcmluZyBvdGhlciBoYW5kbGVyc1xubGV0IG1fc29ja2V0X21zZ3NfbGlzdCA9IG5ldyBNYXAoKTsgLy8gbWVzc2FnZSBtYXAgYnkgdWFkZHJcbi8vIG1vZHVsZSBvYmplY3RcbmxldCBVTkVUID0ge307XG5cbi8vLyBBUEkgTUVUSE9EUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBJbml0aWFsaXplcyB0aGUgd2ViIHNvY2tldCBzZXJ2ZXIgdXNpbmcgdGhlIG9wdGlvbnMgc2V0IGJ5XG4gKiAgSW5pdGlhbGl6ZU5ldHdvcmsoKSwgYW5kIGRpcmVjdHMgY29ubmVjdGlvbnMgdG8gdXRpbGl0eSBmdW5jdGlvblxuICogIG1fTmV3U29ja2V0Q29ubmVjdGVkKClcbiAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gY29uZmlndXJhdGlvbiBzZXR0aW5nc1xuICogIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5wb3J0XSAtIGRlZmF1bHQgdG8gREVGQVVMVF9ORVRfUE9SVCAyOTI5XG4gKiAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnVhZGRyXSAtIGRlZmF1bHQgdG8gRGVmYXVsdFNlcnZlclVBRERSKCkgJ1NWUl8wMSdcbiAqICBAcmV0dXJucyB7T2JqZWN0fSBjb21wbGV0ZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICovXG5VTkVULlN0YXJ0TmV0d29yayA9IChvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKCFvcHRpb25zLnJ1bnRpbWVQYXRoKSB7XG4gICAgcmV0dXJuIEVycm9yKCdydW50aW1lUGF0aCByZXF1aXJlZCB0byBzdGFydCBVUlNZUyBTRVJWRVInKTtcbiAgfVxuICBMT0dHRVIuU3RhcnRMb2dnaW5nKG9wdGlvbnMpO1xuICAvLyBXU1Mgb3B0aW9uc1xuICBvcHRpb25zLmhvc3QgPSBJUC5hZGRyZXNzKCk7XG4gIG9wdGlvbnMucG9ydCA9IG9wdGlvbnMucG9ydCB8fCBERUZBVUxUX05FVF9QT1JUO1xuICAvLyBVUk5FVCBvcHRpb25zXG4gIG9wdGlvbnMudWFkZHIgPSBvcHRpb25zLnVhZGRyIHx8IFNFUlZFUl9VQUREUjtcbiAgb3B0aW9ucy51cm5ldF92ZXJzaW9uID0gUFJPVE9DT0xfVkVSU0lPTjtcbiAgaWYgKG11X3dzcyAhPT0gdW5kZWZpbmVkKSB0aHJvdyBFcnJvcihFUlJfU1NfRVhJU1RTKTtcbiAgTmV0UGFja2V0Lkdsb2JhbFNldHVwKHsgdWFkZHI6IG9wdGlvbnMudWFkZHIgfSk7XG4gIG11X29wdGlvbnMgPSBvcHRpb25zO1xuXG4gIC8vIGNyZWF0ZSBsaXN0ZW5lci5cbiAgbXVfd3NzID0gbmV3IFdTUyhtdV9vcHRpb25zKTtcbiAgbXVfd3NzLm9uKCdsaXN0ZW5pbmcnLCAoKSA9PiB7XG4gICAgaWYgKERCRy5pbml0KSBUT1VUKGBzb2NrZXQgc2VydmVyIGxpc3RlbmluZyBvbiBwb3J0ICR7bXVfb3B0aW9ucy5wb3J0fWApO1xuICAgIG11X3dzcy5vbignY29ubmVjdGlvbicsIChzb2NrZXQsIHJlcSkgPT4ge1xuICAgICAgLy8gaWYgKERCRykgVE9VVCgnc29ja2V0IGNvbm5lY3RlZCcpO1xuICAgICAgLy8gaG91c2Uga2VlcGluZ1xuICAgICAgbV9Tb2NrZXRBZGQoc29ja2V0LCByZXEpOyAvLyBhc3NpZ24gVUFERFIgdG8gc29ja2V0XG4gICAgICBtX1NvY2tldENsaWVudEFjayhzb2NrZXQpOyAvLyB0ZWxsIGNsaWVudCBIRUxMTyB3aXRoIG5ldyBVQUREUlxuICAgICAgLy8gc3Vic2NyaWJlIHNvY2tldCB0byBoYW5kbGVyc1xuICAgICAgc29ja2V0Lm9uKCdtZXNzYWdlJywganNvbiA9PiBtX1NvY2tldE9uTWVzc2FnZShzb2NrZXQsIGpzb24pKTtcbiAgICAgIHNvY2tldC5vbignY2xvc2UnLCAoKSA9PiBtX1NvY2tldERlbGV0ZShzb2NrZXQpKTtcbiAgICB9KTsgLy8gZW5kIG9uICdjb25uZWN0aW9uJ1xuICB9KTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59OyAvLyBlbmQgU3RhcnROZXR3b3JrKClcblxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIFJlZ2lzdGVycyBTRVJWRVItc2lkZSBtZXNzYWdlIGhhbmRsZXJzIHRoYXQgYXJlIHJlYWNoYWJsZSBmcm9tIHJlbW90ZVxuICogY2xpZW50cy4gU2VydmVyLXNpZGUgaGFuZGxlcnMgdXNlIHRoZWlyIG93biBtYXAuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzZ05hbWUgbWVzc2FnZSB0byByZWdpc3RlciBhIGhhbmRsZXIgZm9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyRnVuYyBmdW5jdGlvbiByZWNlaXZpbmcgJ2RhdGEnIG9iamVjdFxuICovXG5VTkVULk5ldFN1YnNjcmliZSA9IChtZXNnTmFtZSwgaGFuZGxlckZ1bmMpID0+IHtcbiAgaWYgKHR5cGVvZiBoYW5kbGVyRnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIFRPVVQoYCR7bWVzZ05hbWV9IHN1YnNjcmlwdGlvbiBmYWlsdXJlYCk7XG4gICAgdGhyb3cgRXJyb3IoJ2FyZzIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgbGV0IGhhbmRsZXJzID0gbV9zZXJ2ZXJfaGFuZGxlcnMuZ2V0KG1lc2dOYW1lKTtcbiAgaWYgKCFoYW5kbGVycykge1xuICAgIGhhbmRsZXJzID0gbmV3IFNldCgpO1xuICAgIG1fc2VydmVyX2hhbmRsZXJzLnNldChtZXNnTmFtZSwgaGFuZGxlcnMpO1xuICB9XG4gIGhhbmRsZXJzLmFkZChoYW5kbGVyRnVuYyk7XG59OyAvLyBlbmQgTmV0U3Vic2NyaWJlKClcbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBSZXZva2VzIGEgaGFuZGxlciBmdW5jdGlvbiBmcm9tIGEgcmVnaXN0ZXJlZCBtZXNzYWdlLiBUaGUgaGFuZGxlciBmdW5jdGlvblxuICogb2JqZWN0IG11c3QgYmUgdGhlIHNhbWUgb25lIHVzZWQgdG8gcmVnaXN0ZXIgaXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzZ05hbWUgbWVzc2FnZSB0byB1bnJlZ2lzdGVyIGEgaGFuZGxlciBmb3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXJGdW5jIGZ1bmN0aW9uIG9yaWdpbmFsbHkgcmVnaXN0ZXJlZFxuICovXG5VTkVULk5ldFVuc3Vic2NyaWJlID0gKG1lc2dOYW1lLCBoYW5kbGVyRnVuYykgPT4ge1xuICBpZiAobWVzZ05hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIG1fc2VydmVyX2hhbmRsZXJzLmNsZWFyKCk7XG4gIH0gZWxzZSBpZiAoaGFuZGxlckZ1bmMgPT09IHVuZGVmaW5lZCkge1xuICAgIG1fc2VydmVyX2hhbmRsZXJzLmRlbGV0ZShtZXNnTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaGFuZGxlcnMgPSBtX3NlcnZlcl9oYW5kbGVycy5nZXQobWVzZ05hbWUpO1xuICAgIGlmIChoYW5kbGVycykge1xuICAgICAgaGFuZGxlcnMuZGVsZXRlKGhhbmRsZXJGdW5jKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBlbmQgTmV0VW5zdWJzY3JpYmUoKVxuXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogU2VydmVyLXNpZGUgbWV0aG9kIGZvciBpbnZva2luZyBhIHJlbW90ZSBtZXNzYWdlLiBJdCBleGVjdXRlcyBhc3luY2hyb25vdXNseVxuICogYnV0IHVzZXMgYXN5bmMvYXdhaXQgc28gaXQgY2FuIGJlIHVzZWQgaW4gYSBzeW5jaHJvbm91cyBzdHlsZSB0byByZXRyaWV2ZVxuICogdmFsdWVzLlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc2dOYW1lIG1lc3NhZ2UgdG8gdW5yZWdpc3RlciBhIGhhbmRsZXIgZm9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyRnVuYyBmdW5jdGlvbiBvcmlnaW5hbGx5IHJlZ2lzdGVyZWRcbiAqIEByZXR1cm4ge0FycmF5PE9iamVjdD59IGFycmF5IG9mIHJldHVybmVkIGRhdGEgaXRlbXNcbiAqL1xuVU5FVC5OZXRDYWxsID0gYXN5bmMgKG1lc2dOYW1lLCBkYXRhKSA9PiB7XG4gIGxldCBwa3QgPSBuZXcgTmV0UGFja2V0KG1lc2dOYW1lLCBkYXRhKTtcbiAgbGV0IHByb21pc2VzID0gbV9Qcm9taXNlUmVtb3RlSGFuZGxlcnMocGt0KTtcbiAgaWYgKERCRy5jYWxsKVxuICAgIFRPVVQoYCR7cGt0LkluZm8oKX0gTkVUQ0FMTCAke3BrdC5NZXNzYWdlKCl9IHRvICR7cHJvbWlzZXMubGVuZ3RofSByZW1vdGVzYCk7XG4gIC8vLyBNQUdJQ0FMIEFTWU5DL0FXQUlUIEJMT0NLIC8vLy8vLy9cbiAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgLy8vIEVORCBNQUdJQ0FMIEFTWU5DL0FXQUlUIEJMT0NLIC8vL1xuICAvLyBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5yZXNBcnJheSk7XG4gIHJldHVybiByZXN1bHRzOyAvLyBhcnJheSBvZiBkYXRhIG9iamVjdHNcbn07XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogU2VydmVyLXNpZGUgbG9jYWwgc2VydmVyIHN1YnNjcmlwdGlvbi4gSXQncyB0aGUgc2FtZSBhcyBOZXRTdWJzY3JpYmVcbiAqL1xuVU5FVC5Mb2NhbFN1YnNjcmliZSA9IFVORVQuTmV0U3Vic2NyaWJlO1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIFNlcnZlci1zaWRlIGxvY2FsIHNlcnZlciBwdWJsaXNoaW5nLiBJdCBleGVjdXRlcyBzeW5jaHJvbm91c2x5LCB1bmxpa2UgdGhlXG4gKiAgcmVtb3RlIHZlcnNpb24uIERvZXNuJ3QgcmV0dXJuIHZzYWx1ZXMuXG4gKi9cblVORVQuTG9jYWxQdWJsaXNoID0gKG1lc2dOYW1lLCBkYXRhKSA9PiB7XG4gIGNvbnN0IGhhbmRsZXJzID0gbV9zZXJ2ZXJfaGFuZGxlcnMuZ2V0KG1lc2dOYW1lKTtcbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuO1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGhhbmRsZXJzLmZvckVhY2goaEZ1bmMgPT4ge1xuICAgIHJlc3VsdHMucHVzaChoRnVuYyhkYXRhKSk7XG4gIH0pO1xufTtcbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBTZXJ2ZXItc2lkZSBtZXRob2QgZm9yIHNlbmRpbmcgYSByZW1vdGUgbWVzc2FnZS4gSXQgZmlyZXMgdGhlIG1lc3NhZ2VzIGJ1dFxuICogZG9lc24ndCBkbyBhbnl0aGluZyB3aXRoIHRoZSByZXR1cm5lZCBwcm9taXNlcy4gVXNlIGZvciBub3RpZnlpbmcgcmVtb3RlXG4gKiBtZXNzYWdlIGhhbmRsZXJzLlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc2dOYW1lIG1lc3NhZ2UgdG8gdW5yZWdpc3RlciBhIGhhbmRsZXIgZm9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyRnVuYyBmdW5jdGlvbiBvcmlnaW5hbGx5IHJlZ2lzdGVyZWRcbiAqL1xuVU5FVC5OZXRQdWJsaXNoID0gKG1lc2dOYW1lLCBkYXRhKSA9PiB7XG4gIGxldCBwa3QgPSBuZXcgTmV0UGFja2V0KG1lc2dOYW1lLCBkYXRhKTtcbiAgbGV0IHByb21pc2VzID0gbV9Qcm9taXNlUmVtb3RlSGFuZGxlcnMocGt0KTtcbiAgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCB3YWl0aW5nIGZvciB0aGUgcHJvbWlzZSB0byBjb21wbGV0ZVxuICBpZiAoREJHLmNhbGwpXG4gICAgVE9VVChgJHtwa3QuSW5mbygpfSBORVRTRU5EICR7cGt0Lk1lc3NhZ2UoKX0gdG8gJHtwcm9taXNlcy5sZW5ndGh9IHJlbW90ZXNgKTtcbn07XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogQWxpYXMgZm9yIE5ldFB1Ymxpc2goKSwga2VwdCBmb3IgY29uY2VwdHVhbCBzeW1tZXRyeSB0byB0aGUgY2xpZW50LXNpZGUgVVJTWVNcbiAqIGludGVyZmFjZS4gSXQgaXMgbm90IG5lZWRlZCBiZWNhdXNlIHRoZSBzZXJ2ZXIgbmV2ZXIgbWlycm9ycyBOZXRQdWJsaXNoIHRvXG4gKiBpdHNlbGYgZm9yIHNpZ25hbGluZyBwdXJwb3Nlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNnTmFtZSBtZXNzYWdlIHRvIHVucmVnaXN0ZXIgYSBoYW5kbGVyIGZvclxuICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlckZ1bmMgZnVuY3Rpb24gb3JpZ2luYWxseSByZWdpc3RlcmVkXG4gKi9cblVORVQuTmV0U2lnbmFsID0gKG1lc2dOYW1lLCBkYXRhKSA9PiB7XG4gIFRPVVQoJ05PVEU6IFVzZSBOZXRQdWJsaXNoKCksIG5vdCBOZXRTaWduYWwoKSBzaW5jZSB0aGUgc2VydmVyIGRvZXNudCBjYXJlLicpO1xuICBVTkVULk5ldFB1Ymxpc2gobWVzZ05hbWUsIGRhdGEpO1xufTtcbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBSZXR1cm4gbGlzdCBvZiByZWdpc3RlcmVkIHNlcnZlciBoYW5kbGVyc1xuICovXG5VTkVULlNlcnZpY2VMaXN0ID0gKCkgPT4ge1xuICBjb25zdCBzZXJ2aWNlTGlzdCA9IFsuLi5tX3NlcnZlcl9oYW5kbGVycy5rZXlzKCldO1xuICByZXR1cm4gc2VydmljZUxpc3Q7XG59O1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIFJldHVybiBsaXN0IG9mIGNsaWVudHMgYW5kIHJlZ2lzdGVyZWQgaGFuZGxlcnNcbiAqL1xuVU5FVC5DbGllbnRMaXN0ID0gKCkgPT4ge1xuICBjb25zdCBoYW5kbGVyTGlzdCA9IFsuLi5tX3JlbW90ZV9oYW5kbGVycy5lbnRyaWVzKCldO1xuICBjb25zdCBjbGllbnRzQnlNZXNzYWdlID0ge307XG4gIGhhbmRsZXJMaXN0LmZvckVhY2goZW50cnkgPT4ge1xuICAgIGNvbnN0IFttc2csIHNldF0gPSBlbnRyeTtcbiAgICBjb25zdCByZW1vdGVzID0gWy4uLnNldC5rZXlzKCldO1xuICAgIGNsaWVudHNCeU1lc3NhZ2VbbXNnXSA9IHJlbW90ZXM7XG4gIH0pO1xuICByZXR1cm4gY2xpZW50c0J5TWVzc2FnZTtcbn07XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogSGFuZGxlcyBVUlNZUyBSRUdJU1RSQVRJT04gUEFDS0VUUyBmcm9tIGNvbm5lY3RpbmcgY2xpZW50cy4gSXQgaXMgdGhlIGZpcnN0XG4gKiBwYWNrZXQgc2VudCBvbiBzdWNjZXNzZnVsIHNvY2tldCBjb25uZWN0aW9uLlxuICogQHBhcmFtIHtOZXRQYWNrZXR9IHBrdCAtIE5ldFBhY2tldCBwYWNrZXQgaW5zdGFuY2VcbiAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggcmVnaXN0ZXJlZCBwcm9wZXJ0eSBjb250YWluaW5nIGFycmF5IG9mIG1lc3NhZ2VcbiAqL1xuVU5FVC5QS1RfUmVnaXN0ZXJSZW1vdGVIYW5kbGVycyA9IHBrdCA9PiB7XG4gIGlmIChwa3QuTWVzc2FnZSgpICE9PSAnTkVUOlNSVl9SRUdfSEFORExFUlMnKVxuICAgIHRocm93IEVycm9yKCdub3QgYSByZWdpc3RyYXRpb24gcGFja2V0Jyk7XG4gIGxldCB1YWRkciA9IHBrdC5Tb3VyY2VBZGRyZXNzKCk7XG4gIGxldCB7IG1lc3NhZ2VzID0gW10gfSA9IHBrdC5EYXRhKCk7XG4gIC8vIG1ha2Ugc3VyZSB0aGVyZSdzIG5vIHNuZWFreSBhdHRlbXB0IHRvIHN1YnZlcnQgdGhlIHN5c3RlbSBtZXNzYWdlc1xuICBjb25zdCBmaWx0ZXJlZCA9IG1lc3NhZ2VzLmZpbHRlcihtc2cgPT4gIW1zZy5zdGFydHNXaXRoKCdORVQ6U1JWJykpO1xuICBpZiAoZmlsdGVyZWQubGVuZ3RoICE9PSBtZXNzYWdlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBlcnJvciA9IGAke3VhZGRyfSBibG9ja2VkIGZyb20gcmVnaXN0ZXJpbmcgU1JWIG1lc3NhZ2VgO1xuICAgIFRPVVQoZXJyb3IpO1xuICAgIHJldHVybiB7IGVycm9yLCBjb2RlOiBOZXRQYWNrZXQuQ09ERV9SRUdfREVOSUVEIH07XG4gIH1cbiAgbGV0IHJlZ2QgPSBbXTtcbiAgLy8gc2F2ZSBtZXNzYWdlIGxpc3QsIGZvciBsYXRlciB3aGVuIGhhdmluZyB0byBkZWxldGVcbiAgbV9zb2NrZXRfbXNnc19saXN0LnNldCh1YWRkciwgbWVzc2FnZXMpO1xuICAvLyBhZGQgdWFkZHIgZm9yIGVhY2ggbWVzc2FnZSBpbiB0aGUgbGlzdFxuICAvLyBtX3JlbW90ZV9oYW5kbGVyc1ttZXNnXSBjb250YWlucyBhIFNldFxuICBtZXNzYWdlcy5mb3JFYWNoKG1zZyA9PiB7XG4gICAgbGV0IGVudHJ5ID0gbV9yZW1vdGVfaGFuZGxlcnMuZ2V0KG1zZyk7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgZW50cnkgPSBuZXcgU2V0KCk7XG4gICAgICBtX3JlbW90ZV9oYW5kbGVycy5zZXQobXNnLCBlbnRyeSk7XG4gICAgfVxuICAgIGlmIChEQkcuY2xpZW50KSBUT1VUKGAke3VhZGRyfSByZWdyICcke21zZ30nYCk7XG4gICAgZW50cnkuYWRkKHVhZGRyKTtcbiAgICByZWdkLnB1c2gobXNnKTtcbiAgfSk7XG4gIHJldHVybiB7IHJlZ2lzdGVyZWQ6IHJlZ2QgfTtcbn07XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogSGFuZGxlIFNFU1NJT04gTE9HSU4gcGFja2V0cy4gQSBrZXkgaXMgZ2VuZXJhdGVkIGJhc2VkIG9uIHRoZSBwcm92aWRlZFxuICogdXNlciB0b2tlbiBhbmQgc29ja2V0IGFkZHJlc3MsIGFuZCBzdG9yZWQgaW4gdGhlIGNsaWVudCBzb2NrZXQuIFRoaXMgc2hvdWxkXG4gKiBlbnN1cmUgdGhhdCBrZXlzIGNhbiBub3QgYmUgcmV1c2VkIGJ5IG90aGVyIHNvY2tldCBjb25uZWN0aW9ucyBvciBtdWx0aXBsZVxuICogbG9naW5zIHVzaW5nIHRoZSBzYW1lIHRva2VuLlxuICpcbiAqIEBwYXJhbSB7TmV0UGFja2V0fSBwa3QgLSBOZXRQYWNrZXQgcGFja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gcGt0LmRhdGEgLSBkYXRhIHBheWxvYWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBwa3QuZGF0YS50b2tlbiAtIGhhc2hlZCBzZXNzaW9uIGluZm9cbiAqIEByZXR1cm4ge09iamVjdH0gcmV0dXJuZWQgZGF0YSBwYXlsb2FkXG4gKi9cblVORVQuUEtUX1Nlc3Npb25Mb2dpbiA9IHBrdCA9PiB7XG4gIGlmIChwa3QuTWVzc2FnZSgpICE9PSAnTkVUOlNSVl9TRVNTSU9OX0xPR0lOJylcbiAgICB0aHJvdyBFcnJvcignbm90IGEgc2Vzc2lvbiBsb2dpbiBwYWNrZXQnKTtcbiAgY29uc3QgdWFkZHIgPSBwa3QuU291cmNlQWRkcmVzcygpO1xuICBjb25zdCBzb2NrID0gbV9Tb2NrZXRMb29rdXAodWFkZHIpO1xuICBpZiAoIXNvY2spIHRocm93IEVycm9yKGB1YWRkciAnJHt1YWRkcn0nIG5vdCBhc3NvY2lhdGVkIHdpdGggYSBzb2NrZXRgKTtcbiAgaWYgKHNvY2suVVNFU1MpIHtcbiAgICBjb25zdCBlcnJvciA9IGBzb2NrZXQgJyR7dWFkZHJ9JyBhbHJlYWR5IGhhcyBhIHNlc3Npb24gJyR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICBzb2NrLlVTRVNTXG4gICAgKX0nYDtcbiAgICByZXR1cm4geyBlcnJvciwgY29kZTogTmV0UGFja2V0LkNPREVfU0VTX1JFX1JFR0lTVEVSIH07XG4gIH1cbiAgY29uc3QgeyB0b2tlbiB9ID0gcGt0LkRhdGEoKTtcbiAgaWYgKCF0b2tlbiB8fCB0eXBlb2YgdG9rZW4gIT09ICdzdHJpbmcnKVxuICAgIHJldHVybiB7IGVycm9yOiAnbXVzdCBwcm92aWRlIHRva2VuIHN0cmluZycgfTtcbiAgY29uc3QgZGVjb2RlZCA9IFNFU1NJT04uRGVjb2RlVG9rZW4odG9rZW4pO1xuICBpZiAoIWRlY29kZWQuaXNWYWxpZCkge1xuICAgIGNvbnN0IGVycm9yID0gYHRva2VuICcke3Rva2VufScgaXMgbm90IHZhbGlkYDtcbiAgICByZXR1cm4geyBlcnJvciwgY29kZTogTmV0UGFja2V0LkNPREVfU0VTX0lOVkFMSURfVE9LRU4gfTtcbiAgfVxuICBjb25zdCBrZXkgPSBTRVNTSU9OLk1ha2VBY2Nlc3NLZXkodG9rZW4sIHVhZGRyKTtcbiAgc29jay5VU0VTUyA9IGRlY29kZWQ7XG4gIHNvY2suVUtFWSA9IGtleTtcbiAgaWYgKERCRy5jbGllbnQpIFRPVVQoYCR7dWFkZHJ9IHVzZXIgbG9nLWluICcke2RlY29kZWQudG9rZW59J2ApO1xuICBMT0dHRVIuV3JpdGUoc29jay5VQUREUiwgJ2xvZy1pbicsIGRlY29kZWQudG9rZW4pO1xuICByZXR1cm4geyBzdGF0dXM6ICdsb2dnZWQgaW4nLCBzdWNjZXNzOiB0cnVlLCB0b2tlbiwgdWFkZHIsIGtleSB9O1xufTtcblxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIEhhbmRsZSBTRVNTSU9OIExPR09VVCBwYWNrZXRzXG4gKlxuICogQHBhcmFtIHtOZXRQYWNrZXR9IHBrdCAtIE5ldFBhY2tldCBwYWNrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBwa3QuZGF0YSAtIGRhdGEgcGF5bG9hZFxuICogQHBhcmFtIHtTdHJpbmd9IHBrdC5kYXRhLnRva2VuIC0gaGFzaGVkIHNlc3Npb24gaW5mb1xuICogQHJldHVybiB7T2JqZWN0fSByZXR1cm5lZCBkYXRhIHBheWxvYWRcbiAqL1xuVU5FVC5QS1RfU2Vzc2lvbkxvZ291dCA9IHBrdCA9PiB7XG4gIGlmIChwa3QuTWVzc2FnZSgpICE9PSAnTkVUOlNSVl9TRVNTSU9OX0xPR09VVCcpXG4gICAgdGhyb3cgRXJyb3IoJ25vdCBhIHNlc3Npb24gbG9nb3V0IHBhY2tldCcpO1xuICBjb25zdCB1YWRkciA9IHBrdC5Tb3VyY2VBZGRyZXNzKCk7XG4gIGNvbnN0IHNvY2sgPSBtX1NvY2tldExvb2t1cCh1YWRkcik7XG4gIGNvbnN0IHsga2V5IH0gPSBwa3QuRGF0YSgpO1xuICBpZiAoc29jay5VS0VZICE9PSBrZXkpXG4gICAgcmV0dXJuIHsgZXJyb3I6IGB1YWRkciAnJHt1YWRkcn0nIGtleSAnJHtrZXl9JyE9PScke3NvY2suVUtFWX0nYCB9O1xuICBpZiAoREJHLmNsaWVudCkgVE9VVChgJHt1YWRkcn0gdXNlciBsb2dvdXQgJyR7c29jay5VU0VTUy50b2tlbn0nYCk7XG4gIGlmIChzb2NrLlVTRVNTKSBMT0dHRVIuV3JpdGUoc29jay5VQUREUiwgJ2xvZ291dCcsIHNvY2suVVNFU1MudG9rZW4pO1xuICBzb2NrLlVLRVkgPSB1bmRlZmluZWQ7XG4gIHNvY2suVVNFU1MgPSB1bmRlZmluZWQ7XG4gIHJldHVybiB7IHN0YXR1czogJ2xvZ2dlZCBvdXQnLCBzdWNjZXNzOiB0cnVlIH07XG59O1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIFJldHVybiBhIHNlc3Npb24gb2JqZWN0IGJhc2VkIG9uIHRoZSBwYXNzZWQgcGFja2V0J3Mgc3RvcmVkIGNyZWRlbnRpYWxzXG4gKi9cblVORVQuUEtUX1Nlc3Npb24gPSBwa3QgPT4ge1xuICBjb25zdCB1YWRkciA9IHBrdC5Tb3VyY2VBZGRyZXNzKCk7XG4gIGNvbnN0IHNvY2sgPSBtX1NvY2tldExvb2t1cCh1YWRkcik7XG4gIGlmICghc29jaykge1xuICAgIGNvbnN0IGVycm9yID0gYCR7dWFkZHJ9IGltcG9zc2libGUgc29ja2V0IGxvb2t1cCBmYWlsdXJlYDtcbiAgICBUT1VUKGVycm9yKTtcbiAgICByZXR1cm4geyBlcnJvciwgY29kZTogTmV0UGFja2V0LkNPREVfU09DX05PU09DSyB9O1xuICB9XG4gIGNvbnN0IHsga2V5IH0gPSBwa3QuRGF0YSgpO1xuICBpZiAoc29jay5VTE9DQUwpIHtcbiAgICBpZiAoREJHLmNsaWVudCkgVE9VVChgJHt1YWRkcn0gaXMgbG9jYWxob3N0IHNvIGJ5cGFzcyBrZXkgY2hlY2tgKTtcbiAgICByZXR1cm4geyBsb2NhbGhvc3Q6IHRydWUgfTtcbiAgfVxuICBpZiAoIWtleSkge1xuICAgIGNvbnN0IGVycm9yID0gYCR7dWFkZHJ9IGFjY2VzcyBrZXkgaXMgbm90IHNldGA7XG4gICAgaWYgKERCRy5jbGllbnQpIFRPVVQoZXJyb3IpO1xuICAgIHJldHVybiB7IGVycm9yLCBjb2RlOiBOZXRQYWNrZXQuQ09ERV9TRVNfUkVRVUlSRV9LRVkgfTtcbiAgfVxuICBjb25zdCBldmlsX2JhY2tkb29yID0gU0VTU0lPTi5BZG1pblBsYWludGV4dFBhc3NwaHJhc2UoKTtcbiAgaWYgKGtleSA9PT0gZXZpbF9iYWNrZG9vcikge1xuICAgIC8vIGRvIHNvbWUgaGFja3kgYnlwYXNzaW5nLi4ueWVlcFxuICAgIGlmICghc29jay5VU0VTUykge1xuICAgICAgY29uc3Qgd2FybmluZyA9IGBub24tbG9jYWxob3N0IGFkbWluICcke2V2aWxfYmFja2Rvb3J9JyBsb2dnZWQtaW5gO1xuICAgICAgTE9HR0VSLldyaXRlKHVhZGRyLCB3YXJuaW5nKTtcbiAgICAgIFRPVVQoYCR7dWFkZHJ9IFdBUk4gJHt3YXJuaW5nfWApO1xuICAgICAgY29uc3QgYWRtaW5Ub2tlbiA9IFNFU1NJT04uTWFrZVRva2VuKCdBZG1pbicsIHtcbiAgICAgICAgZ3JvdXBJZDogMCxcbiAgICAgICAgY2xhc3Nyb29tSWQ6IDBcbiAgICAgIH0pO1xuICAgICAgc29jay5VU0VTUyA9IFNFU1NJT04uRGVjb2RlVG9rZW4oYWRtaW5Ub2tlbik7XG4gICAgICBzb2NrLlVLRVkgPSBrZXk7XG4gICAgfVxuICB9XG4gIGlmICghc29jay5VU0VTUykge1xuICAgIGNvbnN0IGVycm9yID0gYHNvY2suJHt1YWRkcn0gaXMgbm90IGxvZ2dlZC1pbmA7XG4gICAgaWYgKERCRy5jbGllbnQpIFRPVVQoYCR7dWFkZHJ9IGlzIG5vdCBsb2dnZWQtaW5gKTtcbiAgICByZXR1cm4geyBlcnJvciwgY29kZTogTmV0UGFja2V0LkNPREVfU0VTX1JFUVVJUkVfTE9HSU4gfTtcbiAgfVxuICBpZiAoa2V5ICE9PSBzb2NrLlVLRVkpIHtcbiAgICBpZiAoREJHLmNsaWVudCkge1xuICAgICAgVE9VVChcbiAgICAgICAgYFNlc3Npb246IHNvY2suJHt1YWRkcn0ga2V5cyBkbyBub3QgbWF0Y2ggcGFja2V0ICcke3NvY2suVUtFWX0nICcke2tleX0nYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBgc29jay4ke3VhZGRyfSBhY2Nlc3Mga2V5cyBkbyBub3QgbWF0Y2ggJyR7c29jay5VS0VZfScgJyR7a2V5fSdgO1xuICAgIHJldHVybiB7IGVycm9yLCBjb2RlOiBOZXRQYWNrZXQuQ09ERV9TRVNfSU5WQUxJRF9LRVkgfTtcbiAgfVxuICAvLyBwYXNzZXMgYWxsIHRlc3RzLCBzbyBpdHMgZ29vZCFcbiAgcmV0dXJuIHNvY2suVVNFU1M7XG59O1xuXG4vLy8gRU5EIE9GIFVORVQgUFVCTElDIEFQSSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vLyBNT0RVTEUgSEVMUEVSIEZVTkNUSU9OUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vL1x0LSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogQXNzaWducyBhIHVuaXF1ZSBVUlNZUyBhZGRyZXNzIChVQUREUikgdG8gbmV3IHNvY2tldHMsIHN0b3JpbmcgaXQgYXMgdGhlXG4gKiBVQUREUiBwcm9wZXJ0eSBvZiB0aGUgc29ja2V0IGFuZCBhZGRpbmcgdG8gbXVfc29ja2V0cyBtYXAuIFRoZSBjb25uZWN0aW9uIGlzXG4gKiBsb2dnZWQgdG8gdGhlIGxvZ2ZpbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gc29ja2V0IGNvbm5lY3Rpbmcgc29ja2V0XG4gKiBAcGFyYW0ge09iamVjdH0gcmVxIHJhdyByZXF1ZXN0XG4gKi9cbmZ1bmN0aW9uIG1fU29ja2V0QWRkKHNvY2tldCwgcmVxKSB7XG4gIC8vIHNhdmUgc29ja2V0IGJ5IHNvY2tldF9pZFxuICBsZXQgc2lkID0gbV9HZXROZXdVQUREUigpO1xuICAvLyBzdG9yZSB1cnN5cyBhZGRyZXNzXG4gIHNvY2tldC5VQUREUiA9IHNpZDtcbiAgLy8gc2V0IFVMT0NBTCBmbGFnIGlmIHNvY2tldCBpcyBsb2NhbCBiZWNhdXNlIHRoaXMgaXMgcHJpdmlsbGVnZWRcbiAgY29uc3QgcmVtb3RlSXAgPSByZXEgJiYgcmVxLmNvbm5lY3Rpb24gPyByZXEuY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzIDogJyc7XG4gIHNvY2tldC5VTE9DQUwgPSByZW1vdGVJcCA9PT0gJzEyNy4wLjAuMScgfHwgcmVtb3RlSXAgPT09ICc6OjEnO1xuICAvLyBzYXZlIHNvY2tldFxuICBtdV9zb2NrZXRzLnNldChzaWQsIHNvY2tldCk7XG4gIGlmIChEQkcuaW5pdCkgVE9VVChgc29ja2V0IEFERCAke3NvY2tldC5VQUREUn0gdG8gbmV0d29ya2ApO1xuICBMT0dHRVIuV3JpdGUoc29ja2V0LlVBRERSLCAnam9pbmVkIG5ldHdvcmsnKTtcbiAgaWYgKERCRy5pbml0KSBsb2dfTGlzdFNvY2tldHMoYGFkZCAke3NpZH1gKTtcbn0gLy8gZW5kIG1fU29ja2V0QWRkKClcblxuLy8vXHQtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBVdGlsaXR5IHRvIGdlbmVyYXRlIGEgbmV3IFVBRERSIGlkIGZvciBjb25uZWN0aW5nIGNsaWVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4XSAtIGRlZmF1bHQgdG8gVUFERFJcbiAqL1xuZnVuY3Rpb24gbV9HZXROZXdVQUREUihwcmVmaXggPSAnVUFERFInKSB7XG4gICsrbXVfc2lkX2NvdW50ZXI7XG4gIGxldCBjc3RyID0gbXVfc2lkX2NvdW50ZXIudG9TdHJpbmcoMTApLnBhZFN0YXJ0KDIsICcwJyk7XG4gIHJldHVybiBgJHtwcmVmaXh9XyR7Y3N0cn1gO1xufVxuXG4vLy9cdC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIFJldHVybnMgYSBKU09OIHBhY2tldCB0byB0aGUganVzdC1jb25uZWN0ZWQgY2xpZW50IHdpdGggaXRzIGFzc2lnbmVkIFVSU1lTXG4gKiBhZGRyZXNzIChVQUREUikgYW5kIHRoZSBzZXJ2ZXIncyBVQUREUi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb2NrZXQgY29ubmVjdGluZyBzb2NrZXRcbiAqL1xuZnVuY3Rpb24gbV9Tb2NrZXRDbGllbnRBY2soc29ja2V0KSB7XG4gIGxldCBQRUVSUyA9IHsgY291bnQ6IG11X3NvY2tldHMuc2l6ZSB9O1xuICBsZXQgZGF0YSA9IHtcbiAgICBIRUxMTzogYFdlbGNvbWUgdG8gVVJTWVMsICR7c29ja2V0LlVBRERSfWAsXG4gICAgVUFERFI6IHNvY2tldC5VQUREUixcbiAgICBTRVJWRVJfVUFERFIsXG4gICAgUEVFUlMsXG4gICAgVUxPQ0FMOiBzb2NrZXQuVUxPQ0FMXG4gIH07XG4gIHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbn0gLy8gZW5kIG1fU29ja2V0Q2xpZW50QWNrKClcblxuLy8vXHQtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBNYWluIGVudHJ5IHBvaW50IGZvciBoYW5kbGluZyAnbWVzc2FnZScgZXZlbnRzIGZyb20gYSBjbGllbnQgc29ja2V0LiBJdFxuICogY29udmVydHMgdGhlIGluY29taW5nIEpTT04gdG8gYSBOZXRQYWNrZXQgcGFja2V0IGFuZCBwYXNzZXMgcHJvY2Vzc2luZ1xuICogZnVydGhlciBvbiBkZXBlbmRpbmcgb24gdGhlIHR5cGUuXG4gKiBAcGFyYW0ge09iamVjdH0gc29ja2V0IG1lc3NhZ2luZyBzb2NrZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBqc29uIHRleHQtZW5jb2RlZCBOZXRQYWNrZXRcbiAqL1xuZnVuY3Rpb24gbV9Tb2NrZXRPbk1lc3NhZ2Uoc29ja2V0LCBqc29uKSB7XG4gIGxldCBwa3QgPSBuZXcgTmV0UGFja2V0KGpzb24pO1xuICAvLyBmaWd1cmUgb3V0IHdoYXQgdG8gZG9cbiAgc3dpdGNoIChwa3QuVHlwZSgpKSB7XG4gICAgY2FzZSAnbXNpZyc6XG4gICAgY2FzZSAnbXNlbmQnOlxuICAgIGNhc2UgJ21jYWxsJzpcbiAgICAgIG1fSGFuZGxlTWVzc2FnZShzb2NrZXQsIHBrdCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzdGF0ZSc6XG4gICAgICAvLyBtX0hhbmRsZVN0YXRlKHNvY2tldCwgcGt0KTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7VE9VVH0gdW5rbm93biBwYWNrZXQgdHlwZSAnJHtwa3QuVHlwZSgpfSdgKTtcbiAgfSAvLyBlbmQgc3dpdGNoXG59IC8vIGVuZCBtX1NvY2tldE9uTWVzc2FnZSgpXG5cbi8vL1x0LSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogVXRpbGl0eSB0byBoYW5kbGUgZGlzY29ubmVjdGVkIHNvY2tldHMuIEl0IGRvZXMgdGhlIGludGVybmFsIGhvdXNla2VlcGluZ1xuICogYW5kIGxvZ2dpbmcsIGFuZCByZW1vdmVzIGFueSByZWdpc3RlcmVkIG1lc3NhZ2VzIHRoYXQgdGhlIHNvY2tldCBtYXkgaGF2ZVxuICogaGFkLlxuICovXG5mdW5jdGlvbiBtX1NvY2tldERlbGV0ZShzb2NrZXQpIHtcbiAgbGV0IHVhZGRyID0gc29ja2V0LlVBRERSO1xuICBpZiAoIW11X3NvY2tldHMuaGFzKHVhZGRyKSkgdGhyb3cgRXJyb3IoREJHX1NPQ0tfQkFEQ0xPU0UpO1xuICBpZiAoREJHKSBUT1VUKGBzb2NrZXQgREVMICR7dWFkZHJ9IGZyb20gbmV0d29ya2ApO1xuICBjb25zdCB1c2VyID0gc29ja2V0LlVTRVNTID8gc29ja2V0LlVTRVNTLnRva2VuIDogJyc7XG4gIExPR0dFUi5Xcml0ZShzb2NrZXQuVUFERFIsICdsZWZ0IG5ldHdvcmsnLCB1c2VyLnRvVXBwZXJDYXNlKCkpO1xuICBtdV9zb2NrZXRzLmRlbGV0ZSh1YWRkcik7XG4gIC8vIGRlbGV0ZSBzb2NrZXQgcmVmZXJlbmNlIGZyb20gcHJldmlvdXNseSByZWdpc3RlcmVkIGhhbmRsZXJzXG4gIGxldCBybWVzZ3MgPSBtX3NvY2tldF9tc2dzX2xpc3QuZ2V0KHVhZGRyKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocm1lc2dzKSkge1xuICAgIHJtZXNncy5mb3JFYWNoKG1zZyA9PiB7XG4gICAgICBsZXQgaGFuZGxlcnMgPSBtX3JlbW90ZV9oYW5kbGVycy5nZXQobXNnKTtcbiAgICAgIGlmIChEQkcpIFRPVVQoYCR7dWFkZHJ9IHJlbW92ZWQgaGFuZGxlciAnJHttc2d9J2ApO1xuICAgICAgaWYgKGhhbmRsZXJzKSBoYW5kbGVycy5kZWxldGUodWFkZHIpO1xuICAgIH0pO1xuICB9XG4gIGlmIChEQkcuaW5pdCkgbG9nX0xpc3RTb2NrZXRzKGBkZWwgJHtzb2NrZXQuVUFERFJ9YCk7XG4gIC8vIHRlbGwgc3Vic2NyaWJlcnMgc29ja2V0IGlzIGdvbmVcbiAgVU5FVC5Mb2NhbFB1Ymxpc2goJ1NSVl9TT0NLRVRfREVMRVRFRCcsIHsgdWFkZHIgfSk7XG59IC8vIGVuZCBtX1NvY2tldERlbGV0ZSgpXG5cbi8vL1x0LSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogUmV0dXJucyB0aGUgc29ja2V0IGFzc29jaWF0ZWQgd2l0aCBhIHVhZGRyLiBUaGUgVUFERFJcbiAqIGNhbiBiZSBhY2Nlc3NlZCBmcm9tIGEgTmV0UGFja2V0IHBhY2tldCdzIFNvdXJjZUFkZHJlc3MoKS5cbiAqL1xuZnVuY3Rpb24gbV9Tb2NrZXRMb29rdXAodWFkZHIpIHtcbiAgcmV0dXJuIG11X3NvY2tldHMuZ2V0KHVhZGRyKTtcbn1cblxuLy8vXHQtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBNQUlOIEhBTkRMRVIgdGhhdCBwZXJmb3JtcyB0aGUgYWN0dWFsIHdvcmsgb2YgZGlzcGF0Y2hpbmcgbWVzc2FnZXMgb24gYmVoYWxmXG4gKiBvZiBhIGNsaWVudCB0byBvdGhlciByZW1vdGUgY2xpZW50cywgZ2F0aGVycyB1cCBhbGwgdGhlIGRhdGEsIGFuZCByZXR1cm5zXG4gKiBpdC4gVGhlcmUgYXJlIFRIUkVFIENBU0VTOlxuICogMS4gVGhlIGluY29taW5nIG1lc3NhZ2UgaXMgcmV0dXJuaW5nIGZyb20gYSByZW1vdGUgY2FsbGVyIHRvIHJlbW90ZSBzZW5kZXJcbiAqIDIuIFRoZSBpbmNvbWluZyBtZXNzYWdlIGlzIGludGVuZGVkIGZvciB0aGUgc2VydmVyXG4gKiAzLiB0aGUgaW5jb21pbmcgbWVzc2FnZSBpcyBmcm9tIGEgcmVtb3RlIHJlYWNoaW5nIGFub3RoZXIgcmVtb3RlXG4gKiBAcGFyYW0ge09iamVjdH0gc29ja2V0IG1lc3NhZ2luZyBzb2NrZXRcbiAqIEBwYXJhbSB7TmV0UGFja2V0fSBwa3QgLSBOZXRQYWNrZXQgcGFja2V0IGluc3RhbmNlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1fSGFuZGxlTWVzc2FnZShzb2NrZXQsIHBrdCkge1xuICAvLyAoMSkgSXMgdGhlIGluY29taW5nIG1lc3NhZ2UgYSByZXNwb25zZSB0byBhIG1lc3NhZ2UgdGhhdCB0aGUgc2VydmVyIHNlbnQ/XG4gIC8vIEl0IG1pZ2h0IGhhdmUgYmVlbiBhIGR1cGxpY2F0ZSBwYWNrZXQgKCdmb3J3YXJkZWQnKSBvciBvbmUgdGhlIHNlcnZlciBpdHNlbGYgc2VudC5cbiAgLy8gSW4gZWl0aGVyIGNhc2UsIHRoZSBwYWNrZXQgd2lsbCBpbnZva2Ugd2hhdGV2ZXIgZnVuY3Rpb24gaGFuZGxlciBpcyBhc3NvY2lhdGVkIHdpdGhcbiAgLy8gaXQgYW5kIGNvbXBsZXRlIHRoZSB0cmFuc2FjdGlvbiBmdW5jdGlvbi4gTm90ZSB0aGF0IGRpc3BhdGNoZWQgbWVzc2FnZXMgY29tcHJpc2VcbiAgLy8gb2YgdGhlIG9yaWdpbmFsIHBhY2tldCBhbmQgdGhlIGZvcndhcmRlZCBkdXBsaWNhdGUgcGFja2V0KHMpIHRoYXQgdGhlIHNlcnZlclxuICAvLyByZWNvbWJpbmVzIGFuZCByZXR1cm5zIHRvIHRoZSBvcmlnaW5hbCBwYWNrZXQgc2VuZGVyXG4gIGlmIChwa3QuSXNSZXNwb25zZSgpKSB7XG4gICAgaWYgKERCRy5jYWxscylcbiAgICAgIFRPVVQoYC0tICR7cGt0Lk1lc3NhZ2UoKX0gY29tcGxldGluZyB0cmFuc2FjdGlvbiAke3BrdC5zZXFsb2cuam9pbignOicpfWApO1xuICAgIHBrdC5Db21wbGV0ZVRyYW5zYWN0aW9uKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vICgyKSBJZiB3ZSBnb3QgdGhpcyBmYXIsIGl0J3MgYSBuZXcgbWVzc2FnZS5cbiAgLy8gRG9lcyB0aGUgc2VydmVyIGltcGxlbWVudCBhbnkgb2YgdGhlIG1lc3NhZ2VzPyBMZXQncyBhZGQgdGhhdCB0byBvdXJcbiAgLy8gbGlzdCBvZiBwcm9taXNlcy4gSXQgd2lsbCByZXR1cm4gZW1wdHkgYXJyYXkgaWYgdGhlcmUgYXJlIG5vbmUuXG4gIGxldCBwcm9taXNlcyA9IG1fUHJvbWlzZVNlcnZlckhhbmRsZXJzKHBrdCk7XG5cbiAgLy8gKDMpIElmIHRoZSBzZXJ2ZXIgZG9lc24ndCBpbXBsZW1lbnQgYW55IHByb21pc2VzLCBjaGVjayBpZiB0aGVyZSBhcmVcbiAgLy8gYW55IHJlbW90ZXMgdGhhdCBoYXZlIHJlZ2lzdGVyZWQgb25lLlxuICBpZiAocHJvbWlzZXMubGVuZ3RoID09PSAwKSBwcm9taXNlcyA9IG1fUHJvbWlzZVJlbW90ZUhhbmRsZXJzKHBrdCk7XG5cbiAgLy8gKDNhKSBJZiB0aGVyZSB3ZXJlIE5PIEhBTkRMRVJTIGRlZmluZWQgZm9yIHRoZSBpbmNvbWluZyBtZXNzYWdlLCB0aGVuXG4gIC8vIHRoaXMgaXMgYW4gZXJyb3IuIElmIHRoZSBtZXNzYWdlIGlzIGEgQ0FMTCwgdGhlbiByZXBvcnQgYW4gZXJyb3IgYmFjayB0b1xuICAvLyB0aGUgb3JpZ2luYXRvcjsgb3RoZXIgbWVzc2FnZSB0eXBlcyBkb24ndCBleHBlY3QgYSByZXR1cm4gdmFsdWUuXG4gIGlmIChwcm9taXNlcy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zdCBvdXQgPSBgJHtwa3QuU291cmNlQWRkcmVzcygpfSBjYW5ub3QgcmVzb2x2ZSBjYWxsICcke3BrdC5NZXNzYWdlKCl9J2A7XG4gICAgVE9VVChvdXQpO1xuICAgIC8vIHJldHVybiB0cmFuc2FjdGlvbiB0byByZXNvbHZlIGNhbGxlZVxuICAgIHBrdC5TZXREYXRhKHtcbiAgICAgIFVSc2VydmVyOiBgaW5mbzogJHtvdXR9YCxcbiAgICAgIGVycm9yOiBgbWVzc2FnZSAke3BrdC5NZXNzYWdlKCl9IG5vdCBmb3VuZGAsXG4gICAgICBjb2RlOiBOZXRQYWNrZXQuQ09ERV9OT19NRVNTQUdFXG4gICAgfSk7XG4gICAgaWYgKHBrdC5Jc1R5cGUoJ21jYWxsJykpIHBrdC5SZXR1cm5UcmFuc2FjdGlvbihzb2NrZXQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vICgzYikgV2UgaGF2ZSBhdCBsZWFzdCBvbmUgcHJvbWlzZSBmb3IgcmVtb3RlIGhhbmRsZXJzLlxuICAvLyBJdCB3aWxsIGVpdGhlciBiZSBzZXJ2ZXIgY2FsbHMgb3IgcmVtb3RlIGNhbGxzLiBUaGUgc2VydmVyXG4gIC8vIGFsd2F5cyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgcmVtb3RlIGNhbGxzIHNvIGNsaWVudHMgY2FuJ3RcbiAgLy8gc3Vic2NyaWJlIHRvIGNyaXRpY2FsIHN5c3RlbSBtZXNzYWdlcyBpbnRlbmRlZCBvbmx5IGZvclxuICAvLyB0aGUgc2VydmVyIVxuXG4gIC8vIFByaW50IHNvbWUgZGVidWdnaW5nIG1lc3NhZ2VzXG4gIGNvbnN0IERCR19OT1NSViA9ICFwa3QuSXNTZXJ2ZXJNZXNzYWdlKCk7XG4gIGlmIChEQkcuY2FsbHMpIGxvZ19Qa3REaXJlY3Rpb24ocGt0LCAnY2FsbCcsIHByb21pc2VzKTtcbiAgaWYgKERCRy5jYWxscyAmJiBEQkdfTk9TUlYpIGxvZ19Qa3RUcmFuc2FjdGlvbihwa3QsICdxdWV1aW5nJywgcHJvbWlzZXMpO1xuXG4gIC8qICgzYykgTUFHSUNBTCBBU1lOQy9BV0FJVCBCTE9DSyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiBwa3RBcnJheSB3aWxsIGNvbnRhaW4gZGF0YSBvYmplY3RzIGZyb20gZWFjaCByZXNvbHZlZCAqL1xuICAvKiBwcm9taXNlICovXG4gIGxldCBwa3RBcnJheSA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgLyogRU5EIE1BR0lDQUwgQVNZTkMvQVdBSVQgQkxPQ0sgKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLy8gKDNkKSBQcmludCBzb21lIG1vcmUgZGVidWdnaW5nIG1lc3NhZ2VzIGFmdGVyIGFzeW5jXG4gIGlmIChEQkcuY2FsbHMpIHtcbiAgICBpZiAoREJHX05PU1JWKSBsb2dfUGt0VHJhbnNhY3Rpb24ocGt0LCAncmVzb2x2ZWQnKTtcbiAgICBsb2dfUGt0RGlyZWN0aW9uKHBrdCwgJ3J0cm4nLCBwcm9taXNlcyk7XG4gIH1cblxuICAvLyAoM2UpIElmIHRoZSBjYWxsIHR5cGUgZG9lc24ndCBleHBlY3QgcmV0dXJuIGRhdGEsIHdlIGFyZSBkb25lIVxuICBpZiAoIXBrdC5Jc1R5cGUoJ21jYWxsJykpIHJldHVybjtcblxuICAvLyAoM2YpIElmIHRoZSBjYWxsIHR5cGUgaXMgJ21jYWxsJywgYW5kIHdlIG5lZWQgdG8gcmV0dXJuIHRoZSBvcmlnaW5hbFxuICAvLyBtZXNzYWdlIHBhY2tldCB0byB0aGUgb3JpZ2luYWwgY2FsbGVyLiBGaXJzdCBtZXJnZSB0aGUgZGF0YSBpbnRvXG4gIC8vIG9uZSBkYXRhIG9iamVjdC4uLlxuICBsZXQgZGF0YSA9IHBrdEFycmF5LnJlZHVjZSgoZCwgcCkgPT4ge1xuICAgIGxldCBwZGF0YSA9IHAgaW5zdGFuY2VvZiBOZXRQYWNrZXQgPyBwLkRhdGEoKSA6IHA7XG4gICAgbGV0IHJldHZhbCA9IE9iamVjdC5hc3NpZ24oZCwgcGRhdGEpO1xuICAgIGlmIChEQkdfTk9TUlYpIFRPVVQoYCcke3BrdC5NZXNzYWdlKCl9JyByZWR1Y2VgLCBKU09OLnN0cmluZ2lmeShyZXR2YWwpKTtcbiAgICByZXR1cm4gcmV0dmFsO1xuICB9LCB7fSk7XG5cbiAgLy8gKDNnKSAuLi50aGVuIHJldHVybiB0aGUgY29tYmluZWQgZGF0YSB1c2luZyBOZXRQYWNrZXQuUmV0dXJuVHJhbnNhY3Rpb24oKVxuICAvLyBvbiB0aGUgY2FsbGVyJ3Mgc29ja2V0LCB3aGljaCB3ZSBoYXZlIHJldGFpbmVkIHRocm91Z2ggdGhlIG1hZ2ljIG9mIGNsb3N1cmVzIVxuICBjb25zdCBkYmdEYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIHBrdC5TZXREYXRhKGRhdGEpO1xuICBpZiAoREJHX05PU1JWKSBUT1VUKGAnJHtwa3QuTWVzc2FnZSgpfScgcmV0dXJuaW5nIHRyYW5zYWN0aW9uIGRhdGEgJHtkYmdEYXRhfWApO1xuICBwa3QuUmV0dXJuVHJhbnNhY3Rpb24oc29ja2V0KTtcbn0gLy8gZW5kIG1fSGFuZGxlTWVzc2FnZSgpXG5cbi8vL1x0LSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogTUFJTiBIQU5ETEVSIChjdXJyZW50bHkgc3R1YikgZm9yIG5ldHdvcmstc3luY2hlZCBzdGF0ZSBtZXNzYWdlcywgd2hpY2hcbiAqIGFyZSBub3QgeWV0IGltcGxlbWVudGVkIGluIFVSU1lTXG4gKiBAcGFyYW0ge09iamVjdH0gc29ja2V0IG1lc3NhZ2luZyBzb2NrZXRcbiAqIEBwYXJhbSB7TmV0UGFja2V0fSBwa3QgYSBOZXRQYWNrZXQgb2JqZWN0IHJlY2VpdmVkIGZyb20gc29ja2V0XG4gKi9cbi8vLyBmdW5jdGlvbiBtX0hhbmRsZVN0YXRlKHNvY2tldCwgcGt0KSB7fVxuXG4vLy9cdC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIEtFWSBIRUxQRVIgdGhhdCByZXR1cm5zIGFuIGFycmF5IG9mIFByb21pc2VzIHRoYXQgY2FsbCB0aGUgZnVuY3Rpb25zXG4gKiBhc3NvY2lhdGVkIHdpdGggYSBTRVJWRVItYmFzZWQgbWVzc2FnZSBoYW5kbGVyLiBIYW5kbGVyIGZ1bmN0aW9ucyBtdXN0IHJldHVyblxuICogYSBkYXRhIG9iamVjdC4gVW5saWtlIHRoZSByZW1vdGUgdmVyc2lvbiBvZiB0aGlzIGZ1bmN0aW9uLCB0aGlzIGV4ZWN1dGVzXG4gKiBzeW5jaHJvbm91c2x5IGJlY2F1c2UgdGhlcmUgaXMgbm8gbmV0d29yayBjb21tdW5pY2F0aW9uIHJlcXVpcmVkLlxuICogQHBhcmFtIHtOZXRQYWNrZXR9IHBrdCBhIE5ldFBhY2tldCBvYmplY3QgdG8gdXNlIGFzIG1lc3NhZ2Uga2V5XG4gKiBAcmV0dXJucyB7QXJyYXk8UHJvbWlzZT59IHByb21pc2VzIG9iamVjdHMgdG8gdXNlIHdpdGggYXdhaXRcbiAqL1xuZnVuY3Rpb24gbV9Qcm9taXNlU2VydmVySGFuZGxlcnMocGt0KSB7XG4gIGxldCBtZXNnTmFtZSA9IHBrdC5NZXNzYWdlKCk7XG4gIGNvbnN0IGhhbmRsZXJzID0gbV9zZXJ2ZXJfaGFuZGxlcnMuZ2V0KG1lc2dOYW1lKTtcbiAgLy8vIGNyZWF0ZSBwcm9taXNlcyBmb3IgYWxsIHJlZ2lzdGVyZWQgaGFuZGxlcnMgaW4gdGhlIHNldFxuICBsZXQgcHJvbWlzZXMgPSBbXTtcbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIHByb21pc2VzO1xuICBoYW5kbGVycy5mb3JFYWNoKGhGdW5jID0+IHtcbiAgICBsZXQgcCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCByZXR2YWwgPSBoRnVuYyhwa3QpO1xuICAgICAgaWYgKHJldHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBgJyR7bWVzZ05hbWV9JyBtZXNzYWdlIGhhbmRsZXIgTVVTVCByZXR1cm4gb2JqZWN0IG9yIGVycm9yIHN0cmluZ2BcbiAgICAgICAgKTtcbiAgICAgIGlmICh0eXBlb2YgcmV0dmFsICE9PSAnb2JqZWN0JykgcmVqZWN0KHJldHZhbCk7XG4gICAgICBlbHNlIHJlc29sdmUocmV0dmFsKTtcbiAgICB9KTtcbiAgICBwcm9taXNlcy5wdXNoKHApO1xuICB9KTsgLy8gaGFuZGxlcnMgZm9yRWFjaFxuICByZXR1cm4gcHJvbWlzZXM7XG59IC8vIGVuZCBtX1Byb21pc2VTZXJ2ZXJIYW5kbGVycygpXG5cbi8vL1x0LSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogS0VZIEhFTFBFUiBmb3IgaGFuZGxpbmcgXCJmb3J3YXJkZWQgY2FsbHNcIiB0byByZW1vdGUgVVJTWVMgZGV2aWNlcyBvbiBiZWhhbGZcbiAqIG9mIGFuIGluY29taW5nIGNhbGwgdGhhdCBpc24ndCBpbXBsZW1lbnRlZCBvbiB0aGUgc2VydmVyLiBJdCB3b3JrcyBieSBjbG9uaW5nXG4gKiB0aGUgb3JpZ2luYWwgTmV0UGFja2V0IHBhY2tldCBhbmQgc2VuZGluZyBpdCB0byByZW1vdmVzIHZpYVxuICogTmV0UGFja2V0LlByb21pc2VUcmFuc2FjdGlvbigpLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgcHJvbWlzZXMgdGhhdCByZXNvbHZlXG4gKiB3aGVuIE5ldFBhY2tldC5Db21wbGV0ZVRyYW5zYWN0aW9uKCkgaXMgaW52b2tlZCBvbiB0aGUgcmV0dXJuZWQgZGF0YS4gVXNlXG4gKiBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcykgdG8gd2FpdC5cbiAqIEBwYXJhbSB7TmV0UGFja2V0fSBwa3QgYSBOZXRQYWNrZXQgb2JqZWN0IHRvIHVzZSBhcyBtZXNzYWdlIGtleVxuICogQHJldHVybnMge0FycmF5PFByb21pc2U+fSBwcm9taXNlcyBvYmplY3RzIHRvIHVzZSB3aXRoIFByb21pc2UuYWxsKClcbiAqL1xuZnVuY3Rpb24gbV9Qcm9taXNlUmVtb3RlSGFuZGxlcnMocGt0KSB7XG4gIC8vIGRlYnVnZ2luZyB2YWx1ZXNcbiAgbGV0IHNfdWFkZHIgPSBwa3QuU291cmNlQWRkcmVzcygpO1xuICAvLyBsb2dpYyB2YWx1ZXNcbiAgbGV0IG1lc2dOYW1lID0gcGt0Lk1lc3NhZ2UoKTtcbiAgbGV0IHR5cGUgPSBwa3QuVHlwZSgpO1xuICBjb25zdCBwdWJsaXNoT25seSA9IHR5cGUgPT09ICdtc2VuZCcgfHwgdHlwZSA9PT0gJ21jYWxsJztcblxuICAvLyBnZW5lcmF0ZSB0aGUgbGlzdCBvZiBwcm9taXNlc1xuICBsZXQgcHJvbWlzZXMgPSBbXTtcbiAgLy8gZGlzYWxsb3cgTkVUOlNZU1RFTSBwdWJsaXNoZWQgbWVzc2FnZXMgZnJvbSByZW1vdGUgY2xpZW50c1xuICBpZiAoIXBrdC5Jc1NlcnZlck9yaWdpbigpICYmIG1lc2dOYW1lLnN0YXJ0c1dpdGgoJ05FVDpTWVNURU0nKSkgcmV0dXJuIHByb21pc2VzO1xuICAvLyBjaGVjayBmb3IgaGFuZGxlcnNcbiAgbGV0IGhhbmRsZXJzID0gbV9yZW1vdGVfaGFuZGxlcnMuZ2V0KG1lc2dOYW1lKTtcbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIHByb21pc2VzO1xuXG4gIC8vIGlmIHRoZXJlIGFyZSBoYW5kbGVycyB0byBoYW5kbGUsIGNyZWF0ZSBhIE5ldFBhY2tldFxuICAvLyBjbG9uZSBvZiB0aGlzIHBhY2tldCBhbmQgZm9yd2FyZCBpdCBhbmQgc2F2ZSB0aGUgcHJvbWlzZVxuICBoYW5kbGVycy5mb3JFYWNoKGRfdWFkZHIgPT4ge1xuICAgIGNvbnN0IGlzT3JpZ2luID0gc191YWRkciA9PT0gZF91YWRkcjtcbiAgICAvLyB3ZSB3YW50IHRvIGRvIHRoaXMgb25seSB3aGVuXG4gICAgaWYgKHB1Ymxpc2hPbmx5ICYmIGlzT3JpZ2luKSB7XG4gICAgICBpZiAoREJHLmNhbGxzKSBUT1VUKGBza2lwcGluZyBtc2VuZHxtY2FsbCBmcm9tICR7c191YWRkcn0gdG8gJHtkX3VhZGRyfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZF9zb2NrID0gbXVfc29ja2V0cy5nZXQoZF91YWRkcik7XG4gICAgICBpZiAoZF9zb2NrID09PSB1bmRlZmluZWQpIHRocm93IEVycm9yKGAke0VSUl9JTlZBTElEX0RFU1R9ICR7ZF91YWRkcn1gKTtcbiAgICAgIGxldCBuZXdwa3QgPSBuZXcgTmV0UGFja2V0KHBrdCk7IC8vIGNsb25lIHBhY2tldCBkYXRhIHRvIG5ldyBwYWNrZXRcbiAgICAgIG5ld3BrdC5NYWtlTmV3SUQoKTsgLy8gbWFrZSBuZXcgcGFja2V0IHVuaXF1ZVxuICAgICAgbmV3cGt0LkNvcHlTb3VyY2VBZGRyZXNzKHBrdCk7IC8vIGNsb25lIG9yaWdpbmFsIHNvdXJjZSBhZGRyZXNzXG4gICAgICBwcm9taXNlcy5wdXNoKG5ld3BrdC5Qcm9taXNlVHJhbnNhY3Rpb24oZF9zb2NrKSk7XG4gICAgfVxuICB9KTsgLy8gaGFuZGxlcnMuZm9yRWFjaFxuICByZXR1cm4gcHJvbWlzZXM7XG59XG5cbi8vL1x0LSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogaGVscGVyIGRlYnVnIG91dHB1dCB1c2VkIGJ5IG1fU29ja2V0QWRkKCksIG1fU29ja2V0RGVsZXRlKCkgKi9cbmZ1bmN0aW9uIGxvZ19MaXN0U29ja2V0cyhjaGFuZ2UpIHtcbiAgVE9VVChgc29ja2V0bGlzdCBjaGFuZ2VkOiAnJHtjaGFuZ2V9J2ApO1xuICAvLyBsZXQncyB1c2UgaXRlcmF0b3JzISBmb3IuLm9mXG4gIGxldCB2YWx1ZXMgPSBtdV9zb2NrZXRzLnZhbHVlcygpO1xuICBsZXQgY291bnQgPSAxO1xuICBmb3IgKGxldCBzb2NrZXQgb2YgdmFsdWVzKSB7XG4gICAgVE9VVChgICAke2NvdW50fSA9ICR7c29ja2V0LlVBRERSfWApO1xuICAgIGNvdW50Kys7XG4gIH1cbn1cbi8vL1x0LSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogaGVscGVyIGRlYnVnIG91dHB1dCB1c2VkIGJ5IG1fSGFuZGxlTWVzc2FnZSgpICovXG5mdW5jdGlvbiBsb2dfUGt0RGlyZWN0aW9uKHBrdCwgZGlyZWN0aW9uLCBwcm9taXNlcykge1xuICBpZiAocHJvbWlzZXMubGVuZ3RoIDwgMSkgcmV0dXJuO1xuICBjb25zdCBlbnRzID0gcHJvbWlzZXMubGVuZ3RoID4gMSA/ICdoYW5kbGVycycgOiAnaGFuZGxlcic7XG4gIFRPVVQoXG4gICAgYCR7cGt0LkluZm8oKX0gJHtkaXJlY3Rpb259ICcke3BrdC5NZXNzYWdlKCl9JyAoJHtwcm9taXNlcy5sZW5ndGh9ICR7ZW50c30pYFxuICApO1xufVxuLy8vXHQtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBoZWxwZXIgZGVidWcgb3V0cHV0IHVzZWQgYnkgbV9IYW5kbGVNZXNzYWdlKCkgKi9cbmZ1bmN0aW9uIGxvZ19Qa3RUcmFuc2FjdGlvbihwa3QsIHN0YXR1cywgcHJvbWlzZXMpIHtcbiAgY29uc3Qgc3JjID0gcGt0LlNvdXJjZUFkZHJlc3MoKTtcbiAgaWYgKHByb21pc2VzICYmIHByb21pc2VzLmxlbmd0aCkge1xuICAgIFRPVVQoYCR7c3JjfSA+PiAnJHtwa3QuTWVzc2FnZSgpfScgJHtzdGF0dXN9ICR7cHJvbWlzZXMubGVuZ3RofSBQcm9taXNlc2ApO1xuICB9IGVsc2Uge1xuICAgIFRPVVQoYCR7c3JjfSA8PCAnJHtwa3QuTWVzc2FnZSgpfScgJHtzdGF0dXN9YCk7XG4gIH1cbn1cblxuLy8vIEVYUE9SVCBNT0RVTEUgREVGSU5JVElPTiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxubW9kdWxlLmV4cG9ydHMgPSBVTkVUO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/server-urnet.js\n");

/***/ }),

/***/ "./src/util/datestring.js":
/*!********************************!*\
  !*** ./src/util/datestring.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/////////////////////////////////////////////////////////////////////////////\n\n/**\tUTILITY FUNCTIONS ******************************************************/\n// enums for outputing dates\nconst e_weekday = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']; ///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nfunction str_TimeStamp() {\n  let date = new Date();\n  let hh = `0${date.getHours()}`.slice(-2);\n  let mm = `0${date.getMinutes()}`.slice(-2);\n  let ss = `0${date.getSeconds()}`.slice(-2);\n  return `${hh}:${mm}:${ss}`;\n} ///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nfunction str_DateStamp() {\n  let date = new Date();\n  let mm = `0${date.getMonth() + 1}`.slice(-2);\n  let dd = `0${date.getDate()}`.slice(-2);\n  let day = e_weekday[date.getDay()];\n  let yyyy = date.getFullYear();\n  return `${yyyy}/${mm}/${dd} ${day}`;\n} ///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/**\n *  return a filename of form YYYY-MMDD-args-separated-by-dashes-HHMMSS\n */\n\n\nfunction str_TimeDatedFilename(...args) {\n  // construct filename\n  let date = new Date();\n  let dd = `0${date.getDate()}`.slice(-2);\n  let mm = `0${date.getMonth() + 1}`.slice(-2);\n  let hms = `0${date.getHours()}`.slice(-2);\n  hms += `0${date.getMinutes()}`.slice(-2);\n  hms += `0${date.getSeconds()}`.slice(-2);\n  let filename;\n  filename = date.getFullYear().toString();\n  filename += `-${mm}${dd}`;\n  let c = arguments.length;\n  if (c) filename = filename.concat('-', ...args);\n  filename += `-${hms}`;\n  return filename;\n} ///\t- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nmodule.exports = {\n  TimeStamp: str_TimeStamp,\n  DateStamp: str_DateStamp,\n  DatedFilename: str_TimeDatedFilename\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9kYXRlc3RyaW5nLmpzPzBmNzAiXSwibmFtZXMiOlsiZV93ZWVrZGF5Iiwic3RyX1RpbWVTdGFtcCIsImRhdGUiLCJEYXRlIiwiaGgiLCJnZXRIb3VycyIsInNsaWNlIiwibW0iLCJnZXRNaW51dGVzIiwic3MiLCJnZXRTZWNvbmRzIiwic3RyX0RhdGVTdGFtcCIsImdldE1vbnRoIiwiZGQiLCJnZXREYXRlIiwiZGF5IiwiZ2V0RGF5IiwieXl5eSIsImdldEZ1bGxZZWFyIiwic3RyX1RpbWVEYXRlZEZpbGVuYW1lIiwiYXJncyIsImhtcyIsImZpbGVuYW1lIiwidG9TdHJpbmciLCJjIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiY29uY2F0IiwibW9kdWxlIiwiZXhwb3J0cyIsIlRpbWVTdGFtcCIsIkRhdGVTdGFtcCIsIkRhdGVkRmlsZW5hbWUiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBO0FBQ0E7QUFDQSxNQUFNQSxTQUFTLEdBQUcsQ0FBQyxRQUFELEVBQVcsUUFBWCxFQUFxQixTQUFyQixFQUFnQyxXQUFoQyxFQUE2QyxVQUE3QyxFQUF5RCxRQUF6RCxFQUFtRSxVQUFuRSxDQUFsQixDLENBQ0E7O0FBQ0EsU0FBU0MsYUFBVCxHQUF5QjtBQUN2QixNQUFJQyxJQUFJLEdBQUcsSUFBSUMsSUFBSixFQUFYO0FBQ0EsTUFBSUMsRUFBRSxHQUFJLElBQUdGLElBQUksQ0FBQ0csUUFBTCxFQUFnQixFQUFwQixDQUFzQkMsS0FBdEIsQ0FBNEIsQ0FBQyxDQUE3QixDQUFUO0FBQ0EsTUFBSUMsRUFBRSxHQUFJLElBQUdMLElBQUksQ0FBQ00sVUFBTCxFQUFrQixFQUF0QixDQUF3QkYsS0FBeEIsQ0FBOEIsQ0FBQyxDQUEvQixDQUFUO0FBQ0EsTUFBSUcsRUFBRSxHQUFJLElBQUdQLElBQUksQ0FBQ1EsVUFBTCxFQUFrQixFQUF0QixDQUF3QkosS0FBeEIsQ0FBOEIsQ0FBQyxDQUEvQixDQUFUO0FBQ0EsU0FBUSxHQUFFRixFQUFHLElBQUdHLEVBQUcsSUFBR0UsRUFBRyxFQUF6QjtBQUNELEMsQ0FDRDs7O0FBQ0EsU0FBU0UsYUFBVCxHQUF5QjtBQUN2QixNQUFJVCxJQUFJLEdBQUcsSUFBSUMsSUFBSixFQUFYO0FBQ0EsTUFBSUksRUFBRSxHQUFJLElBQUdMLElBQUksQ0FBQ1UsUUFBTCxLQUFrQixDQUFFLEVBQXhCLENBQTBCTixLQUExQixDQUFnQyxDQUFDLENBQWpDLENBQVQ7QUFDQSxNQUFJTyxFQUFFLEdBQUksSUFBR1gsSUFBSSxDQUFDWSxPQUFMLEVBQWUsRUFBbkIsQ0FBcUJSLEtBQXJCLENBQTJCLENBQUMsQ0FBNUIsQ0FBVDtBQUNBLE1BQUlTLEdBQUcsR0FBR2YsU0FBUyxDQUFDRSxJQUFJLENBQUNjLE1BQUwsRUFBRCxDQUFuQjtBQUNBLE1BQUlDLElBQUksR0FBR2YsSUFBSSxDQUFDZ0IsV0FBTCxFQUFYO0FBQ0EsU0FBUSxHQUFFRCxJQUFLLElBQUdWLEVBQUcsSUFBR00sRUFBRyxJQUFHRSxHQUFJLEVBQWxDO0FBQ0QsQyxDQUNEOztBQUNBOzs7OztBQUdBLFNBQVNJLHFCQUFULENBQStCLEdBQUdDLElBQWxDLEVBQXdDO0FBQ3RDO0FBQ0EsTUFBSWxCLElBQUksR0FBRyxJQUFJQyxJQUFKLEVBQVg7QUFDQSxNQUFJVSxFQUFFLEdBQUksSUFBR1gsSUFBSSxDQUFDWSxPQUFMLEVBQWUsRUFBbkIsQ0FBcUJSLEtBQXJCLENBQTJCLENBQUMsQ0FBNUIsQ0FBVDtBQUNBLE1BQUlDLEVBQUUsR0FBSSxJQUFHTCxJQUFJLENBQUNVLFFBQUwsS0FBa0IsQ0FBRSxFQUF4QixDQUEwQk4sS0FBMUIsQ0FBZ0MsQ0FBQyxDQUFqQyxDQUFUO0FBQ0EsTUFBSWUsR0FBRyxHQUFJLElBQUduQixJQUFJLENBQUNHLFFBQUwsRUFBZ0IsRUFBcEIsQ0FBc0JDLEtBQXRCLENBQTRCLENBQUMsQ0FBN0IsQ0FBVjtBQUNBZSxLQUFHLElBQUssSUFBR25CLElBQUksQ0FBQ00sVUFBTCxFQUFrQixFQUF0QixDQUF3QkYsS0FBeEIsQ0FBOEIsQ0FBQyxDQUEvQixDQUFQO0FBQ0FlLEtBQUcsSUFBSyxJQUFHbkIsSUFBSSxDQUFDUSxVQUFMLEVBQWtCLEVBQXRCLENBQXdCSixLQUF4QixDQUE4QixDQUFDLENBQS9CLENBQVA7QUFDQSxNQUFJZ0IsUUFBSjtBQUNBQSxVQUFRLEdBQUdwQixJQUFJLENBQUNnQixXQUFMLEdBQW1CSyxRQUFuQixFQUFYO0FBQ0FELFVBQVEsSUFBSyxJQUFHZixFQUFHLEdBQUVNLEVBQUcsRUFBeEI7QUFDQSxNQUFJVyxDQUFDLEdBQUdDLFNBQVMsQ0FBQ0MsTUFBbEI7QUFDQSxNQUFJRixDQUFKLEVBQU9GLFFBQVEsR0FBR0EsUUFBUSxDQUFDSyxNQUFULENBQWdCLEdBQWhCLEVBQXFCLEdBQUdQLElBQXhCLENBQVg7QUFDUEUsVUFBUSxJQUFLLElBQUdELEdBQUksRUFBcEI7QUFDQSxTQUFPQyxRQUFQO0FBQ0QsQyxDQUVEOzs7QUFDQU0sTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBQ2ZDLFdBQVMsRUFBRTdCLGFBREk7QUFFZjhCLFdBQVMsRUFBRXBCLGFBRkk7QUFHZnFCLGVBQWEsRUFBRWI7QUFIQSxDQUFqQiIsImZpbGUiOiIuL3NyYy91dGlsL2RhdGVzdHJpbmcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXHRVVElMSVRZIEZVTkNUSU9OUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vLyBlbnVtcyBmb3Igb3V0cHV0aW5nIGRhdGVzXG5jb25zdCBlX3dlZWtkYXkgPSBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J107XG4vLy9cdC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbmZ1bmN0aW9uIHN0cl9UaW1lU3RhbXAoKSB7XG4gIGxldCBkYXRlID0gbmV3IERhdGUoKTtcbiAgbGV0IGhoID0gYDAke2RhdGUuZ2V0SG91cnMoKX1gLnNsaWNlKC0yKTtcbiAgbGV0IG1tID0gYDAke2RhdGUuZ2V0TWludXRlcygpfWAuc2xpY2UoLTIpO1xuICBsZXQgc3MgPSBgMCR7ZGF0ZS5nZXRTZWNvbmRzKCl9YC5zbGljZSgtMik7XG4gIHJldHVybiBgJHtoaH06JHttbX06JHtzc31gO1xufVxuLy8vXHQtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5mdW5jdGlvbiBzdHJfRGF0ZVN0YW1wKCkge1xuICBsZXQgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gIGxldCBtbSA9IGAwJHtkYXRlLmdldE1vbnRoKCkgKyAxfWAuc2xpY2UoLTIpO1xuICBsZXQgZGQgPSBgMCR7ZGF0ZS5nZXREYXRlKCl9YC5zbGljZSgtMik7XG4gIGxldCBkYXkgPSBlX3dlZWtkYXlbZGF0ZS5nZXREYXkoKV07XG4gIGxldCB5eXl5ID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICByZXR1cm4gYCR7eXl5eX0vJHttbX0vJHtkZH0gJHtkYXl9YDtcbn1cbi8vL1x0LSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqXG4gKiAgcmV0dXJuIGEgZmlsZW5hbWUgb2YgZm9ybSBZWVlZLU1NREQtYXJncy1zZXBhcmF0ZWQtYnktZGFzaGVzLUhITU1TU1xuICovXG5mdW5jdGlvbiBzdHJfVGltZURhdGVkRmlsZW5hbWUoLi4uYXJncykge1xuICAvLyBjb25zdHJ1Y3QgZmlsZW5hbWVcbiAgbGV0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICBsZXQgZGQgPSBgMCR7ZGF0ZS5nZXREYXRlKCl9YC5zbGljZSgtMik7XG4gIGxldCBtbSA9IGAwJHtkYXRlLmdldE1vbnRoKCkgKyAxfWAuc2xpY2UoLTIpO1xuICBsZXQgaG1zID0gYDAke2RhdGUuZ2V0SG91cnMoKX1gLnNsaWNlKC0yKTtcbiAgaG1zICs9IGAwJHtkYXRlLmdldE1pbnV0ZXMoKX1gLnNsaWNlKC0yKTtcbiAgaG1zICs9IGAwJHtkYXRlLmdldFNlY29uZHMoKX1gLnNsaWNlKC0yKTtcbiAgbGV0IGZpbGVuYW1lO1xuICBmaWxlbmFtZSA9IGRhdGUuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpO1xuICBmaWxlbmFtZSArPSBgLSR7bW19JHtkZH1gO1xuICBsZXQgYyA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmIChjKSBmaWxlbmFtZSA9IGZpbGVuYW1lLmNvbmNhdCgnLScsIC4uLmFyZ3MpO1xuICBmaWxlbmFtZSArPSBgLSR7aG1zfWA7XG4gIHJldHVybiBmaWxlbmFtZTtcbn1cblxuLy8vXHQtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVGltZVN0YW1wOiBzdHJfVGltZVN0YW1wLFxuICBEYXRlU3RhbXA6IHN0cl9EYXRlU3RhbXAsXG4gIERhdGVkRmlsZW5hbWU6IHN0cl9UaW1lRGF0ZWRGaWxlbmFtZVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/util/datestring.js\n");

/***/ }),

/***/ "./src/util/prompts.js":
/*!*****************************!*\
  !*** ./src/util/prompts.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*///////////////////////////////// ABOUT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\n\n  ANSI TERMINAL color codes and utilities\n\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ * /////////////////////////////////////*/\nconst IS_NODE = typeof window === 'undefined';\nconst DEFAULT_PADDING = IS_NODE ? 10 // nodejs\n: 0; // not nodejs\n\nconst DEFAULT_COLOR = 'TagGray';\nconst CSS_PAD = 'padding:3px 5px;border-radius:2px';\nconst CSS_TAB = '4px';\nconst TERM_COLORS = {\n  // TOUT = makeTerminalOut(str); TOUT('hi')\n  Reset: '\\x1b[0m',\n  Bright: '\\x1b[1m',\n  Dim: '\\x1b[2m',\n  Underscore: '\\x1b[4m',\n  Blink: '\\x1b[5m',\n  Reverse: '\\x1b[7m',\n  Hidden: '\\x1b[8m',\n  //\n  Black: '\\x1b[30m',\n  White: '\\x1b[37m',\n  Red: '\\x1b[31m',\n  Yellow: '\\x1b[33m',\n  Green: '\\x1b[32m',\n  Cyan: '\\x1b[36m',\n  Blue: '\\x1b[34m',\n  Magenta: '\\x1b[35m',\n  //\n  BgBlack: '\\x1b[40m',\n  BgRed: '\\x1b[41m',\n  BgYellow: '\\x1b[43m',\n  BgCyan: '\\x1b[46m',\n  BgGreen: '\\x1b[42m',\n  BgBlue: '\\x1b[44m',\n  BgPurple: '\\x1b[45m',\n  BgWhite: '\\x1b[47m',\n  //\n  TagYellow: '\\x1b[43;30m',\n  TagRed: '\\x1b[41;37m',\n  TagGreen: '\\x1b[42;37m',\n  TagCyan: '\\x1b[46;37m',\n  TagBlue: '\\x1b[43;37m',\n  TagPurple: '\\x1b[45;37m',\n  TagPink: '\\x1b[95;30m',\n  TagGray: '\\x1b[2;37m',\n  TagNull: 'color:#999'\n}; // NAME LIST MUST MATCH TERM_COLORS!\n\nconst CSS_COLORS = {\n  Reset: 'color:auto;background-color:auto',\n  // COLOR FOREGROUND\n  Black: 'color:black',\n  White: 'color:white',\n  Red: 'color:red',\n  Yellow: 'color:orange',\n  Green: 'color:green',\n  Cyan: 'color:cyan',\n  Blue: 'color:blue',\n  Magenta: 'color:magenta',\n  // COLOR BACKGROUND\n  TagRed: `color:#000;background-color:#f66;${CSS_PAD}`,\n  TagYellow: `color:#000;background-color:#fd4;${CSS_PAD}`,\n  TagGreen: `color:#000;background-color:#5c8;${CSS_PAD}`,\n  TagCyan: `color:#000;background-color:#2dd;${CSS_PAD}`,\n  TagBlue: `color:#000;background-color:#2bf;${CSS_PAD}`,\n  TagPurple: `color:#000;background-color:#b6f;${CSS_PAD}`,\n  TagPink: `color:#000;background-color:#f9f;${CSS_PAD}`,\n  TagGray: `color:#999;border:1px solid #ddd;${CSS_PAD}`,\n  TagNull: 'color:#999',\n  // COLOR BACKGROUND DARK\n  TagDkRed: `color:white;background-color:red;${CSS_PAD}`,\n  TagDkGreen: `color:white;background-color:green;${CSS_PAD}`,\n  TagDkBlue: `color:white;background-color:blue;${CSS_PAD}`\n}; /// OUTPUT CONTROL ////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** define\n */\n\nconst SHOW = true;\nconst HIDE = false; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst PROMPT_DICT = {\n  // URSYS-RELATED MODULES\n  'UR': [SHOW, 'TagRed'],\n  // SERVERS\n  'APPSRV': [SHOW, 'Yellow'],\n  'GEMSRV': [SHOW, 'Yellow'],\n  // SPECIAL\n  '-': [SHOW, 'TagNull']\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** add a color to the PROMPT_DICT for a particular PREFIX */\n\nfunction m_SetPromptColors(match, color = DEFAULT_COLOR) {\n  if (typeof match !== 'string') throw Error('match prompt must be string');\n  match = match.trim();\n  if (match === '') throw Error('match prompt cannot be empty');\n  let colorTable = IS_NODE ? TERM_COLORS : CSS_COLORS;\n  let validColor = false;\n  validColor = colorTable[color] !== undefined;\n  if (!validColor) throw Error(`prompt color ${color} is not defined`); // turn on color prompt\n\n  PROMPT_DICT[match] = [true, color];\n  return colorTable;\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Based on current detected enviroment, return either ANSI terminal or\n *  css based color markers for use in debugging messages. If tagColor is\n *  defined and corresponds to color definition, it is used to set the color.\n *  This is so users can set their own color prompts without editing\n *  PROMPTS_DICT structure.\n */\n\n\nfunction m_GetEnvColor(prompt, tagColor) {\n  const colorTable = m_SetPromptColors(prompt, tagColor);\n  const [dbg_mode, defcol] = PROMPT_DICT[prompt.trim()] || [SHOW, DEFAULT_COLOR];\n  const ucolor = colorTable[tagColor];\n  const dcolor = colorTable[defcol];\n  const color = ucolor || dcolor;\n  const reset = colorTable.Reset;\n  return [dbg_mode, color, reset];\n} /// API METHODS ///////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Pad string to fixed length, with default padding depending on\n *  whether the environment is node or browser\n */\n\n\nfunction padString(str, padding = DEFAULT_PADDING) {\n  let len = str.length;\n  if (IS_NODE) return `${str.padEnd(padding, ' ')}`; // must be non-node environment, so do dynamic string adjust\n\n  if (padding === 0) return `${str}`; // if this far, then we're truncating\n\n  if (len >= padding) str = str.substr(0, padding - 1);else str.padEnd(padding, ' ');\n  return `${str}`;\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Return a function that will prompt strings for you. The function will\n *  returns an array to destructure into console.log().\n *\n *  To create the function, provide a short PROMPT. This will be color coded\n *  according to the PROMPTS_DICT table, or gray otherwise. You can turn off the\n *  debug output for all PROMPTS in a category also for centralized debug\n *  statement control.\n *\n *  The prompt function accepts a string followed by any number of parameters.\n *  It returns an array of values that are destructured inside of console.log()\n *    const promptFunction = makeLoginHelper('APP');\n *    console.log(...promptFunction('huzzah'));\n *\n *  NOTE: This doesn't work as expected on NodeJS, because empty arrays\n *  render as linefeeds so we just output it regardless. If you want to\n *  disable output, use the makeTerminalOut() function instead.\n */\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** allow modification of the PROMPT_DICT\n */\n\n\nfunction makeStyleFormatter(prompt, tagColor) {\n  const [dbg, color, reset] = m_GetEnvColor(prompt, tagColor); // return empty array if debugging disabled in browser\n  // or debugging is enabled but it's node (de morgan's law)\n\n  if (!(dbg || IS_NODE)) return () => []; // return the appropriate array to deconstructr\n\n  const wrap = IS_NODE ? (str, ...args) => {\n    return [`${color}${padString(prompt)}${reset}   ${str}`, ...args]; // server\n  } : (str, ...args) => {\n    return [`%c${padString(prompt)}%c ${str}`, color, reset, ...args]; // browser\n  };\n  return wrap;\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Function to directly print to console instead of returning an array. This\n *  works better for NodeJS since the empty [] still results in output unlike\n *  the browser. Use makeStyleFormatter for browsers\n */\n\n\nfunction makeTerminalOut(prompt, tagColor) {\n  const [dbg, color, reset] = m_GetEnvColor(prompt, tagColor);\n  if (!dbg) return () => {};\n  const wrap = IS_NODE ? (str, ...args) => {\n    console.log(`${color}${padString(prompt)}${reset} - ${str}`, ...args);\n  } : (str, ...args) => {\n    console.log(`%c${padString(prompt)}%c ${str}`, color, reset, ...args);\n  };\n  return wrap;\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Print all Tag Colors\n */\n\n\nfunction printTagColors() {\n  const colortable = IS_NODE ? TERM_COLORS : CSS_COLORS;\n  const colors = Object.keys(colortable).filter(element => element.includes('Tag'));\n  const reset = colortable.Reset;\n  const out = 'dbg_colors';\n  if (!IS_NODE) console.groupCollapsed(out);\n  colors.forEach(key => {\n    const color = colortable[key];\n    const items = IS_NODE ? [`${padString(out)} - (node) ${color}${key}${reset}`] : [`(browser) %c${key}%c`, color, reset];\n    console.log(...items);\n  });\n  if (!IS_NODE) console.groupEnd();\n} /// MODULE EXPORTS ////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nmodule.exports = {\n  TERM: TERM_COLORS,\n  CSS: CSS_COLORS,\n  padString,\n  makeStyleFormatter,\n  makeTerminalOut,\n  printTagColors,\n  m_SetPromptColors\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9wcm9tcHRzLmpzPzkxNTAiXSwibmFtZXMiOlsiSVNfTk9ERSIsIndpbmRvdyIsIkRFRkFVTFRfUEFERElORyIsIkRFRkFVTFRfQ09MT1IiLCJDU1NfUEFEIiwiQ1NTX1RBQiIsIlRFUk1fQ09MT1JTIiwiUmVzZXQiLCJCcmlnaHQiLCJEaW0iLCJVbmRlcnNjb3JlIiwiQmxpbmsiLCJSZXZlcnNlIiwiSGlkZGVuIiwiQmxhY2siLCJXaGl0ZSIsIlJlZCIsIlllbGxvdyIsIkdyZWVuIiwiQ3lhbiIsIkJsdWUiLCJNYWdlbnRhIiwiQmdCbGFjayIsIkJnUmVkIiwiQmdZZWxsb3ciLCJCZ0N5YW4iLCJCZ0dyZWVuIiwiQmdCbHVlIiwiQmdQdXJwbGUiLCJCZ1doaXRlIiwiVGFnWWVsbG93IiwiVGFnUmVkIiwiVGFnR3JlZW4iLCJUYWdDeWFuIiwiVGFnQmx1ZSIsIlRhZ1B1cnBsZSIsIlRhZ1BpbmsiLCJUYWdHcmF5IiwiVGFnTnVsbCIsIkNTU19DT0xPUlMiLCJUYWdEa1JlZCIsIlRhZ0RrR3JlZW4iLCJUYWdEa0JsdWUiLCJTSE9XIiwiSElERSIsIlBST01QVF9ESUNUIiwibV9TZXRQcm9tcHRDb2xvcnMiLCJtYXRjaCIsImNvbG9yIiwiRXJyb3IiLCJ0cmltIiwiY29sb3JUYWJsZSIsInZhbGlkQ29sb3IiLCJ1bmRlZmluZWQiLCJtX0dldEVudkNvbG9yIiwicHJvbXB0IiwidGFnQ29sb3IiLCJkYmdfbW9kZSIsImRlZmNvbCIsInVjb2xvciIsImRjb2xvciIsInJlc2V0IiwicGFkU3RyaW5nIiwic3RyIiwicGFkZGluZyIsImxlbiIsImxlbmd0aCIsInBhZEVuZCIsInN1YnN0ciIsIm1ha2VTdHlsZUZvcm1hdHRlciIsImRiZyIsIndyYXAiLCJhcmdzIiwibWFrZVRlcm1pbmFsT3V0IiwiY29uc29sZSIsImxvZyIsInByaW50VGFnQ29sb3JzIiwiY29sb3J0YWJsZSIsImNvbG9ycyIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJlbGVtZW50IiwiaW5jbHVkZXMiLCJvdXQiLCJncm91cENvbGxhcHNlZCIsImZvckVhY2giLCJrZXkiLCJpdGVtcyIsImdyb3VwRW5kIiwibW9kdWxlIiwiZXhwb3J0cyIsIlRFUk0iLCJDU1MiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztBQU1BLE1BQU1BLE9BQU8sR0FBRyxPQUFPQyxNQUFQLEtBQWtCLFdBQWxDO0FBQ0EsTUFBTUMsZUFBZSxHQUFHRixPQUFPLEdBQzNCLEVBRDJCLENBQ3hCO0FBRHdCLEVBRTNCLENBRkosQyxDQUVPOztBQUNQLE1BQU1HLGFBQWEsR0FBRyxTQUF0QjtBQUNBLE1BQU1DLE9BQU8sR0FBRyxtQ0FBaEI7QUFDQSxNQUFNQyxPQUFPLEdBQUcsS0FBaEI7QUFFQSxNQUFNQyxXQUFXLEdBQUc7QUFDbEI7QUFDQUMsT0FBSyxFQUFFLFNBRlc7QUFHbEJDLFFBQU0sRUFBRSxTQUhVO0FBSWxCQyxLQUFHLEVBQUUsU0FKYTtBQUtsQkMsWUFBVSxFQUFFLFNBTE07QUFNbEJDLE9BQUssRUFBRSxTQU5XO0FBT2xCQyxTQUFPLEVBQUUsU0FQUztBQVFsQkMsUUFBTSxFQUFFLFNBUlU7QUFTbEI7QUFDQUMsT0FBSyxFQUFFLFVBVlc7QUFXbEJDLE9BQUssRUFBRSxVQVhXO0FBWWxCQyxLQUFHLEVBQUUsVUFaYTtBQWFsQkMsUUFBTSxFQUFFLFVBYlU7QUFjbEJDLE9BQUssRUFBRSxVQWRXO0FBZWxCQyxNQUFJLEVBQUUsVUFmWTtBQWdCbEJDLE1BQUksRUFBRSxVQWhCWTtBQWlCbEJDLFNBQU8sRUFBRSxVQWpCUztBQWtCbEI7QUFDQUMsU0FBTyxFQUFFLFVBbkJTO0FBb0JsQkMsT0FBSyxFQUFFLFVBcEJXO0FBcUJsQkMsVUFBUSxFQUFFLFVBckJRO0FBc0JsQkMsUUFBTSxFQUFFLFVBdEJVO0FBdUJsQkMsU0FBTyxFQUFFLFVBdkJTO0FBd0JsQkMsUUFBTSxFQUFFLFVBeEJVO0FBeUJsQkMsVUFBUSxFQUFFLFVBekJRO0FBMEJsQkMsU0FBTyxFQUFFLFVBMUJTO0FB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QUdBYSxXQUFPLENBQUNDLEdBQVIsQ0FBWSxHQUFHYSxLQUFmO0FBQ0QsR0FORDtBQU9BLE1BQUksQ0FBQ3hGLE9BQUwsRUFBYzBFLE9BQU8sQ0FBQ2UsUUFBUjtBQUNmLEMsQ0FFRDtBQUNBOzs7QUFDQUMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBQ2ZDLE1BQUksRUFBRXRGLFdBRFM7QUFFZnVGLEtBQUcsRUFBRXRELFVBRlU7QUFHZnVCLFdBSGU7QUFJZk8sb0JBSmU7QUFLZkksaUJBTGU7QUFNZkcsZ0JBTmU7QUFPZjlCO0FBUGUsQ0FBakIiLCJmaWxlIjoiLi9zcmMvdXRpbC9wcm9tcHRzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyovLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gQUJPVVQgXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCpcXFxuXG4gIEFOU0kgVEVSTUlOQUwgY29sb3IgY29kZXMgYW5kIHV0aWxpdGllc1xuXG5cXCpcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcICogLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyovXG5cbmNvbnN0IElTX05PREUgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbmNvbnN0IERFRkFVTFRfUEFERElORyA9IElTX05PREVcbiAgPyAxMCAvLyBub2RlanNcbiAgOiAwOyAvLyBub3Qgbm9kZWpzXG5jb25zdCBERUZBVUxUX0NPTE9SID0gJ1RhZ0dyYXknO1xuY29uc3QgQ1NTX1BBRCA9ICdwYWRkaW5nOjNweCA1cHg7Ym9yZGVyLXJhZGl1czoycHgnO1xuY29uc3QgQ1NTX1RBQiA9ICc0cHgnO1xuXG5jb25zdCBURVJNX0NPTE9SUyA9IHtcbiAgLy8gVE9VVCA9IG1ha2VUZXJtaW5hbE91dChzdHIpOyBUT1VUKCdoaScpXG4gIFJlc2V0OiAnXFx4MWJbMG0nLFxuICBCcmlnaHQ6ICdcXHgxYlsxbScsXG4gIERpbTogJ1xceDFiWzJtJyxcbiAgVW5kZXJzY29yZTogJ1xceDFiWzRtJyxcbiAgQmxpbms6ICdcXHgxYls1bScsXG4gIFJldmVyc2U6ICdcXHgxYls3bScsXG4gIEhpZGRlbjogJ1xceDFiWzhtJyxcbiAgLy9cbiAgQmxhY2s6ICdcXHgxYlszMG0nLFxuICBXaGl0ZTogJ1xceDFiWzM3bScsXG4gIFJlZDogJ1xceDFiWzMxbScsXG4gIFllbGxvdzogJ1xceDFiWzMzbScsXG4gIEdyZWVuOiAnXFx4MWJbMzJtJyxcbiAgQ3lhbjogJ1xceDFiWzM2bScsXG4gIEJsdWU6ICdcXHgxYlszNG0nLFxuICBNYWdlbnRhOiAnXFx4MWJbMzVtJyxcbiAgLy9cbiAgQmdCbGFjazogJ1xceDFiWzQwbScsXG4gIEJnUmVkOiAnXFx4MWJbNDFtJyxcbiAgQmdZZWxsb3c6ICdcXHgxYls0M20nLFxuICBCZ0N5YW46ICdcXHgxYls0Nm0nLFxuICBCZ0dyZWVuOiAnXFx4MWJbNDJtJyxcbiAgQmdCbHVlOiAnXFx4MWJbNDRtJyxcbiAgQmdQdXJwbGU6ICdcXHgxYls0NW0nLFxuICBCZ1doaXRlOiAnXFx4MWJbNDdtJyxcbiAgLy9cbiAgVGFnWWVsbG93OiAnXFx4MWJbNDM7MzBtJyxcbiAgVGFnUmVkOiAnXFx4MWJbNDE7MzdtJyxcbiAgVGFnR3JlZW46ICdcXHgxYls0MjszN20nLFxuICBUYWdDeWFuOiAnXFx4MWJbNDY7MzdtJyxcbiAgVGFnQmx1ZTogJ1xceDFiWzQzOzM3bScsXG4gIFRhZ1B1cnBsZTogJ1xceDFiWzQ1OzM3bScsXG4gIFRhZ1Bpbms6ICdcXHgxYls5NTszMG0nLFxuICBUYWdHcmF5OiAnXFx4MWJbMjszN20nLFxuICBUYWdOdWxsOiAnY29sb3I6Izk5OSdcbn07XG5cbi8vIE5BTUUgTElTVCBNVVNUIE1BVENIIFRFUk1fQ09MT1JTIVxuY29uc3QgQ1NTX0NPTE9SUyA9IHtcbiAgUmVzZXQ6ICdjb2xvcjphdXRvO2JhY2tncm91bmQtY29sb3I6YXV0bycsXG4gIC8vIENPTE9SIEZPUkVHUk9VTkRcbiAgQmxhY2s6ICdjb2xvcjpibGFjaycsXG4gIFdoaXRlOiAnY29sb3I6d2hpdGUnLFxuICBSZWQ6ICdjb2xvcjpyZWQnLFxuICBZZWxsb3c6ICdjb2xvcjpvcmFuZ2UnLFxuICBHcmVlbjogJ2NvbG9yOmdyZWVuJyxcbiAgQ3lhbjogJ2NvbG9yOmN5YW4nLFxuICBCbHVlOiAnY29sb3I6Ymx1ZScsXG4gIE1hZ2VudGE6ICdjb2xvcjptYWdlbnRhJyxcbiAgLy8gQ09MT1IgQkFDS0dST1VORFxuICBUYWdSZWQ6IGBjb2xvcjojMDAwO2JhY2tncm91bmQtY29sb3I6I2Y2Njske0NTU19QQUR9YCxcbiAgVGFnWWVsbG93OiBgY29sb3I6IzAwMDtiYWNrZ3JvdW5kLWNvbG9yOiNmZDQ7JHtDU1NfUEFEfWAsXG4gIFRhZ0dyZWVuOiBgY29sb3I6IzAwMDtiYWNrZ3JvdW5kLWNvbG9yOiM1Yzg7JHtDU1NfUEFEfWAsXG4gIFRhZ0N5YW46IGBjb2xvcjojMDAwO2JhY2tncm91bmQtY29sb3I6IzJkZDske0NTU19QQUR9YCxcbiAgVGFnQmx1ZTogYGNvbG9yOiMwMDA7YmFja2dyb3VuZC1jb2xvcjojMmJmOyR7Q1NTX1BBRH1gLFxuICBUYWdQdXJwbGU6IGBjb2xvcjojMDAwO2JhY2tncm91bmQtY29sb3I6I2I2Zjske0NTU19QQUR9YCxcbiAgVGFnUGluazogYGNvbG9yOiMwMDA7YmFja2dyb3VuZC1jb2xvcjojZjlmOyR7Q1NTX1BBRH1gLFxuICBUYWdHcmF5OiBgY29sb3I6Izk5OTtib3JkZXI6MXB4IHNvbGlkICNkZGQ7JHtDU1NfUEFEfWAsXG4gIFRhZ051bGw6ICdjb2xvcjojOTk5JyxcbiAgLy8gQ09MT1IgQkFDS0dST1VORCBEQVJLXG4gIFRhZ0RrUmVkOiBgY29sb3I6d2hpdGU7YmFja2dyb3VuZC1jb2xvcjpyZWQ7JHtDU1NfUEFEfWAsXG4gIFRhZ0RrR3JlZW46IGBjb2xvcjp3aGl0ZTtiYWNrZ3JvdW5kLWNvbG9yOmdyZWVuOyR7Q1NTX1BBRH1gLFxuICBUYWdEa0JsdWU6IGBjb2xvcjp3aGl0ZTtiYWNrZ3JvdW5kLWNvbG9yOmJsdWU7JHtDU1NfUEFEfWBcbn07XG5cbi8vLyBPVVRQVVQgQ09OVFJPTCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBkZWZpbmVcbiAqL1xuY29uc3QgU0hPVyA9IHRydWU7XG5jb25zdCBISURFID0gZmFsc2U7XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5jb25zdCBQUk9NUFRfRElDVCA9IHtcbiAgLy8gVVJTWVMtUkVMQVRFRCBNT0RVTEVTXG4gICdVUic6IFtTSE9XLCAnVGFnUmVkJ10sXG4gIC8vIFNFUlZFUlNcbiAgJ0FQUFNSVic6IFtTSE9XLCAnWWVsbG93J10sXG4gICdHRU1TUlYnOiBbU0hPVywgJ1llbGxvdyddLFxuICAvLyBTUEVDSUFMXG4gICctJzogW1NIT1csICdUYWdOdWxsJ11cbn07XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogYWRkIGEgY29sb3IgdG8gdGhlIFBST01QVF9ESUNUIGZvciBhIHBhcnRpY3VsYXIgUFJFRklYICovXG5mdW5jdGlvbiBtX1NldFByb21wdENvbG9ycyhtYXRjaCwgY29sb3IgPSBERUZBVUxUX0NPTE9SKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggIT09ICdzdHJpbmcnKSB0aHJvdyBFcnJvcignbWF0Y2ggcHJvbXB0IG11c3QgYmUgc3RyaW5nJyk7XG4gIG1hdGNoID0gbWF0Y2gudHJpbSgpO1xuICBpZiAobWF0Y2ggPT09ICcnKSB0aHJvdyBFcnJvcignbWF0Y2ggcHJvbXB0IGNhbm5vdCBiZSBlbXB0eScpO1xuICBsZXQgY29sb3JUYWJsZSA9IElTX05PREUgPyBURVJNX0NPTE9SUyA6IENTU19DT0xPUlM7XG4gIGxldCB2YWxpZENvbG9yID0gZmFsc2U7XG4gIHZhbGlkQ29sb3IgPSBjb2xvclRhYmxlW2NvbG9yXSAhPT0gdW5kZWZpbmVkO1xuICBpZiAoIXZhbGlkQ29sb3IpIHRocm93IEVycm9yKGBwcm9tcHQgY29sb3IgJHtjb2xvcn0gaXMgbm90IGRlZmluZWRgKTtcbiAgLy8gdHVybiBvbiBjb2xvciBwcm9tcHRcbiAgUFJPTVBUX0RJQ1RbbWF0Y2hdID0gW3RydWUsIGNvbG9yXTtcbiAgcmV0dXJuIGNvbG9yVGFibGU7XG59XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogQmFzZWQgb24gY3VycmVudCBkZXRlY3RlZCBlbnZpcm9tZW50LCByZXR1cm4gZWl0aGVyIEFOU0kgdGVybWluYWwgb3JcbiAqICBjc3MgYmFzZWQgY29sb3IgbWFya2VycyBmb3IgdXNlIGluIGRlYnVnZ2luZyBtZXNzYWdlcy4gSWYgdGFnQ29sb3IgaXNcbiAqICBkZWZpbmVkIGFuZCBjb3JyZXNwb25kcyB0byBjb2xvciBkZWZpbml0aW9uLCBpdCBpcyB1c2VkIHRvIHNldCB0aGUgY29sb3IuXG4gKiAgVGhpcyBpcyBzbyB1c2VycyBjYW4gc2V0IHRoZWlyIG93biBjb2xvciBwcm9tcHRzIHdpdGhvdXQgZWRpdGluZ1xuICogIFBST01QVFNfRElDVCBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG1fR2V0RW52Q29sb3IocHJvbXB0LCB0YWdDb2xvcikge1xuICBjb25zdCBjb2xvclRhYmxlID0gbV9TZXRQcm9tcHRDb2xvcnMocHJvbXB0LCB0YWdDb2xvcik7XG4gIGNvbnN0IFtkYmdfbW9kZSwgZGVmY29sXSA9IFBST01QVF9ESUNUW3Byb21wdC50cmltKCldIHx8IFtTSE9XLCBERUZBVUxUX0NPTE9SXTtcbiAgY29uc3QgdWNvbG9yID0gY29sb3JUYWJsZVt0YWdDb2xvcl07XG4gIGNvbnN0IGRjb2xvciA9IGNvbG9yVGFibGVbZGVmY29sXTtcbiAgY29uc3QgY29sb3IgPSB1Y29sb3IgfHwgZGNvbG9yO1xuICBjb25zdCByZXNldCA9IGNvbG9yVGFibGUuUmVzZXQ7XG4gIHJldHVybiBbZGJnX21vZGUsIGNvbG9yLCByZXNldF07XG59XG5cbi8vLyBBUEkgTUVUSE9EUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBQYWQgc3RyaW5nIHRvIGZpeGVkIGxlbmd0aCwgd2l0aCBkZWZhdWx0IHBhZGRpbmcgZGVwZW5kaW5nIG9uXG4gKiAgd2hldGhlciB0aGUgZW52aXJvbm1lbnQgaXMgbm9kZSBvciBicm93c2VyXG4gKi9cbmZ1bmN0aW9uIHBhZFN0cmluZyhzdHIsIHBhZGRpbmcgPSBERUZBVUxUX1BBRERJTkcpIHtcbiAgbGV0IGxlbiA9IHN0ci5sZW5ndGg7XG4gIGlmIChJU19OT0RFKSByZXR1cm4gYCR7c3RyLnBhZEVuZChwYWRkaW5nLCAnICcpfWA7XG4gIC8vIG11c3QgYmUgbm9uLW5vZGUgZW52aXJvbm1lbnQsIHNvIGRvIGR5bmFtaWMgc3RyaW5nIGFkanVzdFxuICBpZiAocGFkZGluZyA9PT0gMCkgcmV0dXJuIGAke3N0cn1gO1xuICAvLyBpZiB0aGlzIGZhciwgdGhlbiB3ZSdyZSB0cnVuY2F0aW5nXG4gIGlmIChsZW4gPj0gcGFkZGluZykgc3RyID0gc3RyLnN1YnN0cigwLCBwYWRkaW5nIC0gMSk7XG4gIGVsc2Ugc3RyLnBhZEVuZChwYWRkaW5nLCAnICcpO1xuICByZXR1cm4gYCR7c3RyfWA7XG59XG5cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJvbXB0IHN0cmluZ3MgZm9yIHlvdS4gVGhlIGZ1bmN0aW9uIHdpbGxcbiAqICByZXR1cm5zIGFuIGFycmF5IHRvIGRlc3RydWN0dXJlIGludG8gY29uc29sZS5sb2coKS5cbiAqXG4gKiAgVG8gY3JlYXRlIHRoZSBmdW5jdGlvbiwgcHJvdmlkZSBhIHNob3J0IFBST01QVC4gVGhpcyB3aWxsIGJlIGNvbG9yIGNvZGVkXG4gKiAgYWNjb3JkaW5nIHRvIHRoZSBQUk9NUFRTX0RJQ1QgdGFibGUsIG9yIGdyYXkgb3RoZXJ3aXNlLiBZb3UgY2FuIHR1cm4gb2ZmIHRoZVxuICogIGRlYnVnIG91dHB1dCBmb3IgYWxsIFBST01QVFMgaW4gYSBjYXRlZ29yeSBhbHNvIGZvciBjZW50cmFsaXplZCBkZWJ1Z1xuICogIHN0YXRlbWVudCBjb250cm9sLlxuICpcbiAqICBUaGUgcHJvbXB0IGZ1bmN0aW9uIGFjY2VwdHMgYSBzdHJpbmcgZm9sbG93ZWQgYnkgYW55IG51bWJlciBvZiBwYXJhbWV0ZXJzLlxuICogIEl0IHJldHVybnMgYW4gYXJyYXkgb2YgdmFsdWVzIHRoYXQgYXJlIGRlc3RydWN0dXJlZCBpbnNpZGUgb2YgY29uc29sZS5sb2coKVxuICogICAgY29uc3QgcHJvbXB0RnVuY3Rpb24gPSBtYWtlTG9naW5IZWxwZXIoJ0FQUCcpO1xuICogICAgY29uc29sZS5sb2coLi4ucHJvbXB0RnVuY3Rpb24oJ2h1enphaCcpKTtcbiAqXG4gKiAgTk9URTogVGhpcyBkb2Vzbid0IHdvcmsgYXMgZXhwZWN0ZWQgb24gTm9kZUpTLCBiZWNhdXNlIGVtcHR5IGFycmF5c1xuICogIHJlbmRlciBhcyBsaW5lZmVlZHMgc28gd2UganVzdCBvdXRwdXQgaXQgcmVnYXJkbGVzcy4gSWYgeW91IHdhbnQgdG9cbiAqICBkaXNhYmxlIG91dHB1dCwgdXNlIHRoZSBtYWtlVGVybWluYWxPdXQoKSBmdW5jdGlvbiBpbnN0ZWFkLlxuICovXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKiogYWxsb3cgbW9kaWZpY2F0aW9uIG9mIHRoZSBQUk9NUFRfRElDVFxuICovXG5mdW5jdGlvbiBtYWtlU3R5bGVGb3JtYXR0ZXIocHJvbXB0LCB0YWdDb2xvcikge1xuICBjb25zdCBbZGJnLCBjb2xvciwgcmVzZXRdID0gbV9HZXRFbnZDb2xvcihwcm9tcHQsIHRhZ0NvbG9yKTtcbiAgLy8gcmV0dXJuIGVtcHR5IGFycmF5IGlmIGRlYnVnZ2luZyBkaXNhYmxlZCBpbiBicm93c2VyXG4gIC8vIG9yIGRlYnVnZ2luZyBpcyBlbmFibGVkIGJ1dCBpdCdzIG5vZGUgKGRlIG1vcmdhbidzIGxhdylcbiAgaWYgKCEoZGJnIHx8IElTX05PREUpKSByZXR1cm4gKCkgPT4gW107XG4gIC8vIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgYXJyYXkgdG8gZGVjb25zdHJ1Y3RyXG4gIGNvbnN0IHdyYXAgPSBJU19OT0RFXG4gICAgPyAoc3RyLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIHJldHVybiBbYCR7Y29sb3J9JHtwYWRTdHJpbmcocHJvbXB0KX0ke3Jlc2V0fSAgICR7c3RyfWAsIC4uLmFyZ3NdOyAvLyBzZXJ2ZXJcbiAgICAgIH1cbiAgICA6IChzdHIsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgcmV0dXJuIFtgJWMke3BhZFN0cmluZyhwcm9tcHQpfSVjICR7c3RyfWAsIGNvbG9yLCByZXNldCwgLi4uYXJnc107IC8vIGJyb3dzZXJcbiAgICAgIH07XG4gIHJldHVybiB3cmFwO1xufVxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIEZ1bmN0aW9uIHRvIGRpcmVjdGx5IHByaW50IHRvIGNvbnNvbGUgaW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gYXJyYXkuIFRoaXNcbiAqICB3b3JrcyBiZXR0ZXIgZm9yIE5vZGVKUyBzaW5jZSB0aGUgZW1wdHkgW10gc3RpbGwgcmVzdWx0cyBpbiBvdXRwdXQgdW5saWtlXG4gKiAgdGhlIGJyb3dzZXIuIFVzZSBtYWtlU3R5bGVGb3JtYXR0ZXIgZm9yIGJyb3dzZXJzXG4gKi9cbmZ1bmN0aW9uIG1ha2VUZXJtaW5hbE91dChwcm9tcHQsIHRhZ0NvbG9yKSB7XG4gIGNvbnN0IFtkYmcsIGNvbG9yLCByZXNldF0gPSBtX0dldEVudkNvbG9yKHByb21wdCwgdGFnQ29sb3IpO1xuICBpZiAoIWRiZykgcmV0dXJuICgpID0+IHt9O1xuICBjb25zdCB3cmFwID0gSVNfTk9ERVxuICAgID8gKHN0ciwgLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhgJHtjb2xvcn0ke3BhZFN0cmluZyhwcm9tcHQpfSR7cmVzZXR9IC0gJHtzdHJ9YCwgLi4uYXJncyk7XG4gICAgICB9XG4gICAgOiAoc3RyLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAlYyR7cGFkU3RyaW5nKHByb21wdCl9JWMgJHtzdHJ9YCwgY29sb3IsIHJlc2V0LCAuLi5hcmdzKTtcbiAgICAgIH07XG4gIHJldHVybiB3cmFwO1xufVxuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqIFByaW50IGFsbCBUYWcgQ29sb3JzXG4gKi9cbmZ1bmN0aW9uIHByaW50VGFnQ29sb3JzKCkge1xuICBjb25zdCBjb2xvcnRhYmxlID0gSVNfTk9ERSA/IFRFUk1fQ09MT1JTIDogQ1NTX0NPTE9SUztcbiAgY29uc3QgY29sb3JzID0gT2JqZWN0LmtleXMoY29sb3J0YWJsZSkuZmlsdGVyKGVsZW1lbnQgPT5cbiAgICBlbGVtZW50LmluY2x1ZGVzKCdUYWcnKVxuICApO1xuICBjb25zdCByZXNldCA9IGNvbG9ydGFibGUuUmVzZXQ7XG4gIGNvbnN0IG91dCA9ICdkYmdfY29sb3JzJztcbiAgaWYgKCFJU19OT0RFKSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKG91dCk7XG4gIGNvbG9ycy5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3QgY29sb3IgPSBjb2xvcnRhYmxlW2tleV07XG4gICAgY29uc3QgaXRlbXMgPSBJU19OT0RFXG4gICAgICA/IFtgJHtwYWRTdHJpbmcob3V0KX0gLSAobm9kZSkgJHtjb2xvcn0ke2tleX0ke3Jlc2V0fWBdXG4gICAgICA6IFtgKGJyb3dzZXIpICVjJHtrZXl9JWNgLCBjb2xvciwgcmVzZXRdO1xuICAgIGNvbnNvbGUubG9nKC4uLml0ZW1zKTtcbiAgfSk7XG4gIGlmICghSVNfTk9ERSkgY29uc29sZS5ncm91cEVuZCgpO1xufVxuXG4vLy8gTU9EVUxFIEVYUE9SVFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVEVSTTogVEVSTV9DT0xPUlMsXG4gIENTUzogQ1NTX0NPTE9SUyxcbiAgcGFkU3RyaW5nLFxuICBtYWtlU3R5bGVGb3JtYXR0ZXIsXG4gIG1ha2VUZXJtaW5hbE91dCxcbiAgcHJpbnRUYWdDb2xvcnMsXG4gIG1fU2V0UHJvbXB0Q29sb3JzXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/util/prompts.js\n");

/***/ }),

/***/ "./src/util/session.js":
/*!*****************************!*\
  !*** ./src/util/session.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable @typescript-eslint/no-use-before-define */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/* eslint-disable no-param-reassign */\n\n/*//////////////////////////////// ABOUT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\n\n  Session Utilities\n  collection of session-related data structures\n\n  For student logins, we just need to encode the groupId, which will give\n  us the classroomId. We also need the name, which is not encoded, but\n  can be checked against the groups database.\n\n  <NAME>-HASHED_DATA\n  where HASHED_DATA encodes groupId, classroomId\n\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ * //////////////////////////////////////*/\n/// SYSTEM LIBRARIES //////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nconst HashIds = __webpack_require__(/*! hashids/cjs */ \"../../node_modules/hashids/cjs/index.js\");\n\nconst UUID = __webpack_require__(/*! uuid */ \"../../node_modules/uuid/dist/esm-node/index.js\");\n\nconst UUIDv5 = UUID.v5;\n\nconst PROMPTS = __webpack_require__(/*! ./prompts */ \"./src/util/prompts.js\"); /// DEBUGGING /////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nconst DBG = false;\nconst PR = PROMPTS.makeStyleFormatter('XSES'); /// CONSTANTS /////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n/// HASH_* are used as parameters for hashids (login tokens)\n\nconst HASH_ABET = 'ABCDEFGHIJKLMNPQRSTVWXYZ23456789';\nconst HASH_MINLEN = 3;\nconst HASH_SALT = 'MEMESALT/2019'; /// UUID_NAMESPACE was arbitrarily generated with 'npx uuid v4' (access keys)\n\nconst UUID_NAMESPACE = '1abc839d-b04f-481e-87fe-5d69bd1907b2';\nlet ADMIN_KEY = ''; // set to non-falsy to disable admin checks\n\nconst ADMIN_QSTRING = 'danishpowers'; // used to bypass admin localhost test\n\nconst SSHOT_URL = '/screenshots';\nconst UPLOAD_URL = `${SSHOT_URL}/upload`; /// MODULE DECLARATIONS ///////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nlet m_current_name; // global decoded name (only for browsers)\n\nlet m_current_idsobj = {}; // global decoded props (only for browsers)\n\nlet m_access_key = ''; // global access key (saved only for browsers)\n/// SESSION ///////////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nconst SESSION = {}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/*/ Given a token of form NAME-HASHED_DATA, return an object\n    containing as many decoded values as possible. Check isValid for\n    complete decode succes. groupId is also set if successful\n/*/\n\nSESSION.DecodeToken = hashedToken => {\n  let studentName;\n  let hashedData; // token\n\n  let groupId;\n  let classroomId; // decoded data\n\n  let isValid = false; // is a valid token?\n\n  if (typeof hashedToken !== 'string') return {\n    isValid,\n    error: 'token must be a string'\n  }; // token is of form NAME-HASHEDID\n  // (1) check student name\n\n  const token = hashedToken.toUpperCase();\n  const tokenBits = token.toUpperCase().split('-');\n  if (tokenBits.length === 1) return {\n    isValid,\n    token,\n    error: 'missing - in token'\n  };\n  if (tokenBits.length > 2) return {\n    isValid,\n    token,\n    error: 'too many - in token'\n  };\n  if (tokenBits[0]) studentName = tokenBits[0].toUpperCase();\n  if (studentName.length < 3) return {\n    isValid,\n    token,\n    error: 'student name must have 3 or more letters'\n  }; // (2) check hashed data\n\n  if (tokenBits[1]) hashedData = tokenBits[1].toUpperCase(); // initialize hashid structure\n\n  let hashids = new HashIds(HASH_SALT + studentName, HASH_MINLEN, HASH_ABET); // try to decode the groupId\n\n  const dataIds = hashids.decode(hashedData); // invalidate if couldn't decode\n\n  if (dataIds.length === 0) return {\n    isValid,\n    token,\n    error: 'invalid token'\n  }; // at this point groupId is valid (begins with ID, all numeric)\n  // check for valid subgroupId\n\n  [groupId, classroomId] = dataIds;\n  isValid = true;\n  return {\n    isValid,\n    studentName,\n    token,\n    groupId,\n    classroomId\n  };\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/*/ Return TRUE if the token decodes into an expected range of values\n/*/\n\n\nSESSION.IsValidToken = token => {\n  let decoded = SESSION.DecodeToken(token);\n  return decoded && Number.isInteger(decoded.groupId) && typeof decoded.studentName === 'string';\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/**\n * Returns a token string of form NAME-HASHED_DATA\n * @param {String} studentName\n * @param {Object} dataIds\n * @param {Number} dataIds.groupId\n * @param {Number} dataIds.classroomId\n */\n\n\nSESSION.MakeToken = (studentName, dataIds = {}) => {\n  // type checking\n  if (typeof studentName !== 'string') throw Error(`classId arg1 '${studentName}' must be string`);\n  let err; // eslint-disable-next-line no-cond-assign\n\n  if (err = f_checkIdValue(dataIds)) {\n    console.warn(`Could not make token. ${err}`);\n    return undefined;\n  } // initialize hashid structure\n\n\n  studentName = studentName.toUpperCase();\n  const {\n    groupId,\n    classroomId\n  } = dataIds;\n  let hashids = new HashIds(HASH_SALT + studentName, HASH_MINLEN, HASH_ABET);\n  let hashedId = hashids.encode(groupId, classroomId);\n  return `${studentName}-${hashedId}`;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/**\n * Returns a token string of form NAME-HASHED_DATA\n * @param {String} teacherName\n * @param {Object} dataIds\n * @param {Number} dataIds.groupId\n * @param {Number} dataIds.teacherId\n */\n\n\nSESSION.MakeTeacherToken = (teacherName, dataIds = {}) => {\n  // type checking\n  if (typeof teacherName !== 'string') throw Error(`classId arg1 '${teacherName}' must be string`);\n  let err; // eslint-disable-next-line no-cond-assign\n\n  if (err = f_checkIdValue(dataIds)) {\n    console.warn(`Could not make token. ${err}`);\n    return undefined;\n  } // convert to alphanumeric no spaces\n\n\n  const tokName = teacherName.replace(/\\W/g, ''); // initialize hashid structure\n\n  teacherName = tokName.toUpperCase();\n  const {\n    groupId,\n    teacherId\n  } = dataIds;\n  let hashids = new HashIds(HASH_SALT + teacherName, HASH_MINLEN, HASH_ABET);\n  let hashedId = hashids.encode(groupId, teacherId);\n  return `${teacherName}-${hashedId}`;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n/// support function\n\n\nfunction f_checkIdValue(idsObj) {\n  const ids = Object.keys(idsObj);\n  let error = '';\n  ids.forEach(key => {\n    const val = idsObj[key];\n\n    if (!Number.isInteger(val)) {\n      error += `'${key}' is not an integer. `;\n      return;\n    }\n\n    if (val < 0) {\n      error += `'${key}' must be non-negative integer. `;\n      return;\n    }\n\n    if (val > Number.MAX_SAFE_INTEGER) {\n      error += `'${key}' exceeds MAX_SAFE_INTEGER. `;\n    }\n  });\n  return error;\n} /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/** Makes a 'access key' that is not very secure, but unique enough to serve\n * as an authentication key based on a login token\n * @param {...*} var_args - string arguments\n */\n\n\nSESSION.MakeAccessKey = (...args) => {\n  const name = [...args].join(':');\n  const key = UUIDv5(name, UUID_NAMESPACE);\n  return key;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/**\n * Set the global GROUPID, which is included in all NetPacket objects that are\n * sent to server. Do not use from server-based code.\n */\n\n\nSESSION.DecodeAndSet = token => {\n  const decoded = SESSION.DecodeToken(token);\n  const {\n    isValid,\n    studentName,\n    groupId,\n    classroomId\n  } = decoded;\n\n  if (isValid) {\n    m_current_name = studentName;\n    m_current_idsobj = {\n      studentName,\n      groupId,\n      classroomId\n    }; // handle teacher login\n    // in this case, the groupId is 0 and classroomId is actually\n    // teacherId, so update the object\n\n    if (groupId === 0) {\n      console.warn(`INFO: TEACHER LOGIN '${studentName}'`);\n      m_current_idsobj.teacherId = classroomId;\n      m_current_idsobj.teacherName = studentName;\n      m_current_idsobj.classroomId = undefined;\n    }\n\n    if (DBG) console.log('DecodeAndSet() success', studentName, groupId, classroomId);\n  } else if (DBG) console.log('DecodeAndSet() failed', token);\n\n  return isValid;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/**\n * Clear all global session parameters. Do not use from server-based code.\n */\n\n\nSESSION.Clear = () => {\n  if (DBG) console.log('Clearing session');\n  m_current_name = undefined;\n  m_current_idsobj = undefined;\n  m_access_key = undefined;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/**\n * Set the global SESSION ACCESS KEY, which is necessary as a parameter for\n * some operations (e.g. database writes). Do not use from server-based code.\n */\n\n\nSESSION.SetAccessKey = key => {\n  if (typeof key === 'string') {\n    m_access_key = key;\n    if (DBG) console.log('setting access key', key);\n  }\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/**\n * Return the global SESSION ACCESS KEY that was set using SetAccessKey(). Don't\n * use this from server-based code.\n */\n\n\nSESSION.AccessKey = () => {\n  if (DBG) console.log('AccessKey() returning', m_access_key);\n  return m_access_key;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nSESSION.SetAdminKey = key => {\n  ADMIN_KEY = key || ADMIN_KEY;\n  return ADMIN_KEY;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/**\n * This is TOTALLY INSECURE and not even trying for the prototype\n */\n\n\nSESSION.AdminKey = () => {\n  const is = ADMIN_KEY || false;\n  if (DBG) console.warn('INFO: requested AdminKey()');\n  return is;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/**\n * Return teacherId if this is a logged-in teacher\n */\n\n\nSESSION.LoggedInProps = () => {\n  const {\n    groupId,\n    classroomId,\n    teacherId\n  } = m_current_idsobj;\n\n  if (groupId === 0) {\n    return {\n      teacherName: m_current_name,\n      teacherId\n    };\n  }\n\n  return {\n    studentName: m_current_name,\n    groupId,\n    classroomId\n  };\n};\n\nSESSION.IsStudent = () => {\n  return SESSION.LoggedInProps().studentName !== undefined;\n};\n\nSESSION.IsTeacher = () => {\n  return SESSION.LoggedInProps().teacherName !== undefined;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/**\n * Return the global LoggedInName that was set using DecodeAndSet(). Don't use\n * this from server-based code.\n */\n\n\nSESSION.LoggedInName = () => {\n  return m_current_name;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n/**\n * Return the global idsObject containing groupId, classroomId that was set\n * using DecodeAndSet(). Don't use this from server-based code.\n */\n\n\nSESSION.Ids = () => {\n  return m_current_idsobj;\n}; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nSESSION.AdminPlaintextPassphrase = () => ADMIN_QSTRING; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nSESSION.ScreenshotURL = () => SSHOT_URL;\n\nSESSION.ScreenshotPostURL = () => UPLOAD_URL; /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n/// EXPORT MODULE /////////////////////////////////////////////////////////////\n/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nmodule.exports = SESSION;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9zZXNzaW9uLmpzP2IyNjMiXSwibmFtZXMiOlsiSGFzaElkcyIsInJlcXVpcmUiLCJVVUlEIiwiVVVJRHY1IiwidjUiLCJQUk9NUFRTIiwiREJHIiwiUFIiLCJtYWtlU3R5bGVGb3JtYXR0ZXIiLCJIQVNIX0FCRVQiLCJIQVNIX01JTkxFTiIsIkhBU0hfU0FMVCIsIlVVSURfTkFNRVNQQUNFIiwiQURNSU5fS0VZIiwiQURNSU5fUVNUUklORyIsIlNTSE9UX1VSTCIsIlVQTE9BRF9VUkwiLCJtX2N1cnJlbnRfbmFtZSIsIm1fY3VycmVudF9pZHNvYmoiLCJtX2FjY2Vzc19rZXkiLCJTRVNTSU9OIiwiRGVjb2RlVG9rZW4iLCJoYXNoZWRUb2tlbiIsInN0dWRlbnROYW1lIiwiaGFzaGVkRGF0YSIsImdyb3VwSWQiLCJjbGFzc3Jvb21JZCIsImlzVmFsaWQiLCJlcnJvciIsInRva2VuIiwidG9VcHBlckNhc2UiLCJ0b2tlbkJpdHMiLCJzcGxpdCIsImxlbmd0aCIsImhhc2hpZHMiLCJkYXRhSWRzIiwiZGVjb2RlIiwiSXNWYWxpZFRva2VuIiwiZGVjb2RlZCIsIk51bWJlciIsImlzSW50ZWdlciIsIk1ha2VUb2tlbiIsIkVycm9yIiwiZXJyIiwiZl9jaGVja0lkVmFsdWUiLCJjb25zb2xlIiwid2FybiIsInVuZGVmaW5lZCIsImhhc2hlZElkIiwiZW5jb2RlIiwiTWFrZVRlYWNoZXJUb2tlbiIsInRlYWNoZXJOYW1lIiwidG9rTmFtZSIsInJlcGxhY2UiLCJ0ZWFjaGVySWQiLCJpZHNPYmoiLCJpZHMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsInZhbCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJNYWtlQWNjZXNzS2V5IiwiYXJncyIsIm5hbWUiLCJqb2luIiwiRGVjb2RlQW5kU2V0IiwibG9nIiwiQ2xlYXIiLCJTZXRBY2Nlc3NLZXkiLCJBY2Nlc3NLZXkiLCJTZXRBZG1pbktleSIsIkFkbWluS2V5IiwiaXMiLCJMb2dnZWRJblByb3BzIiwiSXNTdHVkZW50IiwiSXNUZWFjaGVyIiwiTG9nZ2VkSW5OYW1lIiwiSWRzIiwiQWRtaW5QbGFpbnRleHRQYXNzcGhyYXNlIiwiU2NyZWVuc2hvdFVSTCIsIlNjcmVlbnNob3RQb3N0VVJMIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0EsTUFBTUEsT0FBTyxHQUFHQyxtQkFBTyxDQUFDLDREQUFELENBQXZCOztBQUNBLE1BQU1DLElBQUksR0FBR0QsbUJBQU8sQ0FBQyw0REFBRCxDQUFwQjs7QUFFQSxNQUFNRSxNQUFNLEdBQUdELElBQUksQ0FBQ0UsRUFBcEI7O0FBQ0EsTUFBTUMsT0FBTyxHQUFHSixtQkFBTyxDQUFDLHdDQUFELENBQXZCLEMsQ0FFQTtBQUNBOzs7QUFDQSxNQUFNSyxHQUFHLEdBQUcsS0FBWjtBQUNBLE1BQU1DLEVBQUUsR0FBR0YsT0FBTyxDQUFDRyxrQkFBUixDQUEyQixNQUEzQixDQUFYLEMsQ0FFQTtBQUNBO0FBQ0E7O0FBQ0EsTUFBTUMsU0FBUyxHQUFHLGtDQUFsQjtBQUNBLE1BQU1DLFdBQVcsR0FBRyxDQUFwQjtBQUNBLE1BQU1DLFNBQVMsR0FBRyxlQUFsQixDLENBQ0E7O0FBQ0EsTUFBTUMsY0FBYyxHQUFHLHNDQUF2QjtBQUNBLElBQUlDLFNBQVMsR0FBRyxFQUFoQixDLENBQW9COztBQUNwQixNQUFNQyxhQUFhLEdBQUcsY0FBdEIsQyxDQUFzQzs7QUFDdEMsTUFBTUMsU0FBUyxHQUFHLGNBQWxCO0FBQ0EsTUFBTUMsVUFBVSxHQUFJLEdBQUVELFNBQVUsU0FBaEMsQyxDQUVBO0FBQ0E7O0FBQ0EsSUFBSUUsY0FBSixDLENBQW9COztBQUNwQixJQUFJQyxnQkFBZ0IsR0FBRyxFQUF2QixDLENBQTJCOztBQUMzQixJQUFJQyxZQUFZLEdBQUcsRUFBbkIsQyxDQUF1QjtBQUV2QjtBQUNBOztBQUNBLE1BQU1DLE9BQU8sR0FBRyxFQUFoQixDLENBQ0E7O0FBQ0E7Ozs7O0FBSUFBLE9BQU8sQ0FBQ0MsV0FBUixHQUFzQkMsV0FBVyxJQUFJO0FBQ25DLE1BQUlDLFdBQUo7QUFDQSxNQUFJQyxVQUFKLENBRm1DLENBRW5COztBQUNoQixNQUFJQyxPQUFKO0FBQ0EsTUFBSUMsV0FBSixDQUptQyxDQUlsQjs7QUFDakIsTUFBSUMsT0FBTyxHQUFHLEtBQWQsQ0FMbUMsQ0FNbkM7O0FBQ0EsTUFBSSxPQUFPTCxXQUFQLEtBQXVCLFFBQTNCLEVBQ0UsT0FBTztBQUFFSyxXQUFGO0FBQVdDLFNBQUssRUFBRTtBQUFsQixHQUFQLENBUmlDLENBU25DO0FBQ0E7O0FBQ0EsUUFBTUMsS0FBSyxHQUFHUCxXQUFXLENBQUNRLFdBQVosRUFBZDtBQUNBLFFBQU1DLFNBQVMsR0FBR0YsS0FBSyxDQUFDQyxXQUFOLEdBQW9CRSxLQUFwQixDQUEwQixHQUExQixDQUFsQjtBQUNBLE1BQUlELFNBQVMsQ0FBQ0UsTUFBVixLQUFxQixDQUF6QixFQUNFLE9BQU87QUFBRU4sV0FBRjtBQUFXRSxTQUFYO0FBQWtCRCxTQUFLLEVBQUU7QUFBekIsR0FBUDtBQUNGLE1BQUlHLFNBQVMsQ0FBQ0UsTUFBVixHQUFtQixDQUF2QixFQUNFLE9BQU87QUFBRU4sV0FBRjtBQUFXRSxTQUFYO0FBQWtCRCxTQUFLLEVBQUU7QUFBekIsR0FBUDtBQUNGLE1BQUlHLFNBQVMsQ0FBQyxDQUFELENBQWIsRUFBa0JSLFdBQVcsR0FBR1EsU0FBUyxDQUFDLENBQUQsQ0FBVCxDQUFhRCxXQUFiLEVBQWQ7QUFDbEIsTUFBSVAsV0FBVyxDQUFDVSxNQUFaLEdBQXFCLENBQXpCLEVBQ0UsT0FBTztBQUFFTixXQUFGO0FBQVdFLFNBQVg7QUFBa0JELFNBQUssRUFBRTtBQUF6QixHQUFQLENBbkJpQyxDQXFCbkM7O0FBQ0EsTUFBSUcsU0FBUyxDQUFDLENBQUQsQ0FBYixFQUFrQlAsVUFBVSxHQUFHTyxTQUFTLENBQUMsQ0FBRCxDQUFULENBQWFELFdBQWIsRUFBYixDQXRCaUIsQ0F1Qm5DOztBQUNBLE1BQUlJLE9BQU8sR0FBRyxJQUFJbEMsT0FBSixDQUFZVyxTQUFTLEdBQUdZLFdBQXhCLEVBQXFDYixXQUFyQyxFQUFrREQsU0FBbEQsQ0FBZCxDQXhCbUMsQ0F5Qm5DOztBQUNBLFFBQU0wQixPQUFPLEdBQUdELE9BQU8sQ0FBQ0UsTUFBUixDQUFlWixVQUFmLENBQWhCLENBMUJtQyxDQTJCbkM7O0FBQ0EsTUFBSVcsT0FBTyxDQUFDRixNQUFSLEtBQW1CLENBQXZCLEVBQTBCLE9BQU87QUFBRU4sV0FBRjtBQUFXRSxTQUFYO0FBQWtCRCxTQUFLLEVBQUU7QUFBekIsR0FBUCxDQTVCUyxDQThCbkM7QUFDQTs7QUFDQSxHQUFDSCxPQUFELEVBQVVDLFdBQVYsSUFBeUJTLE9BQXpCO0FBQ0FSLFNBQU8sR0FBRyxJQUFWO0FBQ0EsU0FBTztBQUFFQSxXQUFGO0FBQVdKLGVBQVg7QUFBd0JNLFNBQXhCO0FBQStCSixXQUEvQjtBQUF3Q0M7QUFBeEMsR0FBUDtBQUNELENBbkNELEMsQ0FvQ0E7O0FBQ0E7Ozs7QUFFQU4sT0FBTyxDQUFDaUIsWUFBUixHQUF1QlIsS0FBSyxJQUFJO0FBQzlCLE1BQUlTLE9BQU8sR0FBR2xCLE9BQU8sQ0FBQ0MsV0FBUixDQUFvQlEsS0FBcEIsQ0FBZDtBQUNBLFNBQ0VTLE9BQU8sSUFDUEMsTUFBTSxDQUFDQyxTQUFQLENBQWlCRixPQUFPLENBQUNiLE9BQXpCLENBREEsSUFFQSxPQUFPYSxPQUFPLENBQUNmLFdBQWYsS0FBK0IsUUFIakM7QUFLRCxDQVBELEMsQ0FRQTs7QUFDQTs7Ozs7Ozs7O0FBT0FILE9BQU8sQ0FBQ3FCLFNBQVIsR0FBb0IsQ0FBQ2xCLFdBQUQsRUFBY1ksT0FBTyxHQUFHLEVBQXhCLEtBQStCO0FBQ2pEO0FBQ0EsTUFBSSxPQUFPWixXQUFQLEtBQXVCLFFBQTNCLEVBQ0UsTUFBTW1CLEtBQUssQ0FBRSxpQkFBZ0JuQixXQUFZLGtCQUE5QixDQUFYO0FBQ0YsTUFBSW9CLEdBQUosQ0FKaUQsQ0FLakQ7O0FBQ0EsTUFBS0EsR0FBRyxHQUFHQyxjQUFjLENBQUNULE9BQUQsQ0FBekIsRUFBcUM7QUFDbkNVLFdBQU8sQ0FBQ0MsSUFBUixDQUFjLHlCQUF3QkgsR0FBSSxFQUExQztBQUNBLFdBQU9JLFNBQVA7QUFDRCxHQVRnRCxDQVdqRDs7O0FBQ0F4QixhQUFXLEdBQUdBLFdBQVcsQ0FBQ08sV0FBWixFQUFkO0FBQ0EsUUFBTTtBQUFFTCxXQUFGO0FBQVdDO0FBQVgsTUFBMkJTLE9BQWpDO0FBQ0EsTUFBSUQsT0FBTyxHQUFHLElBQUlsQyxPQUFKLENBQVlXLFNBQVMsR0FBR1ksV0FBeEIsRUFBcUNiLFdBQXJDLEVBQWtERCxTQUFsRCxDQUFkO0FBQ0EsTUFBSXVDLFFBQVEsR0FBR2QsT0FBTyxDQUFDZSxNQUFSLENBQWV4QixPQUFmLEVBQXdCQyxXQUF4QixDQUFmO0FBQ0EsU0FBUSxHQUFFSCxXQUFZLElBQUd5QixRQUFTLEVBQWxDO0FBQ0QsQ0FqQkQsQyxDQWtCQTs7QUFDQTs7Ozs7Ozs7O0FBT0E1QixPQUFPLENBQUM4QixnQkFBUixHQUEyQixDQUFDQyxXQUFELEVBQWNoQixPQUFPLEdBQUcsRUFBeEIsS0FBK0I7QUFDeEQ7QUFDQSxNQUFJLE9BQU9nQixXQUFQLEtBQXVCLFFBQTNCLEVBQ0UsTUFBTVQsS0FBSyxDQUFFLGlCQUFnQlMsV0FBWSxrQkFBOUIsQ0FBWDtBQUNGLE1BQUlSLEdBQUosQ0FKd0QsQ0FLeEQ7O0FBQ0EsTUFBS0EsR0FBRyxHQUFHQyxjQUFjLENBQUNULE9BQUQsQ0FBekIsRUFBcUM7QUFDbkNVLFdBQU8sQ0FBQ0MsSUFBUixDQUFjLHlCQUF3QkgsR0FBSSxFQUExQztBQUNBLFdBQU9JLFNBQVA7QUFDRCxHQVR1RCxDQVV4RDs7O0FBQ0EsUUFBTUssT0FBTyxHQUFHRCxXQUFXLENBQUNFLE9BQVosQ0FBb0IsS0FBcEIsRUFBMkIsRUFBM0IsQ0FBaEIsQ0FYd0QsQ0FZeEQ7O0FBQ0FGLGFBQVcsR0FBR0MsT0FBTyxDQUFDdEIsV0FBUixFQUFkO0FBQ0EsUUFBTTtBQUFFTCxXQUFGO0FBQVc2QjtBQUFYLE1BQXlCbkIsT0FBL0I7QUFDQSxNQUFJRCxPQUFPLEdBQUcsSUFBSWxDLE9BQUosQ0FBWVcsU0FBUyxHQUFHd0MsV0FBeEIsRUFBcUN6QyxXQUFyQyxFQUFrREQsU0FBbEQsQ0FBZDtBQUNBLE1BQUl1QyxRQUFRLEdBQUdkLE9BQU8sQ0FBQ2UsTUFBUixDQUFleEIsT0FBZixFQUF3QjZCLFNBQXhCLENBQWY7QUFDQSxTQUFRLEdBQUVILFdBQVksSUFBR0gsUUFBUyxFQUFsQztBQUNELENBbEJELEMsQ0FtQkE7QUFDQTs7O0FBQ0EsU0FBU0osY0FBVCxDQUF3QlcsTUFBeEIsRUFBZ0M7QUFDOUIsUUFBTUMsR0FBRyxHQUFHQyxNQUFNLENBQUNDLElBQVAsQ0FBWUgsTUFBWixDQUFaO0FBQ0EsTUFBSTNCLEtBQUssR0FBRyxFQUFaO0FBQ0E0QixLQUFHLENBQUNHLE9BQUosQ0FBWUMsR0FBRyxJQUFJO0FBQ2pCLFVBQU1DLEdBQUcsR0FBR04sTUFBTSxDQUFDSyxHQUFELENBQWxCOztBQUNBLFFBQUksQ0FBQ3JCLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQnFCLEdBQWpCLENBQUwsRUFBNEI7QUFDMUJqQyxXQUFLLElBQUssSUFBR2dDLEdBQUksdUJBQWpCO0FBQ0E7QUFDRDs7QUFDRCxRQUFJQyxHQUFHLEdBQUcsQ0FBVixFQUFhO0FBQ1hqQyxXQUFLLElBQUssSUFBR2dDLEdBQUksa0NBQWpCO0FBQ0E7QUFDRDs7QUFDRCxRQUFJQyxHQUFHLEdBQUd0QixNQUFNLENBQUN1QixnQkFBakIsRUFBbUM7QUFDakNsQyxXQUFLLElBQUssSUFBR2dDLEdBQUksOEJBQWpCO0FBQ0Q7QUFDRixHQWJEO0FBY0EsU0FBT2hDLEtBQVA7QUFDRCxDLENBRUQ7O0FBQ0E7Ozs7OztBQUlBUixPQUFPLENBQUMyQyxhQUFSLEdBQXdCLENBQUMsR0FBR0MsSUFBSixLQUFhO0FBQ25DLFFBQU1DLElBQUksR0FBRyxDQUFDLEdBQUdELElBQUosRUFBVUUsSUFBVixDQUFlLEdBQWYsQ0FBYjtBQUNBLFFBQU1OLEdBQUcsR0FBR3pELE1BQU0sQ0FBQzhELElBQUQsRUFBT3JELGNBQVAsQ0FBbEI7QUFDQSxTQUFPZ0QsR0FBUDtBQUNELENBSkQsQyxDQU1BOztBQUNBOzs7Ozs7QUFJQXhDLE9BQU8sQ0FBQytDLFlBQVIsR0FBdUJ0QyxLQUFLLElBQUk7QUFDOUIsUUFBTVMsT0FBTyxHQUFHbEIsT0FBTyxDQUFDQyxXQUFSLENBQW9CUSxLQUFwQixDQUFoQjtBQUNBLFFBQU07QUFBRUYsV0FBRjtBQUFXSixlQUFYO0FBQXdCRSxXQUF4QjtBQUFpQ0M7QUFBakMsTUFBaURZLE9BQXZEOztBQUNBLE1BQUlYLE9BQUosRUFBYTtBQUNYVixrQkFBYyxHQUFHTSxXQUFqQjtBQUNBTCxvQkFBZ0IsR0FBRztBQUNqQkssaUJBRGlCO0FBRWpCRSxhQUZpQjtBQUdqQkM7QUFIaUIsS0FBbkIsQ0FGVyxDQU9YO0FBQ0E7QUFDQTs7QUFDQSxRQUFJRCxPQUFPLEtBQUssQ0FBaEIsRUFBbUI7QUFDakJvQixhQUFPLENBQUNDLElBQVIsQ0FBYyx3QkFBdUJ2QixXQUFZLEdBQWpEO0FBQ0FMLHNCQUFnQixDQUFDb0MsU0FBakIsR0FBNkI1QixXQUE3QjtBQUNBUixzQkFBZ0IsQ0FBQ2lDLFdBQWpCLEdBQStCNUIsV0FBL0I7QUFDQUwsc0JBQWdCLENBQUNRLFdBQWpCLEdBQStCcUIsU0FBL0I7QUFDRDs7QUFDRCxRQUFJekMsR0FBSixFQUNFdUMsT0FBTyxDQUFDdUIsR0FBUixDQUFZLHdCQUFaLEVBQXNDN0MsV0FBdEMsRUFBbURFLE9BQW5ELEVBQTREQyxXQUE1RDtBQUNILEdBbEJELE1Ba0JPLElBQUlwQixHQUFKLEVBQVN1QyxPQUFPLENBQUN1QixHQUFSLENBQVksdUJBQVosRUFBcUN2QyxLQUFyQzs7QUFDaEIsU0FBT0YsT0FBUDtBQUNELENBdkJELEMsQ0F3QkE7O0FBQ0E7Ozs7O0FBR0FQLE9BQU8sQ0FBQ2lELEtBQVIsR0FBZ0IsTUFBTTtBQUNwQixNQUFJL0QsR0FBSixFQUFTdUMsT0FBTyxDQUFDdUIsR0FBUixDQUFZLGtCQUFaO0FBQ1RuRCxnQkFBYyxHQUFHOEIsU0FBakI7QUFDQTdCLGtCQUFnQixHQUFHNkIsU0FBbkI7QUFDQTVCLGNBQVksR0FBRzRCLFNBQWY7QUFDRCxDQUxELEMsQ0FNQTs7QUFDQTs7Ozs7O0FBSUEzQixPQUFPLENBQUNrRCxZQUFSLEdBQXVCVixHQUFHLElBQUk7QUFDNUIsTUFBSSxPQUFPQSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0J6QyxnQkFBWSxHQUFHeUMsR0FBZjtBQUNBLFFBQUl0RCxHQUFKLEVBQVN1QyxPQUFPLENBQUN1QixHQUFSLENBQVksb0JBQVosRUFBa0NSLEdBQWxDO0FBQ1Y7QUFDRixDQUxELEMsQ0FNQTs7QUFDQTs7Ozs7O0FBSUF4QyxPQUFPLENBQUNtRCxTQUFSLEdBQW9CLE1BQU07QUFDeEIsTUFBSWpFLEdBQUosRUFBU3VDLE9BQU8sQ0FBQ3VCLEdBQVIsQ0FBWSx1QkFBWixFQUFxQ2pELFlBQXJDO0FBQ1QsU0FBT0EsWUFBUDtBQUNELENBSEQsQyxDQUlBOzs7QUFDQUMsT0FBTyxDQUFDb0QsV0FBUixHQUFzQlosR0FBRyxJQUFJO0FBQzNCL0MsV0FBUyxHQUFHK0MsR0FBRyxJQUFJL0MsU0FBbkI7QUFDQSxTQUFPQSxTQUFQO0FBQ0QsQ0FIRCxDLENBSUE7O0FBQ0E7Ozs7O0FBR0FPLE9BQU8sQ0FBQ3FELFFBQVIsR0FBbUIsTUFBTTtBQUN2QixRQUFNQyxFQUFFLEdBQUc3RCxTQUFTLElBQUksS0FBeEI7QUFDQSxNQUFJUCxHQUFKLEVBQVN1QyxPQUFPLENBQUNDLElBQVIsQ0FBYSw0QkFBYjtBQUNULFNBQU80QixFQUFQO0FBQ0QsQ0FKRCxDLENBS0E7O0FBQ0E7Ozs7O0FBR0F0RCxPQUFPLENBQUN1RCxhQUFSLEdBQXdCLE1BQU07QUFDNUIsUUFBTTtBQUFFbEQsV0FBRjtBQUFXQyxlQUFYO0FBQXdCNEI7QUFBeEIsTUFBc0NwQyxnQkFBNUM7O0FBQ0EsTUFBSU8sT0FBTyxLQUFLLENBQWhCLEVBQW1CO0FBQ2pCLFdBQU87QUFBRTBCLGlCQUFXLEVBQUVsQyxjQUFmO0FBQStCcUM7QUFBL0IsS0FBUDtBQUNEOztBQUNELFNBQU87QUFBRS9CLGVBQVcsRUFBRU4sY0FBZjtBQUErQlEsV0FBL0I7QUFBd0NDO0FBQXhDLEdBQVA7QUFDRCxDQU5EOztBQU9BTixPQUFPLENBQUN3RCxTQUFSLEdBQW9CLE1BQU07QUFDeEIsU0FBT3hELE9BQU8sQ0FBQ3VELGFBQVIsR0FBd0JwRCxXQUF4QixLQUF3Q3dCLFNBQS9DO0FBQ0QsQ0FGRDs7QUFHQTNCLE9BQU8sQ0FBQ3lELFNBQVIsR0FBb0IsTUFBTTtBQUN4QixTQUFPekQsT0FBTyxDQUFDdUQsYUFBUixHQUF3QnhCLFdBQXhCLEtBQXdDSixTQUEvQztBQUNELENBRkQsQyxDQUdBOztBQUNBOzs7Ozs7QUFJQTNCLE9BQU8sQ0FBQzBELFlBQVIsR0FBdUIsTUFBTTtBQUMzQixTQUFPN0QsY0FBUDtBQUNELENBRkQsQyxDQUdBOztBQUNBOzs7Ozs7QUFJQUcsT0FBTyxDQUFDMkQsR0FBUixHQUFjLE1BQU07QUFDbEIsU0FBTzdELGdCQUFQO0FBQ0QsQ0FGRCxDLENBR0E7OztBQUNBRSxPQUFPLENBQUM0RCx3QkFBUixHQUFtQyxNQUFNbEUsYUFBekMsQyxDQUNBOzs7QUFDQU0sT0FBTyxDQUFDNkQsYUFBUixHQUF3QixNQUFNbEUsU0FBOUI7O0FBQ0FLLE9BQU8sQ0FBQzhELGlCQUFSLEdBQTRCLE1BQU1sRSxVQUFsQyxDLENBQ0E7QUFFQTtBQUNBOzs7QUFDQW1FLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQmhFLE9BQWpCIiwiZmlsZSI6Ii4vc3JjL3V0aWwvc2Vzc2lvbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZSAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuLyovLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBBQk9VVCBcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwqXFxcblxuICBTZXNzaW9uIFV0aWxpdGllc1xuICBjb2xsZWN0aW9uIG9mIHNlc3Npb24tcmVsYXRlZCBkYXRhIHN0cnVjdHVyZXNcblxuICBGb3Igc3R1ZGVudCBsb2dpbnMsIHdlIGp1c3QgbmVlZCB0byBlbmNvZGUgdGhlIGdyb3VwSWQsIHdoaWNoIHdpbGwgZ2l2ZVxuICB1cyB0aGUgY2xhc3Nyb29tSWQuIFdlIGFsc28gbmVlZCB0aGUgbmFtZSwgd2hpY2ggaXMgbm90IGVuY29kZWQsIGJ1dFxuICBjYW4gYmUgY2hlY2tlZCBhZ2FpbnN0IHRoZSBncm91cHMgZGF0YWJhc2UuXG5cbiAgPE5BTUU+LUhBU0hFRF9EQVRBXG4gIHdoZXJlIEhBU0hFRF9EQVRBIGVuY29kZXMgZ3JvdXBJZCwgY2xhc3Nyb29tSWRcblxuXFwqXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwgKiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyovXG5cbi8vLyBTWVNURU0gTElCUkFSSUVTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbmNvbnN0IEhhc2hJZHMgPSByZXF1aXJlKCdoYXNoaWRzL2NqcycpO1xuY29uc3QgVVVJRCA9IHJlcXVpcmUoJ3V1aWQnKTtcblxuY29uc3QgVVVJRHY1ID0gVVVJRC52NTtcbmNvbnN0IFBST01QVFMgPSByZXF1aXJlKCcuL3Byb21wdHMnKTtcblxuLy8vIERFQlVHR0lORyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuY29uc3QgREJHID0gZmFsc2U7XG5jb25zdCBQUiA9IFBST01QVFMubWFrZVN0eWxlRm9ybWF0dGVyKCdYU0VTJyk7XG5cbi8vLyBDT05TVEFOVFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8vLyBIQVNIXyogYXJlIHVzZWQgYXMgcGFyYW1ldGVycyBmb3IgaGFzaGlkcyAobG9naW4gdG9rZW5zKVxuY29uc3QgSEFTSF9BQkVUID0gJ0FCQ0RFRkdISUpLTE1OUFFSU1RWV1hZWjIzNDU2Nzg5JztcbmNvbnN0IEhBU0hfTUlOTEVOID0gMztcbmNvbnN0IEhBU0hfU0FMVCA9ICdNRU1FU0FMVC8yMDE5Jztcbi8vLyBVVUlEX05BTUVTUEFDRSB3YXMgYXJiaXRyYXJpbHkgZ2VuZXJhdGVkIHdpdGggJ25weCB1dWlkIHY0JyAoYWNjZXNzIGtleXMpXG5jb25zdCBVVUlEX05BTUVTUEFDRSA9ICcxYWJjODM5ZC1iMDRmLTQ4MWUtODdmZS01ZDY5YmQxOTA3YjInO1xubGV0IEFETUlOX0tFWSA9ICcnOyAvLyBzZXQgdG8gbm9uLWZhbHN5IHRvIGRpc2FibGUgYWRtaW4gY2hlY2tzXG5jb25zdCBBRE1JTl9RU1RSSU5HID0gJ2RhbmlzaHBvd2Vycyc7IC8vIHVzZWQgdG8gYnlwYXNzIGFkbWluIGxvY2FsaG9zdCB0ZXN0XG5jb25zdCBTU0hPVF9VUkwgPSAnL3NjcmVlbnNob3RzJztcbmNvbnN0IFVQTE9BRF9VUkwgPSBgJHtTU0hPVF9VUkx9L3VwbG9hZGA7XG5cbi8vLyBNT0RVTEUgREVDTEFSQVRJT05TIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbmxldCBtX2N1cnJlbnRfbmFtZTsgLy8gZ2xvYmFsIGRlY29kZWQgbmFtZSAob25seSBmb3IgYnJvd3NlcnMpXG5sZXQgbV9jdXJyZW50X2lkc29iaiA9IHt9OyAvLyBnbG9iYWwgZGVjb2RlZCBwcm9wcyAob25seSBmb3IgYnJvd3NlcnMpXG5sZXQgbV9hY2Nlc3Nfa2V5ID0gJyc7IC8vIGdsb2JhbCBhY2Nlc3Mga2V5IChzYXZlZCBvbmx5IGZvciBicm93c2VycylcblxuLy8vIFNFU1NJT04gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuY29uc3QgU0VTU0lPTiA9IHt9O1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyovIEdpdmVuIGEgdG9rZW4gb2YgZm9ybSBOQU1FLUhBU0hFRF9EQVRBLCByZXR1cm4gYW4gb2JqZWN0XG4gICAgY29udGFpbmluZyBhcyBtYW55IGRlY29kZWQgdmFsdWVzIGFzIHBvc3NpYmxlLiBDaGVjayBpc1ZhbGlkIGZvclxuICAgIGNvbXBsZXRlIGRlY29kZSBzdWNjZXMuIGdyb3VwSWQgaXMgYWxzbyBzZXQgaWYgc3VjY2Vzc2Z1bFxuLyovXG5TRVNTSU9OLkRlY29kZVRva2VuID0gaGFzaGVkVG9rZW4gPT4ge1xuICBsZXQgc3R1ZGVudE5hbWU7XG4gIGxldCBoYXNoZWREYXRhOyAvLyB0b2tlblxuICBsZXQgZ3JvdXBJZDtcbiAgbGV0IGNsYXNzcm9vbUlkOyAvLyBkZWNvZGVkIGRhdGFcbiAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcbiAgLy8gaXMgYSB2YWxpZCB0b2tlbj9cbiAgaWYgKHR5cGVvZiBoYXNoZWRUb2tlbiAhPT0gJ3N0cmluZycpXG4gICAgcmV0dXJuIHsgaXNWYWxpZCwgZXJyb3I6ICd0b2tlbiBtdXN0IGJlIGEgc3RyaW5nJyB9O1xuICAvLyB0b2tlbiBpcyBvZiBmb3JtIE5BTUUtSEFTSEVESURcbiAgLy8gKDEpIGNoZWNrIHN0dWRlbnQgbmFtZVxuICBjb25zdCB0b2tlbiA9IGhhc2hlZFRva2VuLnRvVXBwZXJDYXNlKCk7XG4gIGNvbnN0IHRva2VuQml0cyA9IHRva2VuLnRvVXBwZXJDYXNlKCkuc3BsaXQoJy0nKTtcbiAgaWYgKHRva2VuQml0cy5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuIHsgaXNWYWxpZCwgdG9rZW4sIGVycm9yOiAnbWlzc2luZyAtIGluIHRva2VuJyB9O1xuICBpZiAodG9rZW5CaXRzLmxlbmd0aCA+IDIpXG4gICAgcmV0dXJuIHsgaXNWYWxpZCwgdG9rZW4sIGVycm9yOiAndG9vIG1hbnkgLSBpbiB0b2tlbicgfTtcbiAgaWYgKHRva2VuQml0c1swXSkgc3R1ZGVudE5hbWUgPSB0b2tlbkJpdHNbMF0udG9VcHBlckNhc2UoKTtcbiAgaWYgKHN0dWRlbnROYW1lLmxlbmd0aCA8IDMpXG4gICAgcmV0dXJuIHsgaXNWYWxpZCwgdG9rZW4sIGVycm9yOiAnc3R1ZGVudCBuYW1lIG11c3QgaGF2ZSAzIG9yIG1vcmUgbGV0dGVycycgfTtcblxuICAvLyAoMikgY2hlY2sgaGFzaGVkIGRhdGFcbiAgaWYgKHRva2VuQml0c1sxXSkgaGFzaGVkRGF0YSA9IHRva2VuQml0c1sxXS50b1VwcGVyQ2FzZSgpO1xuICAvLyBpbml0aWFsaXplIGhhc2hpZCBzdHJ1Y3R1cmVcbiAgbGV0IGhhc2hpZHMgPSBuZXcgSGFzaElkcyhIQVNIX1NBTFQgKyBzdHVkZW50TmFtZSwgSEFTSF9NSU5MRU4sIEhBU0hfQUJFVCk7XG4gIC8vIHRyeSB0byBkZWNvZGUgdGhlIGdyb3VwSWRcbiAgY29uc3QgZGF0YUlkcyA9IGhhc2hpZHMuZGVjb2RlKGhhc2hlZERhdGEpO1xuICAvLyBpbnZhbGlkYXRlIGlmIGNvdWxkbid0IGRlY29kZVxuICBpZiAoZGF0YUlkcy5sZW5ndGggPT09IDApIHJldHVybiB7IGlzVmFsaWQsIHRva2VuLCBlcnJvcjogJ2ludmFsaWQgdG9rZW4nIH07XG5cbiAgLy8gYXQgdGhpcyBwb2ludCBncm91cElkIGlzIHZhbGlkIChiZWdpbnMgd2l0aCBJRCwgYWxsIG51bWVyaWMpXG4gIC8vIGNoZWNrIGZvciB2YWxpZCBzdWJncm91cElkXG4gIFtncm91cElkLCBjbGFzc3Jvb21JZF0gPSBkYXRhSWRzO1xuICBpc1ZhbGlkID0gdHJ1ZTtcbiAgcmV0dXJuIHsgaXNWYWxpZCwgc3R1ZGVudE5hbWUsIHRva2VuLCBncm91cElkLCBjbGFzc3Jvb21JZCB9O1xufTtcbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qLyBSZXR1cm4gVFJVRSBpZiB0aGUgdG9rZW4gZGVjb2RlcyBpbnRvIGFuIGV4cGVjdGVkIHJhbmdlIG9mIHZhbHVlc1xuLyovXG5TRVNTSU9OLklzVmFsaWRUb2tlbiA9IHRva2VuID0+IHtcbiAgbGV0IGRlY29kZWQgPSBTRVNTSU9OLkRlY29kZVRva2VuKHRva2VuKTtcbiAgcmV0dXJuIChcbiAgICBkZWNvZGVkICYmXG4gICAgTnVtYmVyLmlzSW50ZWdlcihkZWNvZGVkLmdyb3VwSWQpICYmXG4gICAgdHlwZW9mIGRlY29kZWQuc3R1ZGVudE5hbWUgPT09ICdzdHJpbmcnXG4gICk7XG59O1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqXG4gKiBSZXR1cm5zIGEgdG9rZW4gc3RyaW5nIG9mIGZvcm0gTkFNRS1IQVNIRURfREFUQVxuICogQHBhcmFtIHtTdHJpbmd9IHN0dWRlbnROYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YUlkc1xuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGFJZHMuZ3JvdXBJZFxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGFJZHMuY2xhc3Nyb29tSWRcbiAqL1xuU0VTU0lPTi5NYWtlVG9rZW4gPSAoc3R1ZGVudE5hbWUsIGRhdGFJZHMgPSB7fSkgPT4ge1xuICAvLyB0eXBlIGNoZWNraW5nXG4gIGlmICh0eXBlb2Ygc3R1ZGVudE5hbWUgIT09ICdzdHJpbmcnKVxuICAgIHRocm93IEVycm9yKGBjbGFzc0lkIGFyZzEgJyR7c3R1ZGVudE5hbWV9JyBtdXN0IGJlIHN0cmluZ2ApO1xuICBsZXQgZXJyO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgaWYgKChlcnIgPSBmX2NoZWNrSWRWYWx1ZShkYXRhSWRzKSkpIHtcbiAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBtYWtlIHRva2VuLiAke2Vycn1gKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSBoYXNoaWQgc3RydWN0dXJlXG4gIHN0dWRlbnROYW1lID0gc3R1ZGVudE5hbWUudG9VcHBlckNhc2UoKTtcbiAgY29uc3QgeyBncm91cElkLCBjbGFzc3Jvb21JZCB9ID0gZGF0YUlkcztcbiAgbGV0IGhhc2hpZHMgPSBuZXcgSGFzaElkcyhIQVNIX1NBTFQgKyBzdHVkZW50TmFtZSwgSEFTSF9NSU5MRU4sIEhBU0hfQUJFVCk7XG4gIGxldCBoYXNoZWRJZCA9IGhhc2hpZHMuZW5jb2RlKGdyb3VwSWQsIGNsYXNzcm9vbUlkKTtcbiAgcmV0dXJuIGAke3N0dWRlbnROYW1lfS0ke2hhc2hlZElkfWA7XG59O1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqXG4gKiBSZXR1cm5zIGEgdG9rZW4gc3RyaW5nIG9mIGZvcm0gTkFNRS1IQVNIRURfREFUQVxuICogQHBhcmFtIHtTdHJpbmd9IHRlYWNoZXJOYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YUlkc1xuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGFJZHMuZ3JvdXBJZFxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGFJZHMudGVhY2hlcklkXG4gKi9cblNFU1NJT04uTWFrZVRlYWNoZXJUb2tlbiA9ICh0ZWFjaGVyTmFtZSwgZGF0YUlkcyA9IHt9KSA9PiB7XG4gIC8vIHR5cGUgY2hlY2tpbmdcbiAgaWYgKHR5cGVvZiB0ZWFjaGVyTmFtZSAhPT0gJ3N0cmluZycpXG4gICAgdGhyb3cgRXJyb3IoYGNsYXNzSWQgYXJnMSAnJHt0ZWFjaGVyTmFtZX0nIG11c3QgYmUgc3RyaW5nYCk7XG4gIGxldCBlcnI7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICBpZiAoKGVyciA9IGZfY2hlY2tJZFZhbHVlKGRhdGFJZHMpKSkge1xuICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IG1ha2UgdG9rZW4uICR7ZXJyfWApO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgLy8gY29udmVydCB0byBhbHBoYW51bWVyaWMgbm8gc3BhY2VzXG4gIGNvbnN0IHRva05hbWUgPSB0ZWFjaGVyTmFtZS5yZXBsYWNlKC9cXFcvZywgJycpO1xuICAvLyBpbml0aWFsaXplIGhhc2hpZCBzdHJ1Y3R1cmVcbiAgdGVhY2hlck5hbWUgPSB0b2tOYW1lLnRvVXBwZXJDYXNlKCk7XG4gIGNvbnN0IHsgZ3JvdXBJZCwgdGVhY2hlcklkIH0gPSBkYXRhSWRzO1xuICBsZXQgaGFzaGlkcyA9IG5ldyBIYXNoSWRzKEhBU0hfU0FMVCArIHRlYWNoZXJOYW1lLCBIQVNIX01JTkxFTiwgSEFTSF9BQkVUKTtcbiAgbGV0IGhhc2hlZElkID0gaGFzaGlkcy5lbmNvZGUoZ3JvdXBJZCwgdGVhY2hlcklkKTtcbiAgcmV0dXJuIGAke3RlYWNoZXJOYW1lfS0ke2hhc2hlZElkfWA7XG59O1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLy8vIHN1cHBvcnQgZnVuY3Rpb25cbmZ1bmN0aW9uIGZfY2hlY2tJZFZhbHVlKGlkc09iaikge1xuICBjb25zdCBpZHMgPSBPYmplY3Qua2V5cyhpZHNPYmopO1xuICBsZXQgZXJyb3IgPSAnJztcbiAgaWRzLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCB2YWwgPSBpZHNPYmpba2V5XTtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsKSkge1xuICAgICAgZXJyb3IgKz0gYCcke2tleX0nIGlzIG5vdCBhbiBpbnRlZ2VyLiBgO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsIDwgMCkge1xuICAgICAgZXJyb3IgKz0gYCcke2tleX0nIG11c3QgYmUgbm9uLW5lZ2F0aXZlIGludGVnZXIuIGA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWwgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgZXJyb3IgKz0gYCcke2tleX0nIGV4Y2VlZHMgTUFYX1NBRkVfSU5URUdFUi4gYDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZXJyb3I7XG59XG5cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKiBNYWtlcyBhICdhY2Nlc3Mga2V5JyB0aGF0IGlzIG5vdCB2ZXJ5IHNlY3VyZSwgYnV0IHVuaXF1ZSBlbm91Z2ggdG8gc2VydmVcbiAqIGFzIGFuIGF1dGhlbnRpY2F0aW9uIGtleSBiYXNlZCBvbiBhIGxvZ2luIHRva2VuXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIC0gc3RyaW5nIGFyZ3VtZW50c1xuICovXG5TRVNTSU9OLk1ha2VBY2Nlc3NLZXkgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBuYW1lID0gWy4uLmFyZ3NdLmpvaW4oJzonKTtcbiAgY29uc3Qga2V5ID0gVVVJRHY1KG5hbWUsIFVVSURfTkFNRVNQQUNFKTtcbiAgcmV0dXJuIGtleTtcbn07XG5cbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKlxuICogU2V0IHRoZSBnbG9iYWwgR1JPVVBJRCwgd2hpY2ggaXMgaW5jbHVkZWQgaW4gYWxsIE5ldFBhY2tldCBvYmplY3RzIHRoYXQgYXJlXG4gKiBzZW50IHRvIHNlcnZlci4gRG8gbm90IHVzZSBmcm9tIHNlcnZlci1iYXNlZCBjb2RlLlxuICovXG5TRVNTSU9OLkRlY29kZUFuZFNldCA9IHRva2VuID0+IHtcbiAgY29uc3QgZGVjb2RlZCA9IFNFU1NJT04uRGVjb2RlVG9rZW4odG9rZW4pO1xuICBjb25zdCB7IGlzVmFsaWQsIHN0dWRlbnROYW1lLCBncm91cElkLCBjbGFzc3Jvb21JZCB9ID0gZGVjb2RlZDtcbiAgaWYgKGlzVmFsaWQpIHtcbiAgICBtX2N1cnJlbnRfbmFtZSA9IHN0dWRlbnROYW1lO1xuICAgIG1fY3VycmVudF9pZHNvYmogPSB7XG4gICAgICBzdHVkZW50TmFtZSxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBjbGFzc3Jvb21JZFxuICAgIH07XG4gICAgLy8gaGFuZGxlIHRlYWNoZXIgbG9naW5cbiAgICAvLyBpbiB0aGlzIGNhc2UsIHRoZSBncm91cElkIGlzIDAgYW5kIGNsYXNzcm9vbUlkIGlzIGFjdHVhbGx5XG4gICAgLy8gdGVhY2hlcklkLCBzbyB1cGRhdGUgdGhlIG9iamVjdFxuICAgIGlmIChncm91cElkID09PSAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oYElORk86IFRFQUNIRVIgTE9HSU4gJyR7c3R1ZGVudE5hbWV9J2ApO1xuICAgICAgbV9jdXJyZW50X2lkc29iai50ZWFjaGVySWQgPSBjbGFzc3Jvb21JZDtcbiAgICAgIG1fY3VycmVudF9pZHNvYmoudGVhY2hlck5hbWUgPSBzdHVkZW50TmFtZTtcbiAgICAgIG1fY3VycmVudF9pZHNvYmouY2xhc3Nyb29tSWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChEQkcpXG4gICAgICBjb25zb2xlLmxvZygnRGVjb2RlQW5kU2V0KCkgc3VjY2VzcycsIHN0dWRlbnROYW1lLCBncm91cElkLCBjbGFzc3Jvb21JZCk7XG4gIH0gZWxzZSBpZiAoREJHKSBjb25zb2xlLmxvZygnRGVjb2RlQW5kU2V0KCkgZmFpbGVkJywgdG9rZW4pO1xuICByZXR1cm4gaXNWYWxpZDtcbn07XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKipcbiAqIENsZWFyIGFsbCBnbG9iYWwgc2Vzc2lvbiBwYXJhbWV0ZXJzLiBEbyBub3QgdXNlIGZyb20gc2VydmVyLWJhc2VkIGNvZGUuXG4gKi9cblNFU1NJT04uQ2xlYXIgPSAoKSA9PiB7XG4gIGlmIChEQkcpIGNvbnNvbGUubG9nKCdDbGVhcmluZyBzZXNzaW9uJyk7XG4gIG1fY3VycmVudF9uYW1lID0gdW5kZWZpbmVkO1xuICBtX2N1cnJlbnRfaWRzb2JqID0gdW5kZWZpbmVkO1xuICBtX2FjY2Vzc19rZXkgPSB1bmRlZmluZWQ7XG59O1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqXG4gKiBTZXQgdGhlIGdsb2JhbCBTRVNTSU9OIEFDQ0VTUyBLRVksIHdoaWNoIGlzIG5lY2Vzc2FyeSBhcyBhIHBhcmFtZXRlciBmb3JcbiAqIHNvbWUgb3BlcmF0aW9ucyAoZS5nLiBkYXRhYmFzZSB3cml0ZXMpLiBEbyBub3QgdXNlIGZyb20gc2VydmVyLWJhc2VkIGNvZGUuXG4gKi9cblNFU1NJT04uU2V0QWNjZXNzS2V5ID0ga2V5ID0+IHtcbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgbV9hY2Nlc3Nfa2V5ID0ga2V5O1xuICAgIGlmIChEQkcpIGNvbnNvbGUubG9nKCdzZXR0aW5nIGFjY2VzcyBrZXknLCBrZXkpO1xuICB9XG59O1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLyoqXG4gKiBSZXR1cm4gdGhlIGdsb2JhbCBTRVNTSU9OIEFDQ0VTUyBLRVkgdGhhdCB3YXMgc2V0IHVzaW5nIFNldEFjY2Vzc0tleSgpLiBEb24ndFxuICogdXNlIHRoaXMgZnJvbSBzZXJ2ZXItYmFzZWQgY29kZS5cbiAqL1xuU0VTU0lPTi5BY2Nlc3NLZXkgPSAoKSA9PiB7XG4gIGlmIChEQkcpIGNvbnNvbGUubG9nKCdBY2Nlc3NLZXkoKSByZXR1cm5pbmcnLCBtX2FjY2Vzc19rZXkpO1xuICByZXR1cm4gbV9hY2Nlc3Nfa2V5O1xufTtcbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblNFU1NJT04uU2V0QWRtaW5LZXkgPSBrZXkgPT4ge1xuICBBRE1JTl9LRVkgPSBrZXkgfHwgQURNSU5fS0VZO1xuICByZXR1cm4gQURNSU5fS0VZO1xufTtcbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKlxuICogVGhpcyBpcyBUT1RBTExZIElOU0VDVVJFIGFuZCBub3QgZXZlbiB0cnlpbmcgZm9yIHRoZSBwcm90b3R5cGVcbiAqL1xuU0VTU0lPTi5BZG1pbktleSA9ICgpID0+IHtcbiAgY29uc3QgaXMgPSBBRE1JTl9LRVkgfHwgZmFsc2U7XG4gIGlmIChEQkcpIGNvbnNvbGUud2FybignSU5GTzogcmVxdWVzdGVkIEFkbWluS2V5KCknKTtcbiAgcmV0dXJuIGlzO1xufTtcbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKlxuICogUmV0dXJuIHRlYWNoZXJJZCBpZiB0aGlzIGlzIGEgbG9nZ2VkLWluIHRlYWNoZXJcbiAqL1xuU0VTU0lPTi5Mb2dnZWRJblByb3BzID0gKCkgPT4ge1xuICBjb25zdCB7IGdyb3VwSWQsIGNsYXNzcm9vbUlkLCB0ZWFjaGVySWQgfSA9IG1fY3VycmVudF9pZHNvYmo7XG4gIGlmIChncm91cElkID09PSAwKSB7XG4gICAgcmV0dXJuIHsgdGVhY2hlck5hbWU6IG1fY3VycmVudF9uYW1lLCB0ZWFjaGVySWQgfTtcbiAgfVxuICByZXR1cm4geyBzdHVkZW50TmFtZTogbV9jdXJyZW50X25hbWUsIGdyb3VwSWQsIGNsYXNzcm9vbUlkIH07XG59O1xuU0VTU0lPTi5Jc1N0dWRlbnQgPSAoKSA9PiB7XG4gIHJldHVybiBTRVNTSU9OLkxvZ2dlZEluUHJvcHMoKS5zdHVkZW50TmFtZSAhPT0gdW5kZWZpbmVkO1xufTtcblNFU1NJT04uSXNUZWFjaGVyID0gKCkgPT4ge1xuICByZXR1cm4gU0VTU0lPTi5Mb2dnZWRJblByb3BzKCkudGVhY2hlck5hbWUgIT09IHVuZGVmaW5lZDtcbn07XG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG4vKipcbiAqIFJldHVybiB0aGUgZ2xvYmFsIExvZ2dlZEluTmFtZSB0aGF0IHdhcyBzZXQgdXNpbmcgRGVjb2RlQW5kU2V0KCkuIERvbid0IHVzZVxuICogdGhpcyBmcm9tIHNlcnZlci1iYXNlZCBjb2RlLlxuICovXG5TRVNTSU9OLkxvZ2dlZEluTmFtZSA9ICgpID0+IHtcbiAgcmV0dXJuIG1fY3VycmVudF9uYW1lO1xufTtcbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8qKlxuICogUmV0dXJuIHRoZSBnbG9iYWwgaWRzT2JqZWN0IGNvbnRhaW5pbmcgZ3JvdXBJZCwgY2xhc3Nyb29tSWQgdGhhdCB3YXMgc2V0XG4gKiB1c2luZyBEZWNvZGVBbmRTZXQoKS4gRG9uJ3QgdXNlIHRoaXMgZnJvbSBzZXJ2ZXItYmFzZWQgY29kZS5cbiAqL1xuU0VTU0lPTi5JZHMgPSAoKSA9PiB7XG4gIHJldHVybiBtX2N1cnJlbnRfaWRzb2JqO1xufTtcbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblNFU1NJT04uQWRtaW5QbGFpbnRleHRQYXNzcGhyYXNlID0gKCkgPT4gQURNSU5fUVNUUklORztcbi8vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblNFU1NJT04uU2NyZWVuc2hvdFVSTCA9ICgpID0+IFNTSE9UX1VSTDtcblNFU1NJT04uU2NyZWVuc2hvdFBvc3RVUkwgPSAoKSA9PiBVUExPQURfVVJMO1xuLy8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuXG4vLy8gRVhQT1JUIE1PRFVMRSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5tb2R1bGUuZXhwb3J0cyA9IFNFU1NJT047XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/util/session.js\n");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"assert\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJhc3NlcnRcIj84MTcyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6ImFzc2VydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImFzc2VydFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///assert\n");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"buffer\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJidWZmZXJcIj9iZmZhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6ImJ1ZmZlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJ1ZmZlclwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///buffer\n");

/***/ }),

/***/ "constants":
/*!****************************!*\
  !*** external "constants" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"constants\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjb25zdGFudHNcIj83MzU4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6ImNvbnN0YW50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvbnN0YW50c1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///constants\n");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjcnlwdG9cIj80Yzc2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6ImNyeXB0by5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNyeXB0b1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///crypto\n");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJldmVudHNcIj83YTdlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6ImV2ZW50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImV2ZW50c1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///events\n");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJmc1wiP2E0MGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiZnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJmc1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///fs\n");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"http\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwXCI/OGQxOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJodHRwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///http\n");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"https\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwc1wiP2Q1NTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiaHR0cHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwc1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///https\n");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"net\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJuZXRcIj8yMWVkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6Im5ldC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5ldFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///net\n");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"os\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJvc1wiP2I3MTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoib3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJvc1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///os\n");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJwYXRoXCI/NzRiYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJwYXRoLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicGF0aFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///path\n");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"stream\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzdHJlYW1cIj83NTdmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6InN0cmVhbS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInN0cmVhbVwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///stream\n");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"tls\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ0bHNcIj85NGNiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6InRscy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRsc1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///tls\n");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"url\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1cmxcIj82MWU4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6InVybC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInVybFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///url\n");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1dGlsXCI/YmUwYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJ1dGlsLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXRpbFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///util\n");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"zlib\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ6bGliXCI/ZTU5MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJ6bGliLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiemxpYlwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///zlib\n");

/***/ })

/******/ })));